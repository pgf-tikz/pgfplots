%--------------------------------------------
%
% Package numtable
%
% Provides support to read and work with abstact numeric tables of the
% form
%
% COLUMN1	COLUMN2 COLUMN3
% 1 		2		3
% 4			4		552
% 1e124		0.00001	1.2345e-12
% ...
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------


% This file provides a high-level table manipulation and typesetting
% package.
%
%
% ---------------------------------------------
%  Implementation notes for programmers:
% ---------------------------------------------
%
%  The table data structure consists of
%  1. A name which must be a valid TeX macro like '\table'
%  2. A column list in the \pgfplotslist format.
%   In fact, the column list is stored in the table's name:
%   	\pgfplotslistnewempty\table
%  3. A "file name" stored in
%     \csname\string<\namemacro>@@table@name\endcsname
%  4. A "scan line length" number stored in
%  		\csname\string<\namemacro>@@table@scanline\endcsname
%  		It contains the value of \pgfplotsscanlinelength which has
%  		been identified right after \pgfplotstableread.
%  5. foreach column, there is a list of row-values (a row-vector) in
%  the \pgfplotslist format named
%  		\csname\string<\namemacro>@<column name>\endcsname
%   


\newif\ifpgfplotstable@search@header
\newif\ifpgfplotstable@firstline@is@header
\newcount\c@pgfplotstable@counta
\newwrite\pgfplotstable@outfile
\newif\ifpgfplotstabletypesetdebug
\newif\ifpgfplotstabletypesetskipcoltypes
\newif\ifpgfplotstabletypesetresult
\newif\ifpgfplotstableuserow
\newif\ifpgfplotstabletypeset@includeoutfiles
\newif\ifpgfplotstabletypeset@force@remake
\newif\ifpgfplots@addplotimpl@readcompletely
\newif\ifpgfplotstable@disable@rowcolstyles

% should always be false; use only in grouped internal macros
\newif\ifpgfplots@table@options@areset
\newif\ifpgfplots@tableread@to@listener
\newif\ifpgfplots@tableread@use@begingroup

\input pgfplotstable.coltype.code.tex

% #1= floating point number
% #2= TeX code to execute if #1 == 0
% #3= TeX code to execute if #1 != 0
\def\pgfplots@ifzero#1#2#3{%
	\expandafter\pgfmathfloat@decompose@F#1\relax\pgfmathfloat@a@S
	\ifnum\pgfmathfloat@a@S=0 #2\else#3\fi
}%

% just make sure no-one complaints if manual example are used without
% booktabs loaded:
\pgfutil@ifundefined{toprule}{%
	\def\toprule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\toprule}}%
	\def\midrule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\midrule}}%
	\def\bottomrule{\pgfplots@assert@LaTeX@package@loaded{booktabs}{\string\bottomrule}}%
}{\relax}%

% keys which are NOT predefined:
% /pgfplots/table/alias/<col alias>/.initial={<real col>}
% /pgfplots/table/columns/<col name>/.style={}
% /pgfplots/table/display columns/<col index>/.style={}
% /pgfplots/table/create on use/<col name>/.style={create options}
\pgfkeys{%
	/pgfplots/table/header/.is choice,
	/pgfplots/table/header/true/.code={\pgfplotstable@firstline@is@headerfalse\pgfplotstable@search@headertrue},
	/pgfplots/table/header/false/.code={\pgfplotstable@firstline@is@headerfalse\pgfplotstable@search@headerfalse},
	/pgfplots/table/header/has colnames/.code={\pgfplotstable@firstline@is@headertrue\pgfplotstable@search@headerfalse},
	/pgfplots/table/header=true,
	/pgfplots/table/x index/.initial=0,
	/pgfplots/table/x/.initial=,
	/pgfplots/table/x expr/.initial=,
	/pgfplots/table/y index/.initial=1,
	/pgfplots/table/y/.initial=,
	/pgfplots/table/y expr/.initial=,
	/pgfplots/table/z index/.initial=2,
	/pgfplots/table/z/.initial=,
	/pgfplots/table/z expr/.initial=,
	/pgfplots/table/meta index/.initial=,
	/pgfplots/table/meta/.initial=,
	/pgfplots/table/meta expr/.initial=,
	/pgfplots/table/x error index/.initial=,
	/pgfplots/table/y error index/.initial=,
	/pgfplots/table/z error index/.initial=,
	/pgfplots/table/x error/.initial=,
	/pgfplots/table/y error/.initial=,
	/pgfplots/table/z error/.initial=,
	/pgfplots/table/x error expr/.initial=,
	/pgfplots/table/y error expr/.initial=,
	/pgfplots/table/z error expr/.initial=,
	/pgfplots/table/ignore chars/.initial=,
	/pgfplots/table/white space chars/.initial=,
	/pgfplots/table/read completely/.is if=pgfplots@addplotimpl@readcompletely,
	/pgfplots/table/read completely/.default=true,
	/pgfplots/table/disable rowcol styles/.is if=pgfplotstable@disable@rowcolstyles,
	/pgfplots/table/disable rowcol styles/.default=true,
	/pgfplots/table/row predicate/.code={},
	/pgfplots/table/skip rows between index/.style 2 args={%
		/pgfplots/table/row predicate/.append code={%
			\ifnum##1<#1\relax
			\else
				\ifnum##1<#2\relax
					\pgfplotstableuserowfalse
				\fi
			\fi}
	},
	/pgfplots/table/select equal part entry of/.style 2 args={%
		/pgfplots/table/row predicate/.code={%
			\pgfplotstableuserowtrue
			\begingroup
			% this group re-uses counters as temporary variables.
			\c@pgfplotstable@colindex=\pgfplotstablerows\relax
			\divide\c@pgfplotstable@colindex by#2\relax
			\edef\pgfplotstablepartsize{\the\c@pgfplotstable@colindex}%
			% This here should create empty cells such that
			% remaining entries are distributed equally:
			\c@pgfplotstable@rowindex=\c@pgfplotstable@colindex
			\multiply\c@pgfplotstable@rowindex by#2\relax
			\ifnum\c@pgfplotstable@rowindex<\pgfplotstablerows\relax
				\c@pgfplotstable@colindex=\pgfplotstablerows\relax
				\advance\c@pgfplotstable@colindex by-\c@pgfplotstable@rowindex
				\advance\c@pgfplotstable@colindex by\pgfplotstablepartsize				
				\edef\pgfplotstablepartsize{\the\c@pgfplotstable@colindex}%
			\fi
			%
			\multiply\c@pgfplotstable@colindex by#1\relax
			\ifnum##1<\c@pgfplotstable@colindex\relax
				\aftergroup\pgfplotstableuserowfalse
			\else
				\advance\c@pgfplotstable@colindex by\pgfplotstablepartsize\relax
				\ifnum##1<\c@pgfplotstable@colindex\relax
				\else
					\aftergroup\pgfplotstableuserowfalse
				\fi
			\fi
			\endgroup
		}%
	},
	% #1: colname
	/pgfplots/table/unique/.code={%
		\pgfkeys{/pgfplots/table/row predicate/.append code={%
			\ifnum\pgfplotstablerow=0
				\ifnum\pgfplotstablecol=0
					% PREPARE ONCE! Assemble the boolean results into
					% a list which is used for the complete table:
					\expandafter\pgfplotstablegetcolumnfromstruct\expandafter{\expandafter\pgfplotstablecolname\expandafter}\expandafter\of\pgfplotstablename\to\pgfplotstable@unique@col
					\pgfplotslistnewempty\pgfplotstable@unique@bitlist
					\let\pgfplotstable@unique@LAST=\relax
					\pgfplotslistforeachungrouped\pgfplotstable@unique@col\as\pgfplotstable@unique@cur{%
						\def\pgfplotstable@unique@bit{1}%
						\ifx\pgfplotstable@unique@LAST\relax
						\else
							\ifx\pgfplotstable@unique@LAST\pgfplotstable@unique@cur
								\def\pgfplotstable@unique@bit{0}%
							\fi
						\fi
						\expandafter\pgfplotslistpushback\pgfplotstable@unique@bit\to\pgfplotstable@unique@bitlist
						\let\pgfplotstable@unique@LAST=\pgfplotstable@unique@cur
					}%
					\global\let\pgfplotstable@unique@bitlist@backup=\pgfplotstable@unique@bitlist
				\else
					\ifx\pgfplotstable@unique@bitlist@backup\relax
						% this sanity checking is NOT fool proof: it
						% fails if there are different occurances of
						% unique in the same file
						\pgfplotstable@error{Sorry, the row predicate /pgfplots/table/unique={#1} has been used in the wrong context: it needs to be invoked for the very first processed column, not column no \pgfplotstablecol. Please provide it as argument to \string\pgfplotstabletypeset[unique={#1}] and not inside of column-specific styles.}%
					\fi
				\fi
				% acquire the assembled list here: we'll do a lot of
				% popfronts with it.
				\let\pgfplotstable@unique@bitlist=\pgfplotstable@unique@bitlist@backup
			\fi
			\pgfplotslistcheckempty\pgfplotstable@unique@bitlist
			\ifpgfplotslistempty
				% should not happen!
				\pgfplotstableuserowfalse
			\else
				\pgfplotslistpopfront\pgfplotstable@unique@bitlist\to\pgfplots@loc@TMPa
				\if\pgfplots@loc@TMPa0%
					\pgfplotstableuserowfalse
				\fi
			\fi
		}}%
	},%
	/pgfplots/table/col sep/.is choice,
	/pgfplots/table/col sep/space/.code		= {\def\pgfplotstableread@COLSEP@CASE{0}},
	/pgfplots/table/col sep/comma/.code		= {\def\pgfplotstableread@COLSEP@CASE{1}},
	/pgfplots/table/col sep/semicolon/.code	= {\def\pgfplotstableread@COLSEP@CASE{2}},
	/pgfplots/table/col sep/colon/.code		= {\def\pgfplotstableread@COLSEP@CASE{3}},
	/pgfplots/table/col sep/braces/.code	= {\def\pgfplotstableread@COLSEP@CASE{4}},
	/pgfplots/table/col sep/tab/.code		= {\def\pgfplotstableread@COLSEP@CASE{5}},
	/pgfplots/table/col sep/&/.code			= {\def\pgfplotstableread@COLSEP@CASE{6}},
	/pgfplots/table/col sep/ampersand/.code	= {\def\pgfplotstableread@COLSEP@CASE{6}},
	/pgfplots/table/col sep=space,
	/pgfplots/table/format/.is choice,
	/pgfplots/table/format/auto/.code		= {\def\pgfplotstableread@FORMAT@CASE{0}},
	/pgfplots/table/format/inline/.code		= {\def\pgfplotstableread@FORMAT@CASE{1}},
	/pgfplots/table/format/file/.code		= {\def\pgfplotstableread@FORMAT@CASE{2}},
	/pgfplots/table/format=auto,
	/pgfplots/table/row sep/.code={%
		\pgfplotsutilifstringequal{#1}{\\}{%
			\def\pgfplotstableread@ROWSEP@CASE{1}%
		}{%
			\pgfplotsutilifstringequal{#1}{crcr}{%
				\def\pgfplotstableread@ROWSEP@CASE{1}%
			}{%
				\pgfplotsutilifstringequal{#1}{newline}{%
					\def\pgfplotstableread@ROWSEP@CASE{0}%
				}{%
					{%
					\t@pgfplots@tokc={#1}%
					\pgfplotsthrow{invalid argument}{\pgfplots@loc@TMPa}{Sorry, the choice `row sep=\the\t@pgfplots@tokc' is not known. Maybe you misspelled it? Try `\string\\' or `newline'.}\pgfeov%
					}%
				}%
			}%
		}%
	},%
	/pgfplots/table/row sep=newline,
	% columns={name1,name2}
	% or
	% columns={[index]2,name2,name3,[index]5}
	/pgfplots/table/columns/.initial=,
	/pgfplots/table/column name/.initial=\pgfkeysnovalue,
	%
	% this thing here allows to MODIFY 'column name'.
	%
	% Argument #1 is the current column name, that means after
	% evaluating 'column name'. If this key changes anything, it
	% should write its result back into 'column name'.
	%
	% That means you can use 'column name' to assign the name as such
	% and 'assign column name' to generate final TeX code (for example
	% to insert \multicolumn{1}{c}{#1} or so).
	% default is empty which means no change.
	%/pgfplots/table/assign column name/.code={
	%	\pgfkeyssetvalue{/pgfplots/table/column name}{#1}%
	%},
	%
	%
	%
	% A style which inserts \multicolumn{1}{#1}{<column name>} for
	% each column name.
	% The column name as such can be set with the 'column name' option.
	/pgfplots/table/multicolumn names/.style={%
		/pgfplots/table/assign column name/.code={%
			\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{1}{#1}{##1}}%
		}%
	},
	/pgfplots/table/multicolumn names/.default=c,
	/pgfplots/table/dec sep align/.code={%
		\pgfplots@assert@LaTeX@package@loaded{array}{dec sep align}%
		\def\pgfplotstable@scisepalign@headeralign{#1}%
		\pgfkeysalso{%
			/pgf/number format/assume math mode,
			/pgf/number format/@dec sep mark={$&$},
			/pgfplots/table/assign column name/.code={%
				\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{2}{#1}{##1}}%
			},%
			/pgfplots/table/column type={%
				r<{\pgfplotstableresetcolortbloverhangright}%
				@{}%
				l<{\pgfplotstableresetcolortbloverhangleft}%
			},
			/pgfplots/table/assign cell content/.code={%
				\def\pgfmathresult{##1}%
				\let\continue=\pgfutil@empty
				% allow special handling:
				\pgfplots@invoke@pgfkeyscode{/pgfplots/table/dec sep align/process/.@cmd}{##1}%
				\ifx\continue\pgfutil@empty
					% nothing has changed. Processed as usual:
					\ifx\pgfmathresult\pgfutil@empty
						\def\pgfmathresult{&}%
					\else
						% -6.90000001e-01 -> \meaning\pgfmathresult = macro:->-0$&$.69
						\pgfmathprintnumberto{\pgfmathresult}\pgfmathresult%
						% now make sure we have math mode for the single
						% columns:
						\expandafter\def\expandafter\pgfmathresult\expandafter{\expandafter$\pgfmathresult$}%
					\fi
				\fi
				\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
			},
		}%
	},
	/pgfplots/table/dec sep align/.default=c,
	%
	% A part of dec sep align which can be used to process special
	% cases.
	%
	% #1: the unprocessed input argument.
	% PRECONDITION:
	%   \pgfmathresult contains '#1', not more.
	%   \continue is empty.
	%
	% POSTCONDITION:
	% 	If \continue is empty, `dec sep align' will continue just as
	% 	if the 'process' key hadn't been invoked.
	% 	It will, however, use the current value of \pgfmathresult.
	%
	% 	If \continue is NOT empty, for example \def\continue{0}, 
	% 	`dec sep align' assumes that \pgfmathresult contains the
	% 	completely typeset cell, including any alignment material.
	/pgfplots/table/dec sep align/process/.code=,%
	/pgfplots/table/dec sep align/no unbounded/.style={%
		% FIXME : this thing doesn't work as intended! It looks ugly!
		/pgfplots/table/dec sep align/process/.code={%
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber\pgfmathresult
				\pgfmathfloatiffinite{\pgfmathresult}{%
					% do nothing, just communicate the parsed
					% \pgfmathresult
				}{%
					\begingroup
						\t@pgfplots@toka=\expandafter{\pgfplotstable@scisepalign@headeralign}%
						\t@pgfplots@tokb={\pgfkeyslet{/pgf/number format/@dec sep mark}\pgfutil@empty\pgfmathprintnumber}%
						\t@pgfplots@tokc=\expandafter{\pgfmathresult}%
						\xdef\pgfplotstable@glob@TMPc{%
							\noexpand\multicolumn{2}{\the\t@pgfplots@toka}%
								{\the\t@pgfplots@tokb{\the\t@pgfplots@tokc}}%
						}%
					\endgroup
					\let\pgfmathresult=\pgfplotstable@glob@TMPc
					\def\continue{0}%
				}%
			\fi
		},%
	},%
	/pgfplots/table/sci sep align/.code={%
		\pgfplots@assert@LaTeX@package@loaded{array}{sci sep align}%
			\pgfkeysalso{%
			/pgf/number format/assume math mode,
			/pgf/number format/@sci exponent mark={$&$},
			/pgfplots/table/assign column name/.code={%
				\pgfkeyssetvalue{/pgfplots/table/column name}{\multicolumn{2}{#1}{##1}}%
			},%
			/pgfplots/table/column type={%
				r<{\pgfplotstableresetcolortbloverhangright}%
				@{}%
				l<{\pgfplotstableresetcolortbloverhangleft}%
			},
			/pgfplots/table/assign cell content/.code={%
				\def\pgfmathresult{##1}%
				\ifx\pgfmathresult\pgfutil@empty
					\def\pgfmathresult{&}%
				\else
					\pgfmathprintnumberto{##1}\pgfmathresult%
					\expandafter\pgfutil@in@\expandafter&\expandafter{\pgfmathresult}%
					% now make sure we have math mode for the single
					% columns:
					\ifpgfutil@in@
						\expandafter\def\expandafter\pgfmathresult\expandafter{\expandafter$\pgfmathresult$}%
					\else
						\expandafter\def\expandafter\pgfmathresult\expandafter{\expandafter\pgfutilensuremath\expandafter{\pgfmathresult}&}%
					\fi
				\fi
				\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
			},
		}%
	},
	/pgfplots/table/sci sep align/.default=c,
	%
	% A style which can be used together with the 'dcolumn' package by
	% David Carlisle.
	% #1: the dcolumn type, defaults to 'D{.}{.}{2}'
	% #2: the column name type, defaults to 'c'
	/pgfplots/table/dcolumn/.style 2 args={%
		/pgf/number format/assume math mode,
		column type={#1},
		multicolumn names=#2,
	},
	/pgfplots/table/dcolumn/.default={D{.}{.}{2}}{c},
	/pgfplots/table/column type/.initial={c},
	/pgfplots/table/every table/.style={},
	/pgfplots/table/every even row/.style={},
	/pgfplots/table/every odd row/.style={},
	/pgfplots/table/every last row/.style={},
	/pgfplots/table/every first row/.style={},
	/pgfplots/table/every head row/.style={},
	/pgfplots/table/every first column/.style={},
	/pgfplots/table/every last column/.style={},
	/pgfplots/table/every even column/.style={},
	/pgfplots/table/every odd column/.style={},
	/pgfplots/table/before row/.initial=,
	/pgfplots/table/after row/.initial=,
	/pgfplots/table/begin table/.initial={\begin{tabular}},
	/pgfplots/table/end table/.initial={\end{tabular}},
	/pgfplots/table/outfile/.initial=,
	/pgfplots/table/include outfiles/.is if=pgfplotstabletypeset@includeoutfiles,
	/pgfplots/table/include outfiles/.default=true,
	/pgfplots/table/force remake/.is if=pgfplotstabletypeset@force@remake,
	/pgfplots/table/force remake/.default=true,
	/pgfplots/table/write to macro/.initial=,
	/pgfplots/table/typeset/.is if=pgfplotstabletypesetresult,
	/pgfplots/table/typeset=true,
	/pgfplots/table/skip coltypes/.is if=pgfplotstabletypesetskipcoltypes,
	/pgfplots/table/skip coltypes/.default=true,
	/pgfplots/table/debug/.is if=pgfplotstabletypesetdebug,
	/pgfplots/table/debug level/.initial=0,%
	%
	% will be redefined by |assign cell content| for every cell:
	/pgfplots/table/@cell content/.initial=,
	%
	% #1: the cells content as it has been found in the input table
	% this command key should somehow fill |cell content|.
	/pgfplots/table/assign cell content/.code={%
		\def\pgfmathresult{#1}%
		\ifx\pgfmathresult\pgfutil@empty
		\else
			\pgfmathprintnumberto{#1}\pgfmathresult%
		\fi
		\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	},
	%
	% this here is the default formatting. It uses
	% \pgfmathprintnumber.
	/pgfplots/table/assign cell content as number/.code={%
		\def\pgfmathresult{#1}%
		\ifx\pgfmathresult\pgfutil@empty
		\else
			\pgfmathprintnumberto{#1}\pgfmathresult%
		\fi
		\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	},
	/pgfplots/table/numeric type/.code={%
		\pgfkeysgetvalue{/pgfplots/table/assign cell content as number/.@cmd}\pgfplotstable@loc@TMPa%
		\pgfkeyslet{/pgfplots/table/assign cell content/.@cmd}\pgfplotstable@loc@TMPa
	},
	/pgfplots/table/string type/.style={%
		/pgfplots/table/assign cell content/.style={%
			/pgfplots/table/@cell content={##1}%
		}%
	},%
	/pgfplots/table/numeric as string type/.style={%
		/pgfplots/table/assign cell content/.code={%
			\def\pgfmathresult{##1}%
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathifisint{##1}{\let\pgfmathresult=\pgfretval}{\pgfmathfloattosci{\pgfretval}}%
			\fi
			\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
		}%
	},%
	/pgfplots/table/date type/.style={%
		/pgfplots/table/assign cell content/.code={%
			\begingroup
			\pgfcalendardatetojulian{##1}\c@pgfplotstable@counta
			\pgfcalendarjuliantodate{\c@pgfplotstable@counta}\year\month\day
			\pgfcalendarjuliantoweekday\c@pgfplotstable@counta\c@pgf@countc
			\edef\weekday{\the\c@pgf@countc }%
			\edef\weekdayname{\pgfcalendarweekdayname\c@pgf@countc}%
			\edef\weekdayshortname{\pgfcalendarweekdayshortname\c@pgf@countc}%
			\edef\monthname{\pgfcalendarmonthname\month}%
			\edef\monthshortname{\pgfcalendarmonthshortname\month}%
			\xdef\pgfplots@glob@TMPa{#1}%
			\endgroup
			\pgfkeyslet{/pgfplots/table/@cell content}\pgfplots@glob@TMPa%
		}%
	},%
	/pgfplots/table/date type/.default={\year/\month/\day}%
	/pgfplots/table/set content/.style={%
		/pgfplots/table/postproc cell content/.style={%
			/pgfplots/table/@cell content={#1}%
		}%
	},%
	%
	/pgfplots/table/postproc cell content/.code={},
	/pgfplots/table/preproc cell content/.code={},
	%
	/pgfplots/table/clear infinite/.style={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfmathresult}%
				\let\pgfmatharga=\pgfmathresult
				{%
				\pgfmathfloatgetflags\pgfmatharga\c@pgfplotstable@counta
				\xdef\pgfplots@glob@TMPc{\the\c@pgfplotstable@counta}%
				}%
				\ifnum\pgfplots@glob@TMPc<3
					\pgfmathfloattosci@\pgfmathresult
					\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
				\else
					\pgfkeyslet{/pgfplots/table/@cell content}{\pgfutil@empty}%
				\fi
			\fi
		}
	},
	/pgfplots/table/string replace/.style 2 args={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\def\pgfplots@loc@TMPa{#1}%
			\ifx\pgfmathresult\pgfplots@loc@TMPa
				\def\pgfplots@loc@TMPb{#2}%
				\pgfkeyslet{/pgfplots/table/@cell content}{\pgfplots@loc@TMPb}%
			\fi
		}
	},
	/pgfplots/table/preproc/expr/.code={%
		\ifpgfplots@usefpu
			\pgfkeysalso{/pgf/fpu=true,/pgf/fpu/output format=sci}%
		\fi
		\expandafter\def\csname pgfplotstable@preproc@expr@thisrow@\pgfplotstablecolname\endcsname{\pgfkeysvalueof{/pgfplots/table/@cell content}}%
		\def\thisrow##1{%
			\pgfutil@ifundefined{pgfplotstable@preproc@expr@thisrow@##1}{%
				--inaccessable--%
			}{%
				\csname pgfplotstable@preproc@expr@thisrow@##1\endcsname
			}%
		}%
		\pgfkeysalso{/pgfplots/table/preproc cell content/.append code={%
				\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathparse{#1}%
					\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult%
				\fi
			}%
		}%
	},
	/pgfplots/table/multiply -1/.style={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfmathresult}%
				\let\pgfmatharga=\pgfmathresult
				\pgfmathfloatcreate{2}{1.0}{0}%
				\let\pgfmathargb=\pgfmathresult
				\pgfmathfloatmultiply@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathfloattosci@\pgfmathresult
				\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
			\fi
		}
	},
	/pgfplots/table/multiply with/.code={%
		\pgfmathfloatparsenumber{#1}%
		\let\pgfplotstable@scale=\pgfmathresult
		\pgfkeysalso{
			/pgfplots/table/preproc cell content/.append code={%
				\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathfloatparsenumber{\pgfmathresult}%
					\let\pgfmatharga=\pgfmathresult
					\pgfmathfloatmultiply@{\pgfmatharga}{\pgfplotstable@scale}%
					\pgfmathfloattosci@\pgfmathresult
					\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
				\fi
			}%
		}%
	},
	/pgfplots/table/divide by/.code={%
		\pgfkeysalso{/pgfplots/table/multiply with=#1}%
		\let\pgfplotstable@divisor=\pgfplotstable@scale
		\pgfmathfloatcreate{1}{1.0}{0}%
		\let\pgfplotstable@ONE=\pgfmathresult
		\pgfmathfloatdivide@{\pgfplotstable@ONE}{\pgfplotstable@divisor}%
		\let\pgfplotstable@scale=\pgfmathresult
	},
	/pgfplots/table/sqrt/.style={%
		/pgfplots/table/preproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			\ifx\pgfmathresult\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfmathresult}%
				\let\pgfmatharga=\pgfmathresult
				\pgfmathfloatsqrt@{\pgfmatharga}%
				\pgfmathfloattosci@\pgfmathresult
				\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
			\fi
		}%
	},
	/pgfplots/table/empty cells with/.style={%
		/pgfplots/table/postproc cell content/.append code={%
			\ifnum\pgfplotstablepartno=0
				\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
				\ifx\pgfmathresult\pgfutil@empty
					\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1}%
				\fi
			\fi
		}%
	},
	/pgfplots/table/fonts by sign/.style 2 args={%
		/pgfplots/table/postproc cell content/.append code={%
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfplotsretval
			\ifx\pgfplotsretval\pgfutil@empty
			\else
				\t@pgfplots@toka=\expandafter{\pgfplotsretval}%
				\t@pgfplots@tokb={#1}%
				\t@pgfplots@tokc={#2}%
				\pgfmathfloatparsenumber{\pgfkeysvalueof{/pgfplots/table/@preprocessed cell content}}%
				\pgfmathfloatifflags{\pgfmathresult}{-}{%
					\edef\pgfmathresult{{\the\t@pgfplots@tokc{\the\t@pgfplots@toka}}}%
				}{%
					\edef\pgfmathresult{{\the\t@pgfplots@tokb{\the\t@pgfplots@toka}}}%
				}%
				\pgfkeyslet{/pgfplots/table/@cell content}{\pgfmathresult}%
			\fi
		}%
	},%
	%
	/pgfplots/table/font/.initial=,
	/pgfplots/table/.search also={/pgf/number format,/pgfplots/table/create col},
	%--------------------------------------------------
	% /pgfplots/table/.unknown/.code={%
	% 	\let\pgfplots@table@curkeyname=\pgfkeyscurrentname
	% 	\pgfqkeys{/pgf/number format}{\pgfplots@table@curkeyname=#1}%
	% },%
	%-------------------------------------------------- 
	/pgfplots/table/create col/assign first/.style={
		/pgfplots/table/create col/assign%
	},
	/pgfplots/table/create col/assign last/.style={
		/pgfplots/table/create col/assign%
	},
	/pgfplots/table/create col/assign/.style={
		/pgfplots/table/create col/next content={}%
	},
	/pgfplots/table/create col/next content/.initial={},
	/pgfplots/table/create col/copy/.style={%
		/pgfplots/table/create col/assign/.code={%
			\getthisrow{#1}\pgfmathresult
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		}%
	},
	/pgfplots/table/create col/set/.style={%
		/pgfplots/table/create col/assign/.code={%
			\def\pgfmathresult{#1}%
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		}%
	},%
	/pgfplots/table/create col/set list/.code={%
		\pgfplots@assign@list\pgfmathaccumb{#1}%
		\pgfkeysalso{/pgfplots/table/create col/@from list struct=\pgfmathaccumb}%
	},%
	/pgfplots/table/create col/expr accum/.code 2 args={%
		\ifpgfplots@usefpu
			\pgfkeysalso{/pgf/fpu=true,/pgf/fpu/output format=sci}%
		\fi
		\pgfkeysdef{/pgfplots/table/create col/assign}{%
			\ifx\pgfmathaccuma\pgfutil@empty
				\pgfmathparse{#2}%
				\let\pgfmathaccuma=\pgfmathresult
			\fi
			\pgfmathparse{#1}%
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			\let\pgfmathaccuma=\pgfmathresult
		}%
	},
	/pgfplots/table/create col/expr/.style={%
		/pgfplots/table/create col/expr accum={#1}{0}%
	},%
	/pgfplots/table/create col/copy column from table/.code 2 args={%
		\pgfplotstablegetcolumn{#2}\of{#1}\to\pgfmathaccumb
		\pgfkeysalso{/pgfplots/table/create col/@from list struct=\pgfmathaccumb}%
	},
	/pgfplots/table/create col/@from list struct/.code={%
		\pgfplotslistcopy#1\to\pgfmathaccumb
		\pgfkeysdef{/pgfplots/table/create col/assign}{%
			\pgfplotslistcheckempty\pgfmathaccumb
			\ifpgfplotslistempty
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			\else
				\pgfplotslistpopfront\pgfmathaccumb\to\pgfmathresult
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			\fi
		}%
	},
	/pgfplots/table/create col/quotient/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/iquotient/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	%
	% Produces 'log2( \prevrow{#1}/\thisrow{#1} )
	%
	% Assumeing that every row contains error(h) = O(h^alpha)
	% and h_this = h_prev/2, this result in 'alpha', the convergence
	% rate.
	/pgfplots/table/create col/dyadic refinement rate/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathmultiply@{1.442695}{\pgfmathresult}%
				\fi
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/idyadic refinement rate/.style={%
		/pgfplots/table/columns={#1},
		/pgfplots/table/create col/assign first/.style={%
			/pgfplots/table/create col/next content=
		},%
		/pgfplots/table/create col/assign/.code={%
			\pgfmathfloatparsenumber{\prevrow{#1}}%
			\let\pgfmathargb=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmatharga=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathargb
			\pgfplots@ifzero\pgfmathargb{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmatharga}{\pgfmathargb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
				\else
					\pgfmathmultiply@{1.442695}{\pgfmathresult}%
				\fi
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		}%
	},%
	/pgfplots/table/create col/gradient/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathnext@x
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathnext@y
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
	/pgfplots/table/create col/gradient loglog/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathlog{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathlog{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathlog{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathlog{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			\pgfplots@loop@CONTINUEtrue
			\ifx\pgfmathcur@x\pgfutil@empty		\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathcur@y\pgfutil@empty		\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathnext@x\pgfutil@empty	\pgfplots@loop@CONTINUEfalse\fi
			\ifx\pgfmathnext@y\pgfutil@empty	\pgfplots@loop@CONTINUEfalse\fi
			\ifpgfplots@loop@CONTINUE
				\pgfmathsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
				\let\pgfmathdiff@x=\pgfmathresult
				\pgfmathsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
				\let\pgfmathdiff@y=\pgfmathresult
				\ifdim\pgfmathdiff@x pt=0.0pt
					\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
				\else
					\pgfmathdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
					\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
				\fi
			\else
			%	\pgfmathfloatcreate{3}{0.0}{0}%
			%	\pgfmathfloattosci@\pgfmathresult
			%	\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			\fi
		},%
	},%
	/pgfplots/table/create col/gradient semilogx/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathfloatparsenumber{\thisrow{#1}}
			\pgfmathfloatln@{\pgfmathresult}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathfloatparsenumber{\thisrow{#1}}
			\pgfmathfloatln@{\pgfmathresult}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			%
			\pgfmathfloatparsenumber{\thisrow{#2}}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
	/pgfplots/table/create col/gradient semilogy/.style 2 args={%
		/pgfplots/table/columns={#1,#2},
		/pgfplots/table/create col/assign first/.code={%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatparsenumber{\thisrow{#2}}
			\pgfmathfloatln@{\pgfmathresult}%
			\let\pgfmathaccumb=\pgfmathresult
			\def\pgfmathresult{}% leave first empty.
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
		},%
		/pgfplots/table/create col/assign/.code={%
			\let\pgfmathcur@x=\pgfmathaccuma
			\let\pgfmathcur@y=\pgfmathaccumb
			\pgfmathfloatparsenumber{\thisrow{#2}}
			\pgfmathfloatln@{\pgfmathresult}%
			\let\pgfmathnext@y=\pgfmathresult
			\let\pgfmathaccumb=\pgfmathresult
			%
			\pgfmathfloatparsenumber{\thisrow{#1}}%
			\let\pgfmathnext@x=\pgfmathresult
			\let\pgfmathaccuma=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@x}{\pgfmathcur@x}%
			\let\pgfmathdiff@x=\pgfmathresult
			\pgfmathfloatsubtract@{\pgfmathnext@y}{\pgfmathcur@y}%
			\let\pgfmathdiff@y=\pgfmathresult
			\pgfplots@ifzero\pgfmathdiff@x{%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
			}{%
				\pgfmathfloatdivide@{\pgfmathdiff@y}{\pgfmathdiff@x}%
				\expandafter\pgfmathfloattosci@\expandafter{\pgfmathresult}%
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			}%
		},%
	},%
	/pgfplots/table/typeset cell/.code={%
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
			\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1\\}%
		\else
			\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1&}%
		\fi
	},
	/pgfplots/table/reset styles/.style={
		/pgfplots/table/every table/.code=,
		/pgfplots/table/every odd column/.code=,
		/pgfplots/table/every even column/.code=,
		/pgfplots/table/every first column/.code=,
		/pgfplots/table/every last column/.code=,
		/pgfplots/table/every head row/.code=,
		/pgfplots/table/every odd row/.code=,
		/pgfplots/table/every even row/.code=,
		/pgfplots/table/every first row/.code=,
		/pgfplots/table/every last row/.code=,
	},
	/pgfplots/table/colnames from/.initial=,% for \pgfplotstabletranspose
	/pgfplots/table/input colnames to/.initial=colnames,% for \pgfplotstabletranspose
}
\pgfkeys{
	% #1: the argument which should have been assigned.
	% #2: an error message. 
	/pgfplots/exception/non unique colname/.code 2 args={%
		\ifx\pgfplotsexceptionmsg\relax
			\pgfplots@error{#2}%
		\else
			\pgfplots@error{\pgfplotsexceptionmsg}%
		\fi
		\let#1=\pgfutil@empty
	},%
}
% 'function graph cut y'={<epsilon>}{<options>}{comma-separated-list of specs where to get yi}
%
% fills the column with x1,...,xN such that yi(xi) == epsilon where
%
% In other words, it computes cuts points between the line 
% y == epsilon and one or more other plots yi(x) and returns the 'x'
% values of the cuts.
%
% Example:
% \pgfplotstableset{
%	create on use/cut/.style={create col/function graph cut y={7e-4}{x=Basis,ymode=log,xmode=log}{{table=regtable,y=special-L2}}},
%}
\pgfkeysdefargs{/pgfplots/table/create col/function graph cut y}{#1#2#3}{\pgfplotstable@fgc@init{#1}{#2}{#3}{y}{x}}
\pgfkeysdefargs{/pgfplots/table/create col/function graph cut x}{#1#2#3}{\pgfplotstable@fgc@init{#1}{#2}{#3}{x}{y}}
\pgfkeys{%
	/pgfplots/table/create col/function graph cut/xmode/.is choice,
	/pgfplots/table/create col/function graph cut/xmode/linear/.code={\def\pgfplotstable@fgc@xmode{0}},%
	/pgfplots/table/create col/function graph cut/xmode/log/.code={\def\pgfplotstable@fgc@xmode{1}},%
	/pgfplots/table/create col/function graph cut/ymode/.is choice,
	/pgfplots/table/create col/function graph cut/ymode/linear/.code={\def\pgfplotstable@fgc@ymode{0}},%
	/pgfplots/table/create col/function graph cut/ymode/log/.code={\def\pgfplotstable@fgc@ymode{1}},%
	/pgfplots/table/create col/function graph cut/x/.initial=,
	/pgfplots/table/create col/function graph cut/y/.initial=,
	/pgfplots/table/create col/function graph cut/table/.initial=,
	% foreach={\d in {1,2,3,4}}{{table\d}}
	/pgfplots/table/create col/function graph cut/foreach/.initial=,
}


\pgfkeyslet{/pgfplots/table/TeX comment}\pgfplots@PERCENT@TEXT
\pgfkeysgetvalue{/pgfplots/table/postproc cell content/.@cmd}\pgfplotstable@postproccellcontent@EMPTY


% A helper macro to automatically remove the "hangover" created by
% 'colortbl'.
% This allows compatibility between my 'sci sep align' and 'dec sep align' 
% implementations and \rowcolor. Otherwise, the hangover
% would overwrite digits near the separator.
%
% @remark This does also work if colortbl is not loaded.
\def\pgfplotstableresetcolortbloverhangright{%
	\pgfutil@ifundefined{CT@row@color}{\relax}{%
		\global\let\pgfplots@origrowcolorcmd=\CT@row@color
		\gdef\CT@row@color{%
			\pgfplots@origrowcolorcmd
			\@tempdimc=0pt
			\global\let\CT@row@color=\pgfplots@origrowcolorcmd
		}%
	}%
}%
\def\pgfplotstableresetcolortbloverhangleft{%
	\pgfutil@ifundefined{CT@row@color}{\relax}{%
		\global\let\pgfplots@origrowcolorcmd=\CT@row@color
		\gdef\CT@row@color{%
			\pgfplots@origrowcolorcmd
			\@tempdimb=0pt
			\global\let\CT@row@color=\pgfplots@origrowcolorcmd
		}%
	}%
}%

% \pgfplotstableread[OPTIONS] {FILE} to \name
%
% This method reads a table from FILE to macro \name.
%
% FILE is something like
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
% 17	17	17	2.54685628e-02	0.00000000e+00	3.75580565e-02	5	3	-1
% ...
%
% A number format line is also understood:
% G	Basis	dof	L2	A	Lmax	cgiter	maxlevel	eps
% $flags int	int	int	sci:8	sci:8	sci:8	int	int	std:8
% 5	5	5	8.31160034e-02	0.00000000e+00	1.80007647e-01	2	2	-1
%
% or a three-column-gnuplot file with 2 comment headers like
% #Curve 0, 20 points
% #x y type
% 0.00000 0.00000 i
% 0.52632 0.50235 i
%
% The table data is stored columnwise in lists and can be accessed
% with the other methods of this package.
%
% \pgfplotstableread[<options>]{<file>}{<\macro>}
% \pgfplotstableread[<options>]{<file>} to listener{<\macro>}
% \pgfplotstableread* ...
%
% The '*' does not protect its local variables with TeX groups,
% everything is added to the current scope (useful to the 'to
% listener' thing.
%
% The 'to listener' variant does NOT assemble a table data structure.
% Instead, it processes the input table row-wise and invokes <\macro>
% after each complete row. During the evaluation of <\macro>, the
% following methods can be used to query values:
%   \pgfplotstablereadgetcolindex{<index>}{<\macro>}
%   \pgfplotstablereadgetcolname{<name>}{<\macro>}
%   \pgfplotstablereadvalueofcolname{<name>}
%   \pgfplotstablereadvalueofcolindex{<index>}
%   \thisrow{<name>} (equivalent to \pgfplotstablereadvalueofcolname)
%   \getthisrow{<name>}{<\macro>} (equivalent to \pgfplotstablereadgetcolname)
%   \thisrowno{<index>} (equivalent to \pgfplotstablereadvalueofcolindex)
%   \getthisrowno{<index>}{<\macro>}
%   \pgfplotstableforeachcolumn\as{<\iteratemacro>}{<loop body>}
%   	(the '\as' is required directly after
%   	\pgfplotstableforeachcolumn in this context)
% Attention: 'to listener' is scoped by TeX groups, so any assignments
% need to be done globally (or with aftergroup magic).
%
% More remarks about scoping:
% \pgfplotstableread to listener works as follows:
%     \begingroup
%     // load table
%     while file has more lines:
%     	load line, read every column;
%     	invoke listener;
%     repeat
%     \endgroup
%
%  In short: all invocations of listener have the same level of
%  scoping: they are inside of one TeX group. But single listener
%  invocations as such are not scoped. Make sure you don't
%  accidentally overwrite one of the internals in listener. And: make
%  sure you don't change temporary registers without scoping them!
%
% Note: this command also updates \pgfplotsscanlinelength.
\def\pgfplotstableread{%
	\pgfutil@ifnextchar*{%
		\pgfplots@tableread@use@begingroupfalse
		\pgfplotstableread@impl@star
	}{%
		\pgfplots@tableread@use@begingrouptrue
		\pgfplotstableread@impl@star*%
	}%
}%
\def\pgfplotstableread@impl@star*{%
	\pgfutil@ifnextchar[{%
		\pgfplotstableread@impl
	}{%
		\pgfplotstableread@impl[]%
	}%
}

% BACKWARDS COMPATIBILITY
\let\pgfnumtableread=\pgfplotstableread

% Invokes #2 if '#1' is an already loaded table and #3 if not.
\long\def\pgfplotstable@isloadedtable#1#2#3{%
	\pgfplotsutil@ifdefinedui@withsuffix{#1}{@@table@name}{#2}{#3}%
}%

% Defines \pgfmathresult (and now also \pgfplotsretval) to be the number of rows in table #1.
%
% #1 may be either a loaded table structure (a macro name) or a table
% file name. In the latter case, the file will be loaded temporarily.
\long\def\pgfplotstablegetrowsof#1{%
	\pgfplotstable@isloadedtable{#1}{%
		% ah - it is an already loaded table!
		\begingroup
		\pgfplotslistfront#1\to\pgfplotstablegetrows@@
		\expandafter\pgfplotslistsize\csname\string#1@\pgfplotstablegetrows@@\endcsname\to\c@pgfplotstable@counta
		\edef\pgfmathresult{\the\c@pgfplotstable@counta}%
		\pgfmath@smuggleone\pgfmathresult
		\endgroup
	}{%
		% ah - it is a file name.
		\begingroup
			\pgfplotstableread{#1}\pgfplotstablegetrows@
			\pgfplotstablegetrowsof{\pgfplotstablegetrows@}%
			\pgfmath@smuggleone\pgfmathresult
		\endgroup
	}%
	\let\pgfplotsretval=\pgfmathresult
}%

% \pgfplotstablesave[<options>]{<\tablename>}{file name}
\def\pgfplotstablesave{%
	\pgfutil@ifnextchar[{%
		\pgfplotstablesave@impl
	}{%
		\pgfplotstablesave@impl[]%
	}%
}

\def\pgfplotstablesave@impl[#1]#2#3{%
	\pgfplotstabletypeset[%
		reset styles,%
		disable rowcol styles,%
		begin table={},%
		end table={},%
		typeset cell/.code={%
			\begingroup
			\t@pgfplots@toka={##1}%
			\ifcase\pgfplotstableread@OUTCOLSEP@CASE\relax
				% col sep=SPACE:
				\t@pgfplots@tokb=\expandafter{\pgfplotstableread@tab}%
				\pgfplots@ifempty{##1}{%
					\t@pgfplots@toka={{}}%
				}{}%
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			\or
				% col sep=comma:
				\t@pgfplots@tokb={,}%
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			\or
				% col sep=semicolon:
				\t@pgfplots@tokb={;}%
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			\or
				% col sep=colon:
				\t@pgfplots@tokb={:}%
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			\or
				% col sep=braces:
				\xdef\pgfplots@glob@TMPc{{\the\t@pgfplots@toka}}%
			\or
				% col sep=tab:
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka\pgfplotstableread@tab}%
			\or
				% col sep=&:
				\xdef\pgfplots@glob@TMPc{\the\t@pgfplots@toka&}%
			\fi
			\endgroup
			\pgfkeyslet{/pgfplots/table/@cell content}\pgfplots@glob@TMPc%
		},%
		before row=,%
		after row=,%
		skip coltypes,%
		typeset=false,%
		string type,%
		TeX comment=,%
		columns=,%
		font=,%
		/pgfplots/table/col sep/.is choice,%
		/pgfplots/table/col sep/space/.code		= {\def\pgfplotstableread@OUTCOLSEP@CASE{0}},%
		/pgfplots/table/col sep/comma/.code		= {\def\pgfplotstableread@OUTCOLSEP@CASE{1}},%
		/pgfplots/table/col sep/semicolon/.code	= {\def\pgfplotstableread@OUTCOLSEP@CASE{2}},%
		/pgfplots/table/col sep/colon/.code		= {\def\pgfplotstableread@OUTCOLSEP@CASE{3}},%
		/pgfplots/table/col sep/braces/.code	= {\def\pgfplotstableread@OUTCOLSEP@CASE{4}},%
		/pgfplots/table/col sep/tab/.code		= {\def\pgfplotstableread@OUTCOLSEP@CASE{5}},%
		/pgfplots/table/col sep/&/.code			= {\def\pgfplotstableread@OUTCOLSEP@CASE{6}},%
		/pgfplots/table/col sep/ampersand/.code	= {\def\pgfplotstableread@OUTCOLSEP@CASE{6}},%
		/pgfplots/table/col sep=space,%
		/pgfplots/table/in col sep/.is choice,%
		/pgfplots/table/in col sep/space/.code		= {\def\pgfplotstableread@COLSEP@CASE{0}},%
		/pgfplots/table/in col sep/comma/.code		= {\def\pgfplotstableread@COLSEP@CASE{1}},%
		/pgfplots/table/in col sep/semicolon/.code	= {\def\pgfplotstableread@COLSEP@CASE{2}},%
		/pgfplots/table/in col sep/colon/.code		= {\def\pgfplotstableread@COLSEP@CASE{3}},%
		/pgfplots/table/in col sep/braces/.code		= {\def\pgfplotstableread@COLSEP@CASE{4}},%
		/pgfplots/table/in col sep/tab/.code		= {\def\pgfplotstableread@COLSEP@CASE{5}},%
		/pgfplots/table/in col sep/&/.code			= {\def\pgfplotstableread@COLSEP@CASE{6}},%
		/pgfplots/table/in col sep/ampersand/.code	= {\def\pgfplotstableread@COLSEP@CASE{6}},%
		/pgfplots/table/in col sep=space,%
		% WARNING: you NEED a '%' before '#1':
		#1,%
		outfile={#3}%
	]{#2}%
}%

% clears the table. 
\def\pgfplotstableclear#1{%
	\let#1=\relax
	\expandafter\let\csname \string#1@@table@name\endcsname=\relax
}%


% \pgfplotstablenew[<options>]{<numrows>}{<\name>}
% \pgfplotstablenew*[<options>]{<numrows>}{<\name>}
%
% Creates a new table from scratch. 
%
% The new table will contain all columns listed in the 'columns' key
% which must be present in <options>. The starred version
% \pgfplotstablenew* is not that strict: it will use the current value
% of the columns key (not matter where and when it has been set).
%
% Furthermore, there must be 'create on use' statements for every
% column which shall be generated. Columns are generated
% independently, in the order of appearance in 'columns'.
% The table will contain exactly <numrows> rows.
\def\pgfplotstablenew{%
	\begingroup
	\pgfutil@ifnextchar*{\pgfplotstablenew@star}{\pgfplotstablenew@nostar}}
\def\pgfplotstablenew@star*{\pgfutil@ifnextchar[{\pgfplotstablenew@impl}{\pgfplotstablenew@impl[]}}%
\def\pgfplotstablenew@nostar{%
	% reset columns key:
	\pgfkeyslet{/pgfplots/table/columns}{\pgfutil@empty}%
	\pgfutil@ifnextchar[{\pgfplotstablenew@impl}{\pgfplotstablenew@impl[]}}

\def\pgfplotstablenew@impl[#1]#2#3{%
	\pgfplotsscanlinelengthinitzero
	% create a temporary column with the desired number of rows:
	\pgfutil@in@\pgfplotstablegetrowsof{#2}%
	\ifpgfutil@in@
		#2%
		\let\pgfplotstable@loc@TMPa=\pgfmathresult
	\else
		\def\pgfplotstable@loc@TMPa{#2}%
	\fi
	\pgfplotslistnew#3{@@@@@temporary@column@\\}%
	\expandafter\pgfplots@assign@list\csname\string#3@@@@@@temporary@column@\endcsname{1,2,...,\pgfplotstable@loc@TMPa}%
	%
	% now, create all real columns:
	\pgfplotstableset{#1,%
		/pgf/fpu/handlers/empty number/.code 2 args={%
			\pgfmathfloatcreate{0}{0.0}{0}%
		}%
	}%
	\pgfkeysgetvalue{/pgfplots/table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplots@warning{\string\pgfplotstablenew[columns={},...]{#2}{\string#3} has been invoked - but empty tables are currently not really supported, sorry. You will have to live with an artifical column which contains temporary values.}%
	\else
		\expandafter\pgfplots@assign@list\expandafter\pgfplotstablenew@cols\expandafter{\pgfplotstable@colnames}%
		% make sure every requested column exists:
		\pgfutil@loop
		\pgfplotslistcheckempty\pgfplotstablenew@cols
		\ifpgfplotslistempty
			\pgfplots@loop@CONTINUEfalse
		\else
			\pgfplots@loop@CONTINUEtrue
		\fi
		\ifpgfplots@loop@CONTINUE
			\pgfplotslistpopfront\pgfplotstablenew@cols\to\pgfplotstablenew@col
			\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplotstablenew@col}\of#3\to\pgfplotstable@loc@TMPa
		\pgfutil@repeat
		% remove the temporary column:
		% FIXME this should be done after the '\fi'. But that will
		% lead to an error because empty tables are currently
		% unsupported!
		\pgfplotslistpopfront#3\to\pgfplotstable@loc@TMPa
	\fi
	\pgfplotsscanlinelengthcleanup
	\pgfplotstable@copy@to@globalbuffers#3{newlycreatedtable}%
	\endgroup
	\pgfplotstable@copy@globalbuffers@to#3%
}%

% \pgfplotstablevertcat{<table1>}{<table2>}
% appends the contents of <table2> to <table1>. To be more precise,
% only columns which exist already in <table1> will be used.
%
% If <table1> is undefined, <table2> will be copied completely to
% <table1>.
%
% #1 a table macro.
% #2 either a file name or a table macro.
\long\def\pgfplotstablevertcat#1#2{%
	\pgfplotstable@isloadedtable{#2}{%
		\pgfplotstable@isloadedtable{#1}{%
			% for each column in '#1':
			\pgfplotslistforeachungrouped#1\as\pgfplotstable@loc@TMPa{%
				% for each row in the corresponding column of '#2':
				\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplotstable@loc@TMPa}\of{#2}\to\pgfplotstable@loc@TMPb
				\pgfplotslistforeachungrouped\pgfplotstable@loc@TMPb\as\pgfplotstable@loc@TMPc{%
					\t@pgfplots@toka=\expandafter{\pgfplotstable@loc@TMPc}%
					\edef\pgfplotstable@loc@TMPd{%
						\noexpand\pgfplotslistpushback{\the\t@pgfplots@toka}\to\expandafter\noexpand\csname\string#1@\pgfplotstable@loc@TMPa\endcsname
					}%
					\pgfplotstable@loc@TMPd
				}%
			}%
		}{%
			\pgfplotstablecopy{#2}\to{#1}%
		}%
	}{%
		% FIXME : restore memory here !? SCOPING BUG
		\pgfplotstableread{#2}\pgfplotstable@tmptbl
		\pgfplotstablevertcat{#1}{\pgfplotstable@tmptbl}%
	}%
}

% \pgfplotstabletranspose{<\outtable>}{<intable>}
% \pgfplotstabletranspose[<colname>]{<\outtable>}{<intable>}
% Defines <\outtable> to be the transposed of <intable>. 
%
% If <colname> is not empty, the respective column's entries will be used to
% make output column names.
%
% #1: a table macro name which will be overwritten (redefined)
% #2: either a file name or a table macro (loaded table).
\def\pgfplotstabletranspose{%
	\begingroup
	\pgfutil@ifnextchar*{%
		\pgfplotstabletranspose@star%
	}{%
		\pgfkeyslet{/pgfplots/table/columns}\pgfutil@empty% clear!
		\pgfplotstabletranspose@star*%
	}%
}
\def\pgfplotstabletranspose@star*{\pgfutil@ifnextchar[{\pgfplotstabletranspose@opt}{\pgfplotstabletranspose@opt[]}}%
\long\def\pgfplotstabletranspose@opt[#1]#2#3{%
	\pgfplotstable@isloadedtable{#3}{%
		\pgfplotstabletranspose@[#1]{#2}{#3}%
	}{%
		\pgfplotstableread{#3}\pgfplotstable@tmptbl
		\pgfplotstabletranspose@[#1]{#2}{\pgfplotstable@tmptbl}%
	}%
}%

% Iterates through every column of table '#1' and invokes the code
% '#3' for each column. The current column name will be available as
% '#2' and the current column index as |\pgfplotstablecol| (starting
% with 0).
%
% Example:
% \pgfplotstableforeachcolumn{\table}\as\colname{%
% 	The column name is `\colname'; its index \pgfplotstablecol.\par
% }%
%
% REMARK: this routine does NOT introduce TeX groups.
\long\def\pgfplotstableforeachcolumn#1\as#2#3{%
	\def\pgfplotstablecol{0}%
	\pgfplotslistforeachungrouped#1\as#2{%
		#3\relax%
		\pgfplotsutil@advancestringcounter\pgfplotstablecol
	}%
	\let\pgfplotstablecol=\relax
}%
% A variant of \pgfplotstableforeachcolumn which is used inside of
% \pgfplotstableread to listener.
%
% It is used as \pgfplotstableforeachcolumn\as\cur{<do something with \cur>}
\long\def\pgfplotstableforeachcolumn@listener\as#1#2{%
	\def\pgfplotstablecol{0}%
	\pgfplotslistforeachungrouped\pgfplotstable@colnames@glob\as#1{%
		#2\relax%
		\pgfplotsutil@advancestringcounter\pgfplotstablecol
	}%
	\let\pgfplotstablecol=\relax
}%

% Reports every element t_{ij} for a fixed column j (in read-only
% mode).
%
% For every cell, the code '#4' will be executed where '#3' will
% contain the cell's value. During code '#4', the macro
% \pgfplotstablerow will contain the current row index.
%
% #1: either a column name or the string '[index]' followed by a
% number denoting a column index Access by column name is much faster..
% #2: the table (macro or file name)
% #3: the macro in which the cell values shall be written
% #4: the code to execute.
%
% Example:
% \pgfplotstableforeachcolumnelement{colname}\of\table\as\cellelem{%
% 	I have now cell element `\cellelem' at row index
% 	`\pgfplotstablerow'.
% 	\par
% }
%
% REMARK: this routine does NOT introduce TeX groups.
\long\def\pgfplotstableforeachcolumnelement#1\of#2\as#3#4{%
	\def\pgfplotstablerow{0}%
	\pgfplotstablegetcolumn{#1}\of{#2}\to\pgfplotstableforeachcolumnelement@list
	\pgfplotslistforeachungrouped\pgfplotstableforeachcolumnelement@list\as#3{%
		% allow nesting by copying the old value of \pgfplotstablerow:
		\expandafter\pgfplotstableforeachcolumnelement@\expandafter{\pgfplotstablerow}{#4}%
	}%
	\let\pgfplotstablerow=\relax
}%
% helper method to allow nesting. It copies \pgfplotstablerow.
% #1: the expanded value of \pgfplotstablerow. 
\long\def\pgfplotstableforeachcolumnelement@#1#2{%
	#2\relax
	\def\pgfplotstablerow{#1}% restore to old value.
	% advance.
	\pgfplotsutil@advancestringcounter\pgfplotstablerow
}%

% A routine which is similar to \pgfplotstableforeachcolumnelement,
% but this here checks for changes in \pgfplotsretval and writes them
% back into the respected cell.
%
% The runtime is quadratic in the number of rows.
\long\def\pgfplotstablemodifyeachcolumnelement#1\of#2\as#3#4{%
	\def\pgfplotstablerow{0}%
	%
	% Step 0: get the REAL column name for '#1'.
	% This needs modifications if '#1' is [index]<integer>.
	% -> store the colname to \pgfplotstable@loc@TMPc:
	\def\pgfplotstable@loc@TMPc{#1}%
	\pgfplotstable@is@colname{\pgfplotstable@loc@TMPc}%%
	\ifpgfplotstableread@foundcolnames
	\else
		\expandafter\pgfplotstablegetcolumnnamebyindex\pgfplotstable@loc@TMPc\of{#2}\to\pgfplotstable@loc@TMPc
	\fi
	% Step 0.1: prepare a command which re-assembles column '#1'
	% (using the real column name).
	% The re-assemblation command will be invoked at the end of each
	% iteration. This complicated macro preparation allows nested
	% calls to \pgfplotstablemodifyeachcolumnelement.
	\t@pgfplots@toka={\expandafter\pgfplotslistpushback\expandafter{#3}\to}%
	\edef\pgfplotstable@loc@TMPd{%
		\the\t@pgfplots@toka{\expandafter\noexpand\csname\string#2@\pgfplotstable@loc@TMPc\endcsname}}%
	% Step 1: copy the column data to \pgfplotstable@loc@TMPb
	\expandafter\pgfplotstablegetcolumnbyname\pgfplotstable@loc@TMPc\of#2\to\pgfplotstable@loc@TMPb%
	%
	% clear the original column:
	\expandafter\pgfplotslistnewempty\csname\string#2@\pgfplotstable@loc@TMPc\endcsname
	%
	% Call loop. The prepared re-assemble macro will be provided as macro argument
	% to allow nested calls:
	\expandafter\pgfplotstablemodifyeachcolumnelement@\expandafter{\pgfplotstable@loc@TMPd}
		{\pgfplotstable@loc@TMPb}{#3}{#4}%
	\let\pgfplotstablerow=\relax
}%
% #1: post-iteration code
% #2: the row list
% #3: the loop macro to assign
% #4: the loop body
\long\def\pgfplotstablemodifyeachcolumnelement@#1#2#3#4{%
	\pgfplotslistforeachungrouped{#2}\as#3{%
		% allow nesting by copying the old value of \pgfplotstablerow:
		\expandafter\pgfplotstableforeachcolumnelement@\expandafter{\pgfplotstablerow}{#4}%
		#1%
	}%
}

% Selects a single table element at row #1 and column #2 from table
% #3.
%
% #1: a row index.
% #2: a column name or the string '[index]' followed by a number
% denoting a column index. Access by column name is much faster.
% #3: the table (macro or file name).
%
% The cell value will be written into the macro \pgfplotsretval.
%
% REMARK:
% this routine is supposed to be very slow: it needs time O(N) where N
% is the number of rows. This may change in future versions.
%
% Example:
% \pgfplotstablegetelem{0}{[index]2}\of\table
% The elem is `\pgfplotsretval'.
\def\pgfplotstablegetelem#1#2\of#3{%
	\begingroup
	\pgfplotstablegetcolumn{#2}\of{#3}\to\pgfplotstable@loc@TMPa
	\def\pgfplotsexceptionmsg{Sorry, row `#1' does not exist in table \pgfplotstablenameof{#3}}%
	\pgfplotslistselect#1\of\pgfplotstable@loc@TMPa\to\pgfplotsretval
	\pgfmath@smuggleone\pgfplotsretval
	\endgroup
}%

\def\pgfplotstablegetcolumnlist#1\to#2{\let#2=#1}

% Returns a column vector in form of \pgfplotslist
% into #3.
%
% #1: the column name (not a macro)
% #2: the table structure
% #3: the output macro name.
%
% @throw `no such element' on error
\def\pgfplotstablegetcolumnbyname#1\of#2\to#3{%
	\pgfutil@ifundefined{\string#2@#1}{%
		% Oh, there is no column '#1' in table '#2'!
		%
		% Ok, then check for the 'create on use' and the 'alias'
		% features...
		% 1. create on use:
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		% *** \pgfplotstablereadvalueofcolname ***
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/create on use/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa/.@cmd}{%	
			% aah - a 'create on use' style exists. Apply it!
			\expandafter\pgfplotstablecreatecol\expandafter[\pgfplotstable@loc@TMPa]{#1}{#2}%
			% and return the newly generated col:
			\expandafter\let\expandafter#3\csname\string#2@#1\endcsname
		}{%
			% ok, then it is either an alias or it is simply not
			% existant.
			\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
			\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
				\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
				\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
				\pgfutil@ifundefined{\string#2@\pgfplotstable@loc@TMPa}{%
					\pgfplotsthrow{no such element}{#3}{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstablenameof{#2}'. The original request was for '#1', which does not exist either.}\pgfeov%
				}{%
					\expandafter\let\expandafter#3\csname\string#2@\pgfplotstable@loc@TMPa\endcsname
				}%
			}{%
				\pgfplotsthrow{no such element}{#3}{Sorry, could not retrieve column '#1' from table '\pgfplotstablenameof{#2}'. Please check spelling (or introduce name aliases).}\pgfeov%
			}%
		}%
	}{%
		\expandafter\let\expandafter#3\csname\string#2@#1\endcsname
	}%
}

% Retrieves the column *NAME* '#1' of table #2 and writes it into
% '#3'.
%
% If there is no such column, column aliases will be checked. Finally
% if there are no aliases, the command fails with an error.
%
% The 'create on use' statements can't be used in this context.
% @see \pgfplotstablegetcolumnbyname
%
% #1: a column name (not a macro)
% #2: the table structure
% #3: a macro name which will be filled with the (probably modified)
% column name into #2.
\def\pgfplotstableresolvecolname#1\of#2\to#3{%
	\pgfutil@ifundefined{\string#2@#1}{%
		% Oh, there is no column '#1' in table '#2'!
		%
		% Ok, then check for the 'alias' feature ...
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		% *** \pgfplotstablereadvalueofcolname ***
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
			\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
			\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
			\pgfutil@ifundefined{\string#2@\pgfplotstable@loc@TMPa}{%
				\def\pgfplotstable@loc@TMPb{/pgfplots/table/create on use/#1}%
				\pgfkeysifdefined{\pgfplotstable@loc@TMPb/.@cmd}{%
					\pgfplotstable@error{Sorry, '\pgfplotstable@loc@TMPb' from table '\pgfplotstableread@filename' can't be evaluated in this context. Please prepare the table before using it here. You can do this using the 'read completely' key, see the manual for details.}%
				}{%
					\pgfplotsthrow{no such element}{#3}{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstablenameof{#2}'. The original request was for '#1', which does not exist either.}\pgfeov%
				}%
			}{%
				\let#3=\pgfplotstable@loc@TMPa
			}%
		}{%
			\pgfplotsthrow{no such element}{#3}{Sorry, could not retrieve column '#1' from table '\pgfplotstablenameof{#2}'. Please check spelling (or introduce name aliases).}\pgfeov%
		}%
	}{%
		\def#3{#1}%
	}%
}

% Invokes either \pgfplotstablegetcolumnbyindex or
% \pgfplotstablegetcolumnbyname.
%
% #1: either a column name, alias or create on use specification, or
% [index]<integer> denoting a column index.
% #2: either a loaded table or a table macro.
% #3: a macro name which will be filled with the column, in the format
% accepted of \pgfplotslist...
\long\def\pgfplotstablegetcolumn#1\of#2\to#3{%
	\begingroup
	\pgfplotstable@isloadedtable{#2}{%
		\pgfplotstablegetcolumnfromstruct{#1}\of{#2}\to{#3}%
	}{%
		\pgfplotstableread{#2}\pgfplotstable@tmptbl
		\pgfplotstablegetcolumnfromstruct{#1}\of\pgfplotstable@tmptbl\to{#3}%
	}%
	\pgfmath@smuggleone#3%
	\endgroup
}%
\def\pgfplotstablegetcolumnfromstruct#1\of#2\to#3{%
	\def\pgfplotstable@loc@TMPc{#1}%
	\pgfplotstable@is@colname{\pgfplotstable@loc@TMPc}%%
	\ifpgfplotstableread@foundcolnames
	\else
		\expandafter\pgfplotstablegetcolumnnamebyindex\pgfplotstable@loc@TMPc\of{#2}\to\pgfplotstable@loc@TMPc
	\fi
	\expandafter\pgfplotstablegetcolumnbyname\pgfplotstable@loc@TMPc\of#2\to{#3}%
}%

\def\pgfplotstablegetcolumnnamebyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
}%
\def\pgfplotstablegetcolumnbyindex#1\of#2\to#3{%
	\pgfplotslistselect#1\of#2\to#3\relax
	\expandafter\pgfplotstablegetcolumnbyname#3\of#2\to{#3}%
}

\def\pgfplotstablecopy#1\to#2{%
	\let#2=#1%
	\pgfplotstablegetname#1\pgfplotstable@loc@TMPa
	\expandafter\let\csname\string#2@@table@name\endcsname=\pgfplotstable@loc@TMPa
	\expandafter\edef\csname\string#2@@table@scanline\endcsname{\pgfplotstablescanlinelengthof{#1}}%
	\pgfplotslistforeachungrouped#1\as\pgfplotstable@loc@TMPa{%
		\def\pgfplotstable@loc@TMPb{%
			\expandafter\let\csname\string#2@\pgfplotstable@loc@TMPa\endcsname}%
		\expandafter\pgfplotstable@loc@TMPb\csname\string#1@\pgfplotstable@loc@TMPa\endcsname
	}%
}

% Returns the file name of table '#1' into macro #2.
\def\pgfplotstablegetname#1#2{%
	\expandafter\let\expandafter#2\csname\string#1@@table@name\endcsname
}
	
% expands to the table file name of table '#1'
\def\pgfplotstablenameof#1{%
	\csname\string#1@@table@name\endcsname
}

% Returns the value of \pgfplotsscanlinelength for table '#1' into
% macro #2.
\def\pgfplotstablegetscanlinelength#1#2{%
	\expandafter\let\expandafter#2\csname\string#1@@table@scanline\endcsname
}%

% Expands to the scan line length of table '#1'.
\def\pgfplotstablescanlinelengthof#1{\csname\string#1@@table@scanline\endcsname}%

% Creates a new column named #1 and appends it to table #2.
%
% The column entries will be created using the command keys
% 'create col/assign' 
% 'create col/assign last'
%
% The key 'create col/assign' will be invoked for every row of table #2.
% It is supposed to assign the key 'create col/next content'.
% During evaluation of 'create col/assign', the macro '\thisrow{<col name>}' 
% expands to the current row's value of the column named by <col name>.
% Furthermore, '\nextrow{<col name>}' expands to the \emph{next} row's
% value of the designated column.
%
% Since the "next row" is not available if we are currently processing
% the last row, 'create col/assign last' is used in for the last row's
% value.
%
% You can use
% - \thisrow{<col name>}, 
% - \getthisrow{<col name>}{\macro}
% - \nextrow{<col name>}, 
% - \getnextrow{<col name>}{\macro}
%
% FIXME this documentation is incomplete. Please refer to pgfplotstable.pdf .
\def\pgfplotstablecreatecol{%
	\pgfutil@ifnextchar[{%
		\pgfplotstablecreatecol@opt
	}{%
		\pgfplotstablecreatecol@opt[]%
	}%
}%


% Typesets a table.
%
% \pgfplotstabletypeset[<options>]<\tablestructure>
% or
% \pgfplotstabletypeset[<options>]{<file name>}
%
% If you do not select any columns, the complete table is drawn.
%
% There are several options and styles which are available in
% <options>, see the declaration above.
%
% ATTENTION: the default implementation employs
% \begin{tabular}...\end{tabular} and is therefor only usable with
% LaTeX!
%
% You will need to reconfigure the tables.
%
% Inside of \pgfplotstabletypeset, the macros
% \pgfplotstablecol,\pgfplotstablecolname and
% \pgfplotstablerow will expand to the current column index, column
% name and row index, respectively.
\def\pgfplotstabletypeset{%
	\pgfutil@ifnextchar[{%	
		\pgfplotstabletypeset@opt
	}{%
		\pgfplotstabletypeset@opt[]%
	}%
}
\long\def\pgfplotstabletypeset@opt[#1]{%
	\begingroup
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstableset{#1}%
	\fi
	\pgfplotstablereadpreparecatcodes
	\pgfplotstabletypeset@opt@collectarg[#1]%
}
\long\def\pgfplotstabletypeset@opt@collectarg[#1]#2{%
	\pgfplotstable@isloadedtable{#2}%
		{\pgfplotstabletypeset@opt@[#1]{#2}}%
		{\pgfplotstabletypesetfile@opt@[#1]{#2}}%
}

% calls \pgfplotstableset{every table={1},#2}.
%
% The reason for this extra macro is speed: it turned out to be
% important that all options '#2' are ALREADY set (to determine
% catcodes for the input table data).
% However, '#2' should be set after 'every table' such that 'every
% table' won't get higher precedence. So: set '#2' again.
%
% This macro does nothing if 'every table' is empty.
%
% #1: the table name (argument to 'every table')
% #2: other options.
\long\def\pgfplotstableset@every@table@BEFORE@other@options#1#2{%
	\pgfkeysgetvalue{/pgfplots/table/every table/.@cmd}\pgfplotstable@loc@TMPa
	\ifx\pgfplotstable@loc@TMPa\pgfplots@empty@style@key
	\else
		\pgfplotstableset{/pgfplots/table/every table={#1},#2}%
	\fi
}%

% Like \pgfplotstabletypeset, but the first argument is a file name.
% This is the same now; it will be recognised automatically.
\let\pgfplotstabletypesetfile=\pgfplotstabletypeset
\long\def\pgfplotstabletypesetfile@opt@[#1]#2{%
	%\begingroup <--- is already opened!
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstableset@every@table@BEFORE@other@options{#2}{#1}%
		\pgfplots@table@options@aresettrue
	\fi
	\ifpgfplotstabletypeset@force@remake
		\pgfplotstabletypeset@includeoutfilesfalse
	\else
		\ifpgfplotstabletypeset@includeoutfiles
			\pgfplotstabletypeset@includeoutfilesfalse
			\pgfkeysgetvalue{/pgfplots/table/outfile}\pgfplotstable@outfilename
			\ifx\pgfplotstable@outfilename\pgfutil@empty
			\else
				\openin\r@pgfplots@reada=\pgfplotstable@outfilename\relax
				\ifeof\r@pgfplots@reada
				\else
					\pgfplotstabletypeset@includeoutfilestrue
				\fi
				\closein\r@pgfplots@reada
			\fi
		\fi
	\fi
	\ifpgfplotstabletypeset@includeoutfiles
		\input \pgfplotstable@outfilename\relax	
	\else
		\pgfplotstableread{#2}\pgfplotstabletypesetfile@opt@@
		\ifx\pgfplotstabletypesetfile@opt@@\relax
			% ERROR.
		\else
			\pgfplotstabletypeset\pgfplotstabletypesetfile@opt@@
		\fi
	\fi
	\pgfkeysgetvalue{/pgfplots/table/write to macro}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\def\pgfplots@loc@TMPa{\pgfutil@empty}%
	\else
		\expandafter\ifx\pgfplots@loc@TMPa\relax
			% is it really defined? NO! Sanity checking here:
			\def\pgfplots@loc@TMPa{\pgfutil@empty}%
		\fi
	\fi
	\expandafter\pgfmath@smuggleone\pgfplots@loc@TMPa
	\endgroup
}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% IMPLEMENTATION
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newif\ifpgfplotstableread@curline@contains@colnames
\newif\ifpgfplotstableread@foundcolnames
\newif\ifpgfplotstableread@skipline

% A method which is necessary to work with inline table data.
%
% It needs to be invoked BEFORE the inline table data has been
% seen the first time. "Seen" means collected as argument!
%
% The macro changes \catcodes in order to implement the 'row sep=newline',
% some special 'col sep' choices and the 'ignore chars' features.
\def\pgfplotstablereadpreparecatcodes{%
	\edef\pgfplotstableread@restorecatcodes{%
		\noexpand\catcode`\noexpand\^^M=\the\catcode`\^^M\space
	}%
	\ifcase\pgfplotstableread@FORMAT@CASE\relax
		% format=auto
		\pgfplotstablereadpreparecatcodes@
	\or
		% format=inline
		\pgfplotstablereadpreparecatcodes@
	\fi
	\pgfplotstableinstallignorechars
}
\def\pgfplotstablereadpreparecatcodes@{%
	\if0\pgfplotstableread@ROWSEP@CASE\relax
		% row sep = newline
		\catcode`\^^M=12
	\fi
	\ifcase\pgfplotstableread@COLSEP@CASE\relax
		% col sep=space:
		\catcode`\ =10
	\or
		% col sep=comma:
	\or
		% col sep=semicolon:
		\catcode`\;=12
	\or
		% col sep=colon:
		\catcode`\:=12
	\or
		% col sep=brace:
	\or
		% col sep=tab:
		\catcode`\^^I=12
	\fi
}%

% Accept one of
% \pgfplotstableread[#1]{<file>}{<\macro>}
% \pgfplotstableread[#1]{<file>} to listener{<\macro>}
% or
% \pgfplotstableread[#1]{<file>} to {<\macro>} (DEPRECATED)
\long\def\pgfplotstableread@impl[#1]{%
	\ifpgfplots@tableread@use@begingroup
		\begingroup
		\def\endgroup@@pgfplotstableread{\endgroup}%
	\else
		\let\endgroup@@pgfplotstableread=\relax%
	\fi
	% set options here, although we can't evaluate 'every table' yet
	% (the file name is not yet known).
	% But #1 may contain input format specifiers which are important
	% for \catcodes, BEFORE we have read the second argument:
	\pgfplotstableset{#1}%
	%
	\pgfplotstablereadpreparecatcodes
	%
	\pgfplotstableread@impl@collectfirstarg{#1}%
}%
\long\def\pgfplotstableread@impl@collectfirstarg#1#2{%
	\pgfutil@ifnextchar t{%
		\pgfplotstableread@impl@@{#1}{#2}%
	}{%
		\pgfplotstableread@impl@{#1}{#2}%
	}%
}%


% I don't know why; but I started with 
% >> \pgfplotstableread[]{file} to \macro
% That ' to ' is really ugly. This here is for backwards
% compatibility:
\long\def\pgfplotstableread@impl@@#1#2to {%
	\pgfutil@ifnextchar l{%
		\pgfplotstableread@impl@@listener{#1}{#2}%
	}{%
		\pgfplotstableread@impl@{#1}{#2}%
	}%
}%
\long\def\pgfplotstableread@impl@@listener#1#2listener#3{%
	\pgfplots@tableread@to@listenertrue
	\pgfplotstableread@impl@{#1}{#2}{#3}%
	\pgfplots@tableread@to@listenerfalse
}%

\newif\ifpgfplotstableread@inline
\long\def\pgfplotstableread@checkinlineformat@CRCR#1\\#2\pgfplotstable@EOI{%
	\def\pgfplotstable@loc@TMPa{#2}%
	\ifx\pgfplotstable@loc@TMPa\pgfutil@empty
		\pgfplotstableread@inlinefalse
	\else
		\pgfplotstableread@inlinetrue
		\let\pgfplotstableread@loop@next=\pgfplotstableread@loop@next@CRCR
	\fi
}%
\long\def\pgfplotstableread@loop@next@CRCR#1\\{%
	\long\def\pgfplotstable@LINE{#1}%
	\pgfplotstableread@loop@processnextline
	\pgfplotstableread@loop@over@lines
}%
\begingroup
\catcode`\^^M=12\relax%
\long\gdef\pgfplotstableread@checkinlineformat@NL@#1^^M#2\pgfplotstable@EOI{%
	\def\pgfplotstable@loc@TMPa{#2}%
	\ifx\pgfplotstable@loc@TMPa\pgfutil@empty%
		\pgfplotstableread@inlinefalse%
	\else%
		\pgfplotstableread@inlinetrue%
		\let\pgfplotstableread@loop@next=\pgfplotstableread@loop@next@NL%
	\fi%
}%
\long\gdef\pgfplotstableread@checkinlineformat@NL#1{%
	\pgfplotstableread@checkinlineformat@NL@ #1^^M\pgfplotstable@EOI%
}%
\long\gdef\pgfplotstableread@loop@next@NL#1^^M{%
	\long\def\pgfplotstable@LINE{#1}%
	\pgfplotstableread@loop@processnextline%
	\pgfplotstableread@loop@over@lines%
}%
\endgroup

% #1: options.
% #2: the table content (file name or inline data)
% #3: the result macro.
\long\def\pgfplotstableread@impl@#1#2#3{%
	\ifcase\pgfplotstableread@FORMAT@CASE\relax
		% format=auto
		\ifcase\pgfplotstableread@ROWSEP@CASE\relax
			% row sep=newline
			\pgfplotstableread@checkinlineformat@NL{#2}%
		\or
			% row sep=crcr
			\pgfplotstableread@checkinlineformat@CRCR #2\\\pgfplotstable@EOI
		\fi
	\or
		% format=inline
		\pgfplotstableread@inlinetrue
		\ifcase\pgfplotstableread@ROWSEP@CASE\relax
			% row sep=newline
			\let\pgfplotstableread@loop@next=\pgfplotstableread@loop@next@NL
		\or
			% row sep=crcr
			\let\pgfplotstableread@loop@next=\pgfplotstableread@loop@next@CRCR
		\fi
	\or
		\pgfplotstableread@inlinefalse
	\fi
	%
	\ifpgfplotstableread@inline
		\def\pgfplotstableread@impl@fCLOSE{}%
		\let\pgfplotstableread@loop@over@lines=\pgfplotstableread@loop@over@lines@frominline%
		\long\def\pgfplotstableread@start@loop{%
			\pgfplotstableread@loop@over@lines #2\pgfplotstable@EOI
		}%
		\def\pgfplotstableread@ready{1}%
		\def\pgfplotstableread@filename{<inline_table>}%
	\else
		\def\pgfplotstableread@ready{1}%
		\def\pgfplotstableread@filename{#2}%
		\pgfplotstableread@openfile
		\def\pgfplotstableread@impl@fCLOSE{%
			\closein\r@pgfplots@reada
		}%
		\let\pgfplotstableread@loop@over@lines=\pgfplotstableread@loop@over@lines@fromfile%
		\def\pgfplotstableread@start@loop{\pgfplotstableread@loop@over@lines}%
	\fi
	\edef\pgfplotstableread@oldendlinechar{\the\endlinechar}%
	\pgfplotstableread@restorecatcodes
	\endlinechar=-1 % do not append a white space after each line for file input
%\pgfplots@message{ATTEMPTING TO READ \pgfplotstableread@filename}%
	%
	\def\pgfplots@loc@TMPa{\pgfplotstableread@impl@prepare{#1}}%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplotstableread@filename}{#3}%
	%
	\if1\pgfplotstableread@ready
		\pgfplotstableread@start@loop
		%
		\pgfplotstableread@impl@fCLOSE%
		%
		\pgfplotstableread@finish
		%
	\fi
	\endlinechar=\pgfplotstableread@oldendlinechar
	\pgfplotsscanlinelengthcleanup
	\expandafter\pgfplotstable@copy@to@globalbuffers@simple\expandafter{\pgfplotstableread@filename}%
	\endgroup@@pgfplotstableread
	\ifpgfplots@tableread@to@listener
		% there are no data structures in this case.
		\let\pgfplotsscanlinelength=\pgfplotstable@glob@buf@scanline
	\else
		% Now, we can access the global variables!
		% copy them to #3.
		\pgfplotstable@copy@globalbuffers@to#3%
	\fi
}

{\catcode`\"=12 \gdef\pgfplots@dquote{"}}

% Opens \pgfplotstableread@filename.
\def\pgfplotstableread@openfile{%
	\def\pgfplotstable@loc@TMPa{\pgfutil@in@{ }}%
	\expandafter\pgfplotstable@loc@TMPa\expandafter{\pgfplotstableread@filename}%
	\ifpgfutil@in@
		\t@pgfplots@toka=\expandafter{\pgfplotstableread@filename}%
		\edef\pgfplotstableread@filename{\pgfplots@dquote\the\t@pgfplots@toka\pgfplots@dquote}%
	\fi
	\let\pgfplotstableread@old@crcr=\\%
	\def\\{\string\\}% just to make sure we don't try to open inline table data...
	\openin\r@pgfplots@reada=\pgfplotstableread@filename.tex
	\ifeof\r@pgfplots@reada
		\openin\r@pgfplots@reada=\pgfplotstableread@filename\relax
	\else
		\pgfplots@warning{%
			You requested to open table '\pgfplotstableread@filename', but there is also a '\pgfplotstableread@filename.tex'. 
			TeX will automatically append the suffix '.tex', so I will now open '\pgfplotstableread@filename.tex'.
			Please make sure you don't accidentally load TeX files - this may produce unrecoverable errors.}%
		\closein\r@pgfplots@reada
		\openin\r@pgfplots@reada=\pgfplotstableread@filename\relax
	\fi
	\pgfplots@logfileopen{\pgfplotstableread@filename}%
	%
	\ifeof\r@pgfplots@reada
		\pgfplotsthrow{no such table file}{\pgfplots@loc@TMPa}{\pgfplotstableread@filename}{Could not read table file '\pgfplotstableread@filename'. In case you intended to provide inline data: maybe TeX screwed up your end-of-lines? Try `row sep=crcr' and terminate your lines with `\string\\' (refer to the pgfplotstable manual for details)}\pgfeov%
		\global\let\pgfplotstable@colnames@glob=\pgfplots@loc@TMPa
		\def\pgfplotstableread@ready{0}%
	\fi
	\let\\=\pgfplotstableread@old@crcr
}

\def\pgfplotstableinstallignorechars{%
	\pgfkeysgetvalue{/pgfplots/table/ignore chars}\pgfplotstable@loc@TMPa
	\ifx\pgfplotstable@loc@TMPa\pgfutil@empty
	\else
		\expandafter\pgfplotsutilforeachcommasep\expandafter{\pgfplotstable@loc@TMPa}\as\pgfplotstable@loc@TMPa{%
			\expandafter\catcode\expandafter`\pgfplotstable@loc@TMPa=9
		}%
	\fi
	\pgfkeysgetvalue{/pgfplots/table/white space chars}\pgfplotstable@loc@TMPa
	\ifx\pgfplotstable@loc@TMPa\pgfutil@empty
	\else
		\expandafter\pgfplotsutilforeachcommasep\expandafter{\pgfplotstable@loc@TMPa}\as\pgfplotstable@loc@TMPa{%
			\expandafter\catcode\expandafter`\pgfplotstable@loc@TMPa=10
		}%
	\fi
}%		

% #1: any options to set (respect \ifpgfplots@table@options@areset )
% #2: the file name (if any)
% #3: the output macro (or listener)
\def\pgfplotstableread@impl@prepare#1#2#3{%
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstableset@every@table@BEFORE@other@options{#2}{#1}%
	\fi
	%
	% local counter definitions:
	\ifpgfplots@tableread@use@begingroup
		\let\pgfplotstableread@lineno=\c@pgf@counta
		\let\pgfplotstableread@numcols=\c@pgf@countb
		\let\pgfplotstableread@curcol=\c@pgf@countc
		\let\pgfplotstableread@usablelineno=\c@pgf@countd
		\def\thepgfplotstableread@lineno{\the\pgfplotstableread@lineno}%
		\def\thepgfplotstableread@usablelineno{\the\pgfplotstableread@usablelineno}%
		\def\thepgfplotstableread@curcol{\the\pgfplotstableread@curcol}%
		\def\thepgfplotstableread@numcols{\the\pgfplotstableread@numcols}%
		\def\pgfplotstableread@countreset##1{##1=0 }%
		\def\pgfplotstableread@countset##1##2{##1=##2\relax}%
		\def\pgfplotstableread@countadvance##1{\advance##1 by1 }%
	\else
		% don't re-use integers! We have no protecting scopes!
		\def\thepgfplotstableread@lineno{\pgfplotstableread@lineno}%
		\def\thepgfplotstableread@usablelineno{\pgfplotstableread@usablelineno}%
		\def\thepgfplotstableread@curcol{\pgfplotstableread@curcol}%
		\def\thepgfplotstableread@numcols{\pgfplotstableread@numcols}%
		\def\pgfplotstableread@countreset##1{\def##1{0}}%
		\def\pgfplotstableread@countset##1##2{\def##1{##2}}%
		\def\pgfplotstableread@countadvance##1{\pgfplotsutil@advancestringcounter{##1}}%
	\fi
	\pgfplotstableread@countreset\pgfplotstableread@lineno
	\pgfplotstableread@countreset\pgfplotstableread@usablelineno
	\pgfplotstableread@countreset\pgfplotstableread@numcols
	\pgfplotstableread@countreset\pgfplotstableread@curcol
	%
	\pgfplotstableread@impl@prepare@DO
	\def\pgfplotstableread@isgnuplotformat{0}%
	\global\pgfplotslistnewempty\pgfplotstable@colnames@glob
	\pgfplotsscanlinelengthinitzero
	\ifpgfplots@tableread@to@listener
		\def\pgfplotstablerow{\thepgfplotstableread@usablelineno}%
		\def\pgfplotstablelineno{\thepgfplotstableread@lineno}%
		\let\pgfplotstable@listener=#3%
		\let\pgfplotstableread@impl@nextrow@NEXT=\pgfplotstableread@impl@nextrow@NEXT@listener
		\let\pgfplotstablereadgetcolindex=\pgfplotstablereadgetcolindex@
		\let\pgfplotstablereadgetcolname=\pgfplotstablereadgetcolname@
		\let\pgfplotstablereadgetptrtocolname=\pgfplotstablereadgetptrtocolname@
		\let\pgfplotstablereadgetptrtocolindex=\pgfplotstablereadgetptrtocolindex@
		\let\pgfplotstablereadevalptr=\pgfplotstablereadevalptr@
		\let\pgfplotstablereadvalueofptr=\pgfplotstablereadvalueofptr@
		\let\pgfplotstableforeachcolumn=\pgfplotstableforeachcolumn@listener
		\let\pgfplotstablereadvalueofcolname=\pgfplotstablereadvalueofcolname@
		\let\pgfplotstablereadvalueofcolindex=\pgfplotstablereadvalueofcolindex@
		\let\getthisrow=\pgfplotstablereadgetcolname
		\let\thisrow=\pgfplotstablereadvalueofcolname
		\let\thisrowno=\pgfplotstablereadvalueofcolindex
		\let\getthisrowno=\pgfplotstablereadgetcolindex
	\fi
}%

% Copies the table column list and the column vectors of #1 to global buffers. 
% @see \pgfplotstable@copy@globalbuffers@to
%
% Use these two methods to avoid scoping problems.
%
% #1: the <\macro> name of the table which is to be copied to global buffers.
% #2: the table file name.
\def\pgfplotstable@copy@to@globalbuffers#1#2{%
	\global\let\pgfplotstable@colnames@glob=#1
	\c@pgfplotstable@counta=0\relax%
	\pgfplotslistforeachungrouped\pgfplotstable@colnames@glob\as\pgfplotstable@loc@TMPa{%
		\def\pgfplotstable@loc@TMPb{%
			\expandafter\global\expandafter\let\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname%
		}%
		\expandafter\pgfplotstable@loc@TMPb\csname\string#1@\pgfplotstable@loc@TMPa\endcsname
		\advance\c@pgfplotstable@counta by1\relax
	}%
	\pgfplotstable@copy@to@globalbuffers@simple{#2}%
}%
% A variant of \pgfplotstable@copy@to@globalbuffers which copies only
% the member variables of a loaded table (the name and scanline length) to
% global buffers.
%
% #1: the table's file name.
%
% @PRECONDITION: any other variables and cell data of the table are already stored
% in global buffers.
\def\pgfplotstable@copy@to@globalbuffers@simple#1{%
	\gdef\pgfplotstable@glob@buf@name{#1}%
	\global\let\pgfplotstable@glob@buf@scanline=\pgfplotsscanlinelength
}%

% copies the global column list and the global column vectors to #1
% (NOT the table file name).
% @see \pgfplotstable@copy@to@globalbuffers
%
% @PRECONDITION the global buffers contain all members of a table.
% 
% @POSTCONDITION The table '#1' is be initialised to these members.
% 		Furthermore, \pgfplotsscanlinelength is set.
\def\pgfplotstable@copy@globalbuffers@to#1{%
	\let#1=\pgfplotstable@colnames@glob
	\c@pgfplotstable@counta=0\relax%
	\pgfplotslistforeachungrouped\pgfplotstable@colnames@glob\as\pgfplotstable@loc@TMPa{%
		\def\pgfplotstable@loc@TMPb{%
			\expandafter\let\csname\string#1@\pgfplotstable@loc@TMPa\endcsname}%
		\expandafter\pgfplotstable@loc@TMPb\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname
%\message{Column '\pgfplotstable@loc@TMPa' has entries: \expandafter\meaning\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname}%
		\expandafter\global\expandafter\let\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@counta\endcsname=\pgfutil@empty
		\advance\c@pgfplotstable@counta by1\relax
	}%
	\global\let\pgfplotstable@colnames@glob=\pgfutil@empty
	\expandafter\let\csname\string#1@@table@scanline\endcsname=\pgfplotstable@glob@buf@scanline
	\expandafter\let\csname\string#1@@table@name\endcsname=\pgfplotstable@glob@buf@name
	\let\pgfplotsscanlinelength=\pgfplotstable@glob@buf@scanline
}%

\def\pgfplotstableread@finish{%
	\pgfplotsscanlinecomplete
	\ifpgfplots@tableread@to@listener
	\else
		\ifpgfplotstableread@foundcolnames
		\else
			\pgfplotstableread@create@column@names@with@numbers
		\fi
		\pgfplotstableread@countreset\pgfplotstableread@curcol%
		\pgfutil@loop
		\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols\relax
			\expandafter\pgfplotsapplistXflushbuffers\csname pgfp@numtable@glob@col@\thepgfplotstableread@curcol\endcsname
			\pgfplotstableread@countadvance\pgfplotstableread@curcol
		\pgfutil@repeat
	\fi
}

\def\pgfplotstableread@loop@over@lines@fromfile{%
	\ifeof\r@pgfplots@reada
%\pgfplots@message{EOF}%
	\else
		\read\r@pgfplots@reada to\pgfplotstable@LINE
		\ifeof\r@pgfplots@reada
		\else
			\pgfplotstableread@loop@processnextline
		\fi
		\expandafter\pgfplotstableread@loop@over@lines
	\fi
}%
\def\pgfplotstableread@loop@over@lines@frominline{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfutil@gobble
	}{%	
		\pgfplotstableread@loop@next
	}%
}%

% PRECONDITION: 
% 	\pgfplotstable@LINE contains the current input line.
\def\pgfplotstableread@loop@processnextline{%
	\expandafter\pgfplotstableread@checkspecial@line\pgfplotstable@LINE\pgfplotstable@EOI
	\ifpgfplotstableread@skipline
		\def\pgfplotstableread@gnuplotcheck{####x y type}%
		\ifx\pgfplotstableread@gnuplotcheck\pgfplotstable@LINE
			\def\pgfplotstableread@isgnuplotformat{1}%
		\fi
		\def\pgfplotstableread@gnuplotcheck{####x y z type}%
		\ifx\pgfplotstableread@gnuplotcheck\pgfplotstable@LINE
			\def\pgfplotstableread@isgnuplotformat{1}%
		\fi
	\else
		%--------------------------------------------------
		% \ifnum\pgfplotstableread@lineno=0
		% 	\let\pgfplotstable@firstline=\pgfplotstable@LINE
		% \fi
		%-------------------------------------------------- 
%\pgfplots@message{READING LINE \thepgfplotstableread@lineno: '\meaning\pgfplotstable@LINE'.}%
		\pgfplotstableread@curline@contains@colnamesfalse
		\ifnum\pgfplotstableread@numcols=0\relax
			% STEP 0: initialise
			% 	- count columns
			% 	- find header data
			\pgfplotstableread@countreset\pgfplotstableread@curcol
			\ifpgfplotstable@firstline@is@header
				\pgfplotstableread@curline@contains@colnamestrue
			\fi
			\pgfplotstableread@impl@DO\pgfplotstableread@impl@countcols@and@identifynames@NEXT\pgfplotstable@LINE
			\pgfplotstableread@countset\pgfplotstableread@numcols{\pgfplotstableread@curcol}%
			\pgfplotstableread@countreset\pgfplotstableread@curcol
			% Create empty column lists:
			\pgfplotstableread@create@column@lists
			%
			\ifnum\pgfplotstableread@usablelineno=0\relax
			\if1\pgfplotstableread@isgnuplotformat%
				% The file started with
				% #...
				% #x y type
				% X Y i
				% -> thats a gnuplot file!
				\pgfplotstableread@curline@contains@colnamesfalse
			\fi
			\fi
			% Now, read the first line.
			% It contains either
			% - column names,
			% - numerical data,
			% - nothing (comments).
			\ifpgfplotstableread@curline@contains@colnames
				\pgfplotstableread@foundcolnamestrue
				\pgfplotstableread@countreset\pgfplotstableread@curcol
				\pgfplotstableread@impl@DO\pgfplotstableread@impl@collectcolnames@NEXT\pgfplotstable@LINE
			\else
				\pgfplotsscanlinelengthincrease
				\pgfplotstableread@foundcolnamesfalse
				\pgfplotstableread@countreset\pgfplotstableread@curcol
				% Leave column name lists empty...
				\pgfplotstableread@impl@DO\pgfplotstableread@impl@nextrow@NEXT\pgfplotstable@LINE
			\fi
%\pgfplots@message{After reading first row: found '\thepgfplotstableread@numcols' columns; column name list='\meaning\pgfplotstable@colnames@glob'}%
		\else
			\pgfplotsscanlinelengthincrease
			\pgfplotstableread@countreset\pgfplotstableread@curcol
			\pgfplotstableread@impl@DO\pgfplotstableread@impl@nextrow@NEXT\pgfplotstable@LINE
		\fi
		\ifnum\pgfplotstableread@curcol=\pgfplotstableread@numcols\relax
		\else
			\pgfplotstable@error{input table '\pgfplotstableread@filename' has an unbalanced number  of columns in row '\thepgfplotstableread@lineno' (expected '\thepgfplotstableread@numcols' cols; got '\thepgfplotstableread@curcol'). Maybe the input table is corrupted? If you need unbalanced data, consider using 'nan' in empty cells (perhaps combined with 'unbounded coords=jump')}%
		\fi
		\ifpgfplots@tableread@to@listener
			\ifpgfplotstableread@curline@contains@colnames
			\else
				% report row!
				\pgfplotstable@listener
			\fi
		\fi
		\pgfplotstableread@countadvance\pgfplotstableread@usablelineno
	\fi
	\pgfplotstableread@countadvance\pgfplotstableread@lineno
}%

% WARNING: this routine is also used in pgfplots.code.tex ...
\def\pgfplotstableread@checkspecial@line{%
	\pgfutil@ifnextchar##{%
		\pgfplotstableread@skiplinetrue
		\pgfplotstableread@impl@gobble
	}{%
		\pgfutil@ifnextchar${%
			\pgfplotstableread@process@flags@line
		}{%
			\pgfutil@ifnextchar\pgfplotstable@EOI{%
				\pgfplotstableread@skiplinetrue
				\pgfplotsscanlinecomplete% the line is empty; same as \par!
				\pgfplotstableread@impl@gobble
			}{%
				\pgfutil@ifnextchar\par{%
					\pgfplotstableread@skiplinetrue
					\pgfplotsscanlinecomplete
					\pgfplotstableread@impl@gobble
				}{%
					\pgfplotstableread@skiplinefalse
					\pgfplotstableread@impl@gobble
				}%
			}%
		}%
	}%
}

\long\def\pgfplotstableread@process@flags@line$flags {%
%\pgfplots@message{Ignoring flags line ...}%
	\pgfplotstableread@skiplinetrue
	\pgfplotstableread@impl@gobble
}

\def\pgfplotstableread@create@column@lists{%
	\pgfutil@loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols\relax
		\def\pgfplots@loc@TMPa{\pgfplotsapplistXnewempty[to global]}%
		\expandafter\pgfplots@loc@TMPa\csname pgfp@numtable@glob@col@\thepgfplotstableread@curcol\endcsname
		\pgfplotstableread@countadvance\pgfplotstableread@curcol
	\pgfutil@repeat
}

\def\pgfplotstableread@create@column@names@with@numbers{%
	\pgfplotstableread@countreset\pgfplotstableread@curcol
	\pgfutil@loop
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols\relax
		\edef\pgfplotstable@loc@TMPb{\thepgfplotstableread@curcol}%
		\expandafter\pgfplotslistpushbackglobal\pgfplotstable@loc@TMPb\to\pgfplotstable@colnames@glob
		\pgfplotstableread@countadvance\pgfplotstableread@curcol
	\pgfutil@repeat
}

\long\def\pgfplotstableread@impl@gobble#1\pgfplotstable@EOI{}%

\def\pgfplotstable@EOI{\pgfplotstable@EOI}%

%%%%%%%%%%%%%%%

% A loop command which processes every single entry in a raw data row #2 
% and invokes the macro #1{<arg>}  for each found column entry.
%
% Columns are separated by the /pgfplots/table/col sep character.
%
% #1: a command which takes precisely one argument. It will be called
% for each found column entry
%
% #2: a macro containing a raw data line with <col sep> separated
% entries.
\long\def\pgfplotstableread@impl@DO#1#2{%
	\let\pgfplotstableread@impl@ITERATE@NEXT@=#1\relax
	\expandafter\pgfplotstableread@impl@DO@\expandafter{#2}%
}
{%
	\catcode`\ =10
	\catcode`\;=12
	\catcode`\:=12
	\gdef\pgfplotstableread@impl@prepare@DO{%
		\ifcase\pgfplotstableread@COLSEP@CASE\relax
			% col sep=space:
			\catcode`\ =10
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1 \pgfplotstable@EOI}%
		\or
			% col sep=comma:
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@COMMA
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1,\pgfplotstable@EOI}%
		\or
			% col sep=semicolon:
			\catcode`\;=12
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@SEMICOLON
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1;\pgfplotstable@EOI}%
		\or
			% col sep=colon:
			\catcode`\:=12
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@COLON
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1:\pgfplotstable@EOI}%
		\or
			% col sep=brace:
			% allow multi line cells:
			\endlinechar=\pgfplotstableread@oldendlinechar\relax
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@BRACE
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1\pgfplotstable@EOI}%
		\or
			% col sep=tab:
			\catcode`\^^I=12
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@TAB
			\long\edef\pgfplotstableread@impl@DO@##1{\noexpand\pgfplotstableread@impl@ITERATE##1\pgfplotstableread@tab\noexpand\pgfplotstable@EOI}%
		\or
			% col sep=&:
			\let\pgfplotstableread@impl@ITERATE@NEXT=\pgfplotstableread@impl@ITERATE@NEXT@AMPERSAND
			\long\def\pgfplotstableread@impl@DO@##1{\pgfplotstableread@impl@ITERATE##1&\pgfplotstable@EOI}%
		\fi
	}%
}%
\long\def\pgfplotstableread@impl@ITERATE{%
	\pgfutil@ifnextchar\pgfplotstable@EOI{%
		\pgfplotstableread@impl@gobble
	}{%
		\pgfplotstableread@impl@ITERATE@NEXT
	}%
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT#1 {%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT@COMMA#1,{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT@SEMICOLON#1;{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT@COLON#1:{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT@BRACE#1{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\long\def\pgfplotstableread@impl@ITERATE@NEXT@AMPERSAND#1&{%
	\pgfplotstableread@impl@ITERATE@NEXT@{#1}%
	\pgfplotstableread@impl@ITERATE
}%
\begingroup
\catcode`\^^I=12
\gdef\pgfplotstableread@tab{^^I}%
\long\gdef\pgfplotstableread@impl@ITERATE@NEXT@TAB#1^^I{% the following white spaces are SPACES, not tabs:
    \pgfplotstableread@impl@ITERATE@NEXT@{#1}%
    \pgfplotstableread@impl@ITERATE
}%
\endgroup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% these values are only usable for a read-listener, that means:
% when using
%
% \pgfplotstableread{<file>} to listener<\macro>
%
% -> <\macro> can than use the methods
%
% \pgfplotstablereadgetcolindex{<index>}{<\content>}
% performs \let\content=<content of column no <index> >
\def\pgfplotstablereadgetcolindex@#1#2{%
	\pgfutil@ifundefined{pgfplotstblread@colcontent@no#1}{%
		\pgfplotsthrow{no such element}{#2}{Sorry, the requested column number '#1' in table '\pgfplotstableread@filename' does not exist!? Please verify you used the correct index 0 <= i < N.}\pgfeov%
	}{%
		\expandafter\let\expandafter#2\csname pgfplotstblread@colcontent@no#1\endcsname
	}%
}%

\pgfkeysdef{/pgfplots/table/@undefined column text}{#1__column_not_found.}%
\def\pgfplotstable@undefinedtext#1{\pgfkeysvalueof{/pgfplots/table/@undefined column text/.@cmd}#1\pgfeov}%

% As \pgfplotstablereadgetcolindex, but
% \pgfplotstablereadvalueofcolindex{<index>}
% directly expands to the value stored in the desired column.
%
% Example:
% \pgfplotstablereadvalueofcolindex{3}  -> expands to '42' if '42' is
% written in column no 3.
%
% Column indexing starts at 0.
%
% @ATTENTION: since such a command may occur within an \edef or an
% \csname, it can't perform sanity checking. Proving an invalid index
% expands to \pgfkeysvalueof{/pgfplots/table/@undefined column text}.
\def\pgfplotstablereadvalueofcolindex@#1{%
	\pgfutil@ifundefined{pgfplotstblread@colcontent@no#1}{%
		\pgfplotstable@undefinedtext{colindex#1}%
	}{%
		\csname pgfplotstblread@colcontent@no#1\endcsname
	}%
}

% \pgfplotstablereadgetcolname{<name>}{<\content>}
% performs \let\content=<content of column named <name> >
\def\pgfplotstablereadgetcolname@#1#2{%
	\pgfplotstablereadgetptrtocolname{#1}{\pgfplots@loc@TMPa}%
	\pgfplotstablereadevalptr\pgfplots@loc@TMPa{#2}%
}%

% This here is the implementation of \pgfplotstablereadvalueofcolname
% (and \thisrow{<colname>}) for use inside of the 'read to listener'
% framework.
%
% Like \pgfplotstablereadgetcolname, but this one expands directly to
% the value of the desired column.
%
% #1: a column name or a column alias.
%
% @ATTENTION: since such a command may occur within an \edef or an
% \csname, it can't perform sanity checking. Proving an invalid index
% expands to \pgfkeysvalueof{/pgfplots/table/@undefined column text}.
\def\pgfplotstablereadvalueofcolname@#1{%
	\pgfplotstable@thisrow@impl{#1}{pgfplotstblread@colindex@for@name}{\pgfplotstable@thisrow@impl@read}%
}%
\def\pgfplotstable@thisrow@impl@read#1{\csname pgfplotstblread@colcontent@no#1\endcsname}%

% This implements \thisrow in different contexts.
%
% Usage:
% \def\thisrow#1{\pgfplotstable@thisrow@impl{#1}{macroprefix@}{\pgfplotstable@thisrow@impl@}}
%
% Then, \thisrow{existingcol}
% will expand to 
% -> \pgfplotstable@thisrow@impl@{\csname macroprefix@existingcol\endcsname}
% -> \csname macroprefix@existingcol\endcsname
%
% Furthermore, if '#1' is no existing col and there exists /pgfplots/table/alias/#1,
% \thisrow{aliased}
% will expand to
% -> \pgfplotstable@thisrow@impl@{\csname macroprefix@\pgfkeysvalueof{/pgfplots/table/alias/aliased}\endcsname}
% -> \csname macroprefix@\pgfkeysvalueof{/pgfplots/table/alias/aliased}\endcsname
%
% #1: the argument for \thisrow{#1}
% #2: a macro prefix such that \csname #2<colname>\endcsname contains
% the value of the current row for (physical) column <colname>
% #3: the name of a one-argument-macro which will get \csname #2<colname>\endcsname
% as argument. This is the last step of \thisrow. It allows indirect
% access by translating colnames to col indices in '\pgfplotstableread to listener'
\def\pgfplotstable@thisrow@impl#1#2#3{%
	\pgfutil@ifundefined{#2#1}%
	{%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		% *** \pgfplotstablereadvalueofcolname ***
		\pgfkeysifdefined{/pgfplots/table/alias/#1}{%
			\pgfutil@ifundefined{#2\pgfkeysvalueof{/pgfplots/table/alias/#1}}{%
				\pgfplotstable@undefinedtext{\pgfkeysvalueof{/pgfplots/table/alias/#1}}%
			}{%
				#3{\csname #2\pgfkeysvalueof{/pgfplots/table/alias/#1}\endcsname}%
			}%
		}{%
			\pgfplotstable@undefinedtext{#1}%
		}%
	}%
	{%
		#3{\csname #2#1\endcsname}%
	}%
}%
\def\pgfplotstable@thisrow@impl@#1{#1}%

% \pgfplotstablereadgetptrtocolname{<name>}{\ptr}
% Creates some sort of "pointer" to the column named <name>. This
% pointer can than be used every time a new line has been reported to
% the listener. It works like this:
%
% \let\ptr=\pgfutil@empty
% \def\macro{%
% 	\ifx\ptr\empty
% 		\pgfplotstablereadgetptrtocolname{<my col>}{\ptr}%
% 	\fi
% 	\pgfplotstablereadevalptr{\ptr}{\content}%
% 	-> do something with \content!
% }
% 	
% \pgfplotstableread{<file>} to listener<\macro>
%
% -> will evaluate \macro foreach row.
%
% The advantage of such a prepared pointer over \thisrow{#1} or
% \getthisrow{#1} is simply efficiency and sanity checking: the checks
% are done at the time of pointer creation, dereferencing the pointer
% is fast.
\def\pgfplotstablereadgetptrtocolname@#1#2{%
	% Implementation note: it is necessary to replicate code becuase
	% in this context, the table structure is NOT available.
	\pgfutil@ifundefined{pgfplotstblread@colindex@for@name#1}{%
		% Oh, there is no column '#1'!
		%
		% Check for the 'alias' feature!
		%
		% WARNING : this code has been REPLICATED in
		% *** \pgfplotstablereadgetptrtocolname ***
		% *** \pgfplotstablegetcolumnbyname ***
		% *** \pgfplotstableresolvecolname ***
		% *** \pgfplotstablereadvalueofcolname ***
		%
		\def\pgfplotstable@loc@TMPa{/pgfplots/table/alias/#1}%
		\pgfkeysifdefined{\pgfplotstable@loc@TMPa}{%
			\pgfkeysgetvalue{\pgfplotstable@loc@TMPa}{\pgfplotstable@loc@TMPb}%
			\let\pgfplotstable@loc@TMPa=\pgfplotstable@loc@TMPb
			\pgfutil@ifundefined{pgfplotstblread@colindex@for@name\pgfplotstable@loc@TMPa}{%
				\pgfplotsthrow{no such element}{#2}{Sorry, could not retrieve aliased column '\pgfplotstable@loc@TMPa' from table '\pgfplotstableread@filename'. The original request was for '#1', which does not exist either.}\pgfeov%
				\def#2{0}%
			}{%
				\edef#2{\csname pgfplotstblread@colindex@for@name\pgfplotstable@loc@TMPa\endcsname}%
			}%
		}{%
			\def\pgfplotstable@loc@TMPa{/pgfplots/table/create on use/#1}%
			\pgfkeysifdefined{\pgfplotstable@loc@TMPa/.@cmd}{%
				\pgfplotstable@error{Sorry, '\pgfplotstable@loc@TMPa' from table '\pgfplotstableread@filename' can't be evaluated in this context. Please prepare the table before using it here. You can do this using the 'read completely' key, see the manual for details.}%
			}{%
				\pgfplotsthrow{no such element}{#2}{Sorry, could not retrieve column '#1' from table '\pgfplotstableread@filename'. Please check spelling (or introduce name aliases).}\pgfeov%
			}%
			\def#2{0}%
		}%
	}{%
		\edef#2{\csname pgfplotstblread@colindex@for@name#1\endcsname}%
	}%
}%

% As \pgfplotstablereadgetptrtocolname, but this here access columns
% by index.
\def\pgfplotstablereadgetptrtocolindex@#1#2{\def#2{#1}}%

% \pgfplotstablereadevalptr{<\ptr>}{<\content}
% writes the current value of <\ptr> to <\content>. The pointer <\ptr>
% must be initialised with \pgfplotstablereadgetptrtocolname
\let\pgfplotstablereadevalptr@=\pgfplotstablereadgetcolindex@

% \pgfplotstablereadvalueofptr{<\ptr>} -> expands to the pointers value.
%
% The pointer \ptr must be initialised with
% \pgfplotstablereadgetptrtocolname.
\let\pgfplotstablereadvalueofptr@=\pgfplotstablereadvalueofcolindex@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\long\def\pgfplotstableread@impl@nextrow@NEXT@listener#1{%
	\expandafter\def\csname pgfplotstblread@colcontent@no\thepgfplotstableread@curcol\endcsname{#1}%
	\pgfplotstableread@countadvance\pgfplotstableread@curcol
}

\long\def\pgfplotstableread@impl@nextrow@NEXT#1{%
%\pgfplots@message{Inserting '#1' at (\thepgfplotstableread@lineno, \thepgfplotstableread@curcol).}%
	\ifnum\pgfplotstableread@curcol<\pgfplotstableread@numcols\relax
		\pgfplotslist@assembleentry{#1}\into\t@pgfplots@tokc
		\def\pgfplotstableread@TMP{\expandafter\pgfplotsapplistXpushback\expandafter{\the\t@pgfplots@tokc}\to}%
		\expandafter\pgfplotstableread@TMP\csname pgfp@numtable@glob@col@\thepgfplotstableread@curcol\endcsname
		\pgfplotstableread@countadvance\pgfplotstableread@curcol
	\else
		\begingroup
		\t@pgfplots@tokc={#1}%
		\pgfplotstable@error{Table '\pgfplotstableread@filename' has too much columns in line \thepgfplotstableread@lineno: Ignoring '\the\t@pgfplots@tokc'. Please verify that every cell entry is separated correctly (use braces {<cell entry>} if necessary). This error is not critical}%
		\endgroup
	\fi
}



\long\def\pgfplotstableread@impl@collectcolnames@NEXT#1{%
%\pgfplots@message{Got column name no \thepgfplotstableread@curcol\ as '#1'}%
	\pgfutil@ifundefined{pgfplotstableread@impl@COLNAME@#1}{%
		\def\pgfplotstable@loc@TMPa{#1}%
	}{% generate unique column names warning:
		\pgfplots@warning{Table '\pgfplotstableread@filename' has non-unique column name '#1'. Only the first occurence can be accessed via column names.}%
		\edef\pgfplotstable@loc@TMPa{#1--index\thepgfplotstableread@curcol}%
	}%
	\expandafter\def\csname pgfplotstableread@impl@COLNAME@#1\endcsname{foo}% remember this name.
	\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotstable@loc@TMPa}\to\pgfplotstable@colnames@glob
	\ifpgfplots@tableread@to@listener
		% create an associative container colindex -> colname
		% for use in a listener.
		\expandafter\edef\csname pgfplotstblread@colindex@for@name#1\endcsname{\thepgfplotstableread@curcol}%
	\fi
	\pgfplotstableread@countadvance\pgfplotstableread@curcol
}




\long\def\pgfplotstableread@impl@countcols@and@identifynames@NEXT#1{%
	\pgfplotstableread@countadvance\pgfplotstableread@curcol
	\ifpgfplotstable@search@header
		\ifpgfplotstableread@curline@contains@colnames
		\else
			\pgfplotstableread@isnumber@ITERATE#1\pgfplotstable@EOI
%\ifpgfplotstableread@curline@contains@colnames\pgfplots@message{'#1' is a column name!}\else\pgfplots@message{'#1' is NO column name!}\fi
		\fi
	\fi
}
\def\pgfplotstableread@isnumber@plus{+}
\def\pgfplotstableread@isnumber@minus{-}
\def\pgfplotstableread@isnumber@zero{0}
\def\pgfplotstableread@isnumber@one{1}
\def\pgfplotstableread@isnumber@two{2}
\def\pgfplotstableread@isnumber@three{3}
\def\pgfplotstableread@isnumber@four{4}
\def\pgfplotstableread@isnumber@five{5}
\def\pgfplotstableread@isnumber@six{6}
\def\pgfplotstableread@isnumber@seven{7}
\def\pgfplotstableread@isnumber@eight{8}
\def\pgfplotstableread@isnumber@nine{9}
\def\pgfplotstableread@isnumber@e{e}
\def\pgfplotstableread@isnumber@E{E}
\def\pgfplotstableread@isnumber@period{.}

\def\pgfplotstableread@isnumber@ITERATE#1{%
	\def\pgfplotstableread@CURTOK{#1}%
	\ifx\pgfplotstableread@CURTOK\pgfplotstable@EOI
		\def\pgfplotstableread@NEXT{}%
	\else
		\def\pgfplotstableread@NEXT{\pgfplotstableread@isnumber@ITERATE}%
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@plus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@minus
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@zero
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@one
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@two
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@three
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@four
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@five
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@six
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@seven
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@eight
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@nine
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@e
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@E
		\else
		\ifx\pgfplotstableread@CURTOK\pgfplotstableread@isnumber@period
		\else
%\message{NO ITS NOT!  Token: '\meaning\pgfplotstableread@CURTOK'}%
			% it's no number, so it is a column name.
			\pgfplotstableread@curline@contains@colnamestrue
			\def\pgfplotstableread@NEXT{\pgfplotstableread@impl@gobble}%
		\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
	\fi
	\pgfplotstableread@NEXT
}

\def\pgfplotstable@error#1{\pgfplotsthrow{unsupported operation}{#1}\pgfeov}%


\def\pgfplotstableset{%
	\pgfqkeys{/pgfplots/table}%
}%

% Accepts a macro #1 which contains an argument denoting a column
% name.
%
% It checks whether #1 starts with '[index]', indicating that it is actually
% a column INDEX. If that is the case,
% \ifpgfplotstableread@foundcolnames is set to false and the index is
% returned into #1.
%
% Otherwise, \ifpgfplotstableread@foundcolnames is set to true.
\def\pgfplotstable@is@colname#1{%
	\expandafter\pgfplotstabletypeset@is@colname@#1\pgfplotstable@EOI
	\ifpgfplotstableread@foundcolnames
	\else
		\let#1=\pgfplotstable@loc@TMPa
	\fi
}%
\def\pgfplotstabletypeset@is@colname@{%
	\pgfutil@ifnextchar[{%
		\pgfplotstabletypeset@is@colname@index
	}{%
		\pgfplotstableread@foundcolnamestrue
		\pgfplotstabletypeset@is@colname@name
	}%
}
\def\pgfplotstabletypeset@is@colname@index@@{index}%
\def\pgfplotstabletypeset@is@colname@index[#1]#2\pgfplotstable@EOI{%
	\def\pgfplotstable@loc@TMPa{#1}%
	\ifx\pgfplotstable@loc@TMPa\pgfplotstabletypeset@is@colname@index@@
		\pgfplotstableread@foundcolnamesfalse
		\edef\pgfplotstable@loc@TMPa{#2}%
	\else
		\pgfplotstableread@foundcolnamestrue
	\fi
}%
\def\pgfplotstabletypeset@is@colname@name#1\pgfplotstable@EOI{}%

\long\def\pgfplotstabletypeset@getfinalentry#1#2{%
	\begingroup
	\def\pgfplotstablepartno{0}%
	\pgfkeyssetvalue{/pgfplots/table/@cell content}{#1}%
	\pgfkeyssetvalue{/pgfplots/table/@unprocessed cell content}{#1}%
	\pgfplotstable@debug@notify@cellcontent%
	\pgfkeysvalueof{/pgfplots/table/preproc cell content/.@cmd}#1\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\pgfkeyslet{/pgfplots/table/@preprocessed cell content}\pgfmathresult%
	\pgfplotstable@debug@notify@cellcontent@preprocessed%
	%
	\pgfkeysgetvalue{/pgfplots/table/assign cell content/.@cmd}\pgfplotstable@assigncell
	\expandafter\pgfplotstable@assigncell\pgfmathresult\pgfeov
	\pgfplotstable@debug@notify@cellcontent@assigned%
	%
	\pgfkeysgetvalue{/pgfplots/table/postproc cell content/.@cmd}\pgfplotstable@postproccellcontent
	\ifx\pgfplotstable@postproccellcontent\pgfplotstable@postproccellcontent@EMPTY
	\else
		% apply postprocessing to final cell content.
		\def\pgfplotstabletypeset@rawinput{#1}%
		%
		% This is complicated if there is an '&' in '@cell content',
		% so handle that specially!
		%
		% FIXME also support more than one '&' ?
		\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
		\expandafter\pgfutil@in@\expandafter&\expandafter{\pgfmathresult}%
		\ifpgfutil@in@
			\expandafter\pgfplotstabletypeset@postproc@separately\pgfmathresult\pgfplotstable@EOI
		\else
			\expandafter\pgfplotstable@postproccellcontent\pgfplotstabletypeset@rawinput\pgfeov
		\fi
	\fi
	\pgfplotstable@debug@notify@cellcontent@postprocessed%
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
	\let#2=\pgfmathresult
}%

\def\pgfplotstable@debug@notify@cellcontent{}%
\def\pgfplotstable@debug@notify@cellcontent@preprocessed{}%
\def\pgfplotstable@debug@notify@cellcontent@assigned{}%
\def\pgfplotstable@debug@notify@cellcontent@postprocessed{}%
\def\pgfplotstable@debug@notify@preprocess@incol#1{}%
\def\pgfplotstable@debug@notify@preprocess@col#1{}%
\def\pgfplotstable@debug@notify@preprocessed@col#1{}%
\def\pgfplotstable@debug@notify@balancingcell{}%

\def\pgfplotstable@debug@notify@cellcontent@ACTIVE{%
	\begingroup
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\toks0=\expandafter{\pgfmathresult}%
	\immediate\write16{Row \pgfplotstablerow/out \the\c@pgfplotstable@counta: Before cell content processing: `\the\toks0'}%
	\endgroup
}%
\def\pgfplotstable@debug@notify@cellcontent@preprocessed@ACTIVE{%
	\begingroup
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\toks0=\expandafter{\pgfmathresult}%
	\immediate\write16{Row \pgfplotstablerow/out \the\c@pgfplotstable@counta: After '@preproc cell content  : `\the\toks0'}%
	\endgroup
}%
\def\pgfplotstable@debug@notify@cellcontent@assigned@ACTIVE{%
	\begingroup
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\toks0=\expandafter{\pgfmathresult}%
	\immediate\write16{Row \pgfplotstablerow/out \the\c@pgfplotstable@counta: After 'assign cell content    : `\the\toks0'}%
	\endgroup
}%
\def\pgfplotstable@debug@notify@cellcontent@postprocessed@ACTIVE{%
	\begingroup
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult%
	\toks0=\expandafter{\pgfmathresult}%
	\immediate\write16{Row \pgfplotstablerow/out \the\c@pgfplotstable@counta: After 'postproc cell content  : `\the\toks0'}%
	\endgroup
}
\def\pgfplotstable@debug@notify@balancingcell@ACTIVE{%
	\immediate\write16{Row --/out \the\c@pgfplotstable@counta: Inserting empty cell to balance rows}%
}%
\def\pgfplotstable@debug@notify@preprocess@incol@ACTIVE#1{%
	\begingroup
	\toks0=\expandafter{#1}%
	\immediate\write16{>=== Loading input column `\the\toks0' <===}%
	\endgroup
}%
\def\pgfplotstable@debug@notify@preprocess@col@ACTIVE#1{%
	\begingroup
	\toks0=\expandafter{#1}%
	\immediate\write16{>=== Preprocessing output column `\the\toks0' <===}%
	\endgroup
}%
\def\pgfplotstable@debug@notify@preprocessed@col@ACTIVE#1{%
	\begingroup
	\toks0=\expandafter{#1}%
	\immediate\write16{>=== output column `\the\toks0' prepared, ok. <===}%
	\endgroup
}%
\def\pgfplotstable@debug@activate{%
	\ifnum\pgfkeysvalueof{/pgfplots/table/debug level}>0
		\let\pgfplotstable@debug@notify@preprocess@incol=\pgfplotstable@debug@notify@preprocess@incol@ACTIVE
		\let\pgfplotstable@debug@notify@preprocess@col=\pgfplotstable@debug@notify@preprocess@col@ACTIVE
		\let\pgfplotstable@debug@notify@preprocessed@col=\pgfplotstable@debug@notify@preprocessed@col@ACTIVE
		\let\pgfplotstable@debug@notify@cellcontent=\pgfplotstable@debug@notify@cellcontent@ACTIVE
		\let\pgfplotstable@debug@notify@cellcontent@preprocessed=\pgfplotstable@debug@notify@cellcontent@preprocessed@ACTIVE
		\let\pgfplotstable@debug@notify@cellcontent@assigned=\pgfplotstable@debug@notify@cellcontent@assigned@ACTIVE
		\let\pgfplotstable@debug@notify@cellcontent@postprocessed=\pgfplotstable@debug@notify@cellcontent@postprocessed@ACTIVE
		\let\pgfplotstable@debug@notify@balancingcell=\pgfplotstable@debug@notify@balancingcell@ACTIVE
	\fi
}%

% This routine invokes 'postproc cell content' for columns which
% contain the column separator '&'.
%
% #1&#2 is the formatted number, the result of 'dec sep align
% #3 is the (unformatted) input number.
\def\pgfplotstabletypeset@postproc@separately#1&#2\pgfplotstable@EOI{%
	\def\pgfmathresult{#1}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	\expandafter\pgfplotstable@postproccellcontent\pgfplotstabletypeset@rawinput\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfplotstable@entry@a
	%
	\def\pgfplotstablepartno{1}%
	\def\pgfmathresult{#2}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
	\expandafter\pgfplotstable@postproccellcontent\pgfplotstabletypeset@rawinput\pgfeov
	\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
	\t@pgfplots@toka=\expandafter{\pgfplotstable@entry@a}%
	\t@pgfplots@tokb=\expandafter{\pgfmathresult}%
	\edef\pgfmathresult{\the\t@pgfplots@toka&\the\t@pgfplots@tokb}%
	\pgfkeyslet{/pgfplots/table/@cell content}\pgfmathresult
}

% processes the option 'assign column name'
\def\pgfplotstabletypeset@assign@final@colname#1#2{%
	\pgfkeysifdefined{/pgfplots/table/assign column name/.@cmd}{%
		\pgfkeysdef{/pgfplots/table/column name}{#1}%
		\pgfkeysvalueof{/pgfplots/table/assign column name/.@cmd}#1\pgfeov
		\pgfkeysgetvalue{/pgfplots/table/column name}{#2}%
	}{}%
}
\def\pgfplotstabletypeset@nocolname{\pgfkeysnovalue}

% checks if #1 contains invalid chars for pgfkeys and sets
% \ifpgfutil@in@ to true if that is the case.
\def\pgfplotstable@checkspecialchars@pgfkeys#1\pgfplotstable@EOI{%
	\pgfutil@in@/{#1}%
	\ifpgfutil@in@
	\else
		\pgfutil@in@={#1}%
		\ifpgfutil@in@
		\else
			\pgfutil@in@,{#1}%
		\fi
	\fi

}%

\def\pgfplotstable@insertemptycells@forbalance{%
	\pgfutil@loop
	\ifnum\c@pgfplotstable@counta<\pgfplotstable@firstnumrows\relax
		\pgfplotstable@debug@notify@balancingcell
		% let's hope @getfinalentry handles empty strings!
		\pgfplotstabletypeset@getfinalentry{}{\pgfplotstable@entry}%
		\expandafter\pgfplotslistpushback\pgfplotstable@entry\to\pgfplotstable@col@processed
		\pgfplotslistpushback\to\pgfplotstable@col@processed
		\advance\c@pgfplotstable@counta by1\relax
	\pgfutil@repeat
}

% TODO
% - replace grouped list foreach by popfront-loop and use arrays
%   directly -> group only the pgfkeys eval
\long\def\pgfplotstabletypeset@opt@[#1]#2{%
	%\begingroup <--- is already opened!
	%--------------------------------------------------
	% \pgfutil@ifundefined{#2}{%
	% 	\pgfplots@error{There is no such table '\string#2' loaded into memory. Maybe you meant to use '\string\pgfplotstabletypesetfile{\string#2}' instead of '\string\pgfplotstabletypeset{\string#2}'?}%
	% 	\pgfplotslistnewempty#2
	% }{}%
	%-------------------------------------------------- 
	\def\pgfplotstablename{#2}%
	\def\pgfplotstablecolname{\pgfplotstable@colname}%
	\def\pgfplotstablecol{\the\c@pgfplotstable@colindex}%
	\def\pgfplotstablerow{\the\c@pgfplotstable@rowindex}%
	\def\pgfplotstablecols{\the\c@pgfplotstable@numcols}%
	\def\pgfplotstablerows{\the\c@pgfplotstable@numrows}%
	\ifpgfplots@table@options@areset
	\else
		\pgfplotstablegetname{#2}\pgfplotstable@loc@TMPa
		\expandafter\pgfplotstableset@every@table@BEFORE@other@options\expandafter{\pgfplotstable@loc@TMPa}{#1}%
	\fi
	\pgfkeysgetvalue{/pgfplots/table/outfile}\pgfplotstable@outfilename
	\pgfkeysgetvalue{/pgfplots/table/TeX comment}\pgfplots@TeX@comment
	\ifpgfplotstabletypeset@force@remake
		\pgfplotstabletypeset@includeoutfilesfalse
	\else
		\ifpgfplotstabletypeset@includeoutfiles
			\pgfplotstabletypeset@includeoutfilesfalse
			\ifx\pgfplotstable@outfilename\pgfutil@empty
			\else
				\pgfplots@logfileopen{\pgfplotstable@outfilename}%
				\openin\r@pgfplots@reada=\pgfplotstable@outfilename\relax
				\ifeof\r@pgfplots@reada \else\pgfplotstabletypeset@includeoutfilestrue \fi
				\closein\r@pgfplots@reada
			\fi
		\fi
	\fi
	\ifpgfplotstabletypeset@includeoutfiles
		\input \pgfplotstable@outfilename\relax
	\else
	%
	% Prepare outfile and debug options:
	\let\pgfplotstable@notify@finished@line=\pgfutil@empty
	%
	% FLUSH assumes that \pgfplotstable@curline is finished. It
	% appends all its contents as-is to \pgfplotstable@result.
	%
	% Furthermore, it calls \pgfplotstable@notify@finished@line which
	% in turn may invoke additional output routines for the debug and
	% outfile options.
	%
	% Finally, it resets \pgfplotstable@curline.
	\def\pgfplotstable@curline@FLUSH{%
		\pgfplotstable@notify@finished@line
		\t@pgfplots@toka=\expandafter{\pgfplotstable@result}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
		\edef\pgfplotstable@result{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
		\let\pgfplotstable@curline=\pgfutil@empty
	}%
	\ifpgfplotstabletypesetdebug
		\immediate\write16{------- PGFPLOTSTABLE DEBUG MODE: --------}%
		\expandafter\def\expandafter\pgfplotstable@notify@finished@line\expandafter{\pgfplotstable@notify@finished@line
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\immediate\write16{\the\t@pgfplots@toka\pgfplots@TeX@comment}%
		}%
		\pgfplotstable@debug@activate
	\fi
	\ifx\pgfplotstable@outfilename\pgfutil@empty
	\else
		\immediate\openout\pgfplotstable@outfile=\pgfplotstable@outfilename\relax
		\expandafter\def\expandafter\pgfplotstable@notify@finished@line\expandafter{\pgfplotstable@notify@finished@line
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\immediate\write\pgfplotstable@outfile{\the\t@pgfplots@toka\pgfplots@TeX@comment}%
		}%
	\fi
	%
	% Start operation:
	\pgfkeysgetvalue{/pgfplots/table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplotstablegetcolumnlist#2\to\pgfplotstable@colnames
	\else
		\expandafter\pgfplotslistnew\expandafter\pgfplotstable@colnames\expandafter{\pgfplotstable@colnames}%
	\fi
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@colnames
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@coltypes
	\global\pgfplotslistnewempty\pgfplotstabletypeset@final@cols
	\let\c@pgfplotstable@numcols=\c@pgf@counta
	\let\c@pgfplotstable@numrows=\c@pgf@countd
	\let\c@pgfplotstable@rowindex=\c@pgf@countc
	\let\c@pgfplotstable@colindex=\c@pgf@countb
	\pgfplotslistsize\pgfplotstable@colnames\to\c@pgfplotstable@numcols
	\def\pgfplotstable@firstnumrows{-1}%
	\c@pgfplotstable@numrows=-1\relax
	\c@pgfplotstable@colindex=0\relax
	% FOREACH COLUMN:
	\pgfplotslistforeach\pgfplotstable@colnames\as\pgfplotstable@colname{%
		\pgfplotstable@debug@notify@preprocess@incol\pgfplotstable@colname
		%
		\c@pgfplotstable@rowindex=0\relax
		\pgfplotstable@is@colname\pgfplotstable@colname
		\ifpgfplotstableread@foundcolnames
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplotstable@colname\of#2\to\pgfplotstable@colname
		\fi
		\pgfplotstablegetcolumnbyname\pgfplotstable@colname\of#2\to\pgfplotstable@col
		%
		% Init number of *input* rows here. This may not be the same
		% as the number of *output* rows (see the row predicate
		% below).
		%
		% Accessable with \pgfplotstablerows in style keys.
		\ifnum\c@pgfplotstable@numrows=-1\relax
			\pgfplotslistsize\pgfplotstable@col\to\c@pgfplotstable@numrows
			\global\c@pgfplotstable@numrows=\c@pgfplotstable@numrows
		\fi
		%
		%
		% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Set keys for columns!
		\ifodd\c@pgfplotstable@colindex
			\t@pgfplots@toka={every odd column}%
		\else
			\t@pgfplots@toka={every even column}%
		\fi
		\ifnum\c@pgfplotstable@colindex=0\relax
			\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every first column}%
		\fi
		% save this now before we increment '\c@pgfplotstable@colindex':
		\edef\pgfplotstable@displaycolkey{display columns/\the\c@pgfplotstable@colindex/.try,every col no \the\c@pgfplotstable@colindex/.try}%
		%
		\global\advance\c@pgfplotstable@colindex by1\relax
		\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols
			\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every last column}%
		\fi
		% temporarily restore it: we may need it in row predicates:
		\global\advance\c@pgfplotstable@colindex by-1\relax
		\ifpgfplotstable@disable@rowcolstyles
			% ok, then don't check for 'columns/<name>' and 
			% 'display columns/<index>':
			\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka}%
		\else
			\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname}%
			\expandafter\pgfplotstable@checkspecialchars@pgfkeys\the\t@pgfplots@tokb\pgfplotstable@EOI
			\ifpgfutil@in@
				\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,columns/{\the\t@pgfplots@tokb}/.try}%
			\else
				\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,columns/\the\t@pgfplots@tokb/.try}%
			\fi
			\t@pgfplots@toka=\expandafter{\pgfplotstable@loc@TMPa}%
			\t@pgfplots@tokb=\expandafter{\pgfplotstable@displaycolkey}%
			\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,\the\t@pgfplots@tokb}%
		\fi
		\expandafter\pgfplotstableset\expandafter{\pgfplotstable@loc@TMPa}%
		% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%
		\pgfkeysgetvalue{/pgfplots/table/column name}{\pgfplotstable@colname@out}%
		\ifx\pgfplotstable@colname@out\pgfplotstabletypeset@nocolname
			\let\pgfplotstable@colname@out=\pgfplotstable@colname
		\fi
		\expandafter\pgfplotstabletypeset@assign@final@colname\expandafter{\pgfplotstable@colname@out}\pgfplotstable@colname@out
		%
		\pgfplotstable@debug@notify@preprocess@col\pgfplotstable@colname@out
		%
		\expandafter\pgfplotslistpushbackglobal\pgfplotstable@colname@out\to\pgfplotstabletypeset@final@colnames
		\pgfkeysgetvalue{/pgfplots/table/column type}{\pgfplotstable@coltype}%
		\expandafter\pgfplotslistpushbackglobal\pgfplotstable@coltype\to\pgfplotstabletypeset@final@coltypes
		%
		\pgfplotslistnewempty\pgfplotstable@col@processed
		\c@pgfplotstable@counta=0 
		\pgfplotslistforeachungrouped\pgfplotstable@col\as\pgfplotstable@entry{%
			\pgfplotstableuserowtrue
			\edef\pgfplotstable@loc@TMPa{\noexpand\pgfkeysvalueof{/pgfplots/table/row predicate/.@cmd}\the\c@pgfplotstable@rowindex}%
			\pgfplotstable@loc@TMPa\pgfeov
			\ifpgfplotstableuserow
				\ifnum\pgfplotstable@firstnumrows=-1\relax
				\else
					\ifnum\c@pgfplotstable@counta<\pgfplotstable@firstnumrows\relax
					\else
						\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
						\t@pgfplots@tokb=\expandafter{\pgfplotstable@colname@out}%
						\pgfplots@warning{Unbalanced cell with content '\the\t@pgfplots@toka' of column '\the\t@pgfplots@tokb' has been skipped: row count \the\c@pgfplotstable@counta+1 > \pgfplotstable@firstnumrows (which is the number of rows in the first column)}%
						\pgfplotstableuserowfalse
					\fi
				\fi
				\ifpgfplotstableuserow
					\expandafter\pgfplotstabletypeset@getfinalentry\expandafter{\pgfplotstable@entry}{\pgfplotstable@entry}%
					\expandafter\pgfplotslistpushback\pgfplotstable@entry\to\pgfplotstable@col@processed
					\advance\c@pgfplotstable@counta by1\relax
				\fi
			\fi
			\advance\c@pgfplotstable@rowindex by1\relax
		}%
		\ifnum\pgfplotstable@firstnumrows=-1\relax
			\xdef\pgfplotstable@firstnumrows{\the\c@pgfplotstable@counta}%
		\else
			% balance columns:
			\pgfplotstable@insertemptycells@forbalance
		\fi
		%
		\pgfplotstable@debug@notify@preprocessed@col\pgfplotstable@colname@out
		%
		\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols
		\global\advance\c@pgfplotstable@colindex by1\relax
	}%
	%
	\pgfplotslistcheckempty\pgfplotstabletypeset@final@colnames
	\ifpgfplotslistempty
		\let\pgfplotstable@result=\pgfutil@empty
	\else
		% Ok, I have now everything which will come into the final table.
		%
		% But I have it column-oriented; I need to transpose the storage.
		%
		% The following code assembles a
		% \begin{tabular}{}
		% ...
		% \end{tabular}
		% statement piece after piece.
		%
	%\message{I have now \meaning\pgfplotstabletypeset@final@colnames, and \meaning\pgfplotstabletypeset@final@cols.}%
		% Step 1: column names.
		\c@pgfplotstable@colindex=0\relax
		\c@pgfplotstable@rowindex=-1\relax
		\let\pgfplotstable@result=\pgfutil@empty
		%
		\pgfkeysgetvalue{/pgfplots/table/font}{\pgfplotstable@font}%
		\ifx\pgfplotstable@font\pgfutil@empty
		\else
			\t@pgfplots@toka=\expandafter{\pgfplotstable@font}%
			\edef\pgfplotstable@curline{\noexpand\begingroup\the\t@pgfplots@toka}%
			\pgfplotstable@curline@FLUSH
		\fi
		%
		\pgfkeysgetvalue{/pgfplots/table/begin table}{\pgfplotstable@entry}%
		\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka}%
		%
		\ifpgfplotstabletypesetskipcoltypes
		\else
			% STEP 1.1: collect column types:
			\def\pgfplotstable@resulttypes{}%
			\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@coltypes\as\pgfplotstable@coltype{%
				\t@pgfplots@toka=\expandafter{\pgfplotstable@resulttypes}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@coltype}%
				\edef\pgfplotstable@resulttypes{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
			}%
			\ifx\pgfplotstable@resulttypes\pgfutil@empty
			\else
				\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@resulttypes}%
				\edef\pgfplotstable@curline{\the\t@pgfplots@toka{\the\t@pgfplots@tokb}}%
			\fi
		\fi
		\ifx\pgfplotstable@curline\pgfutil@empty
		\else
			\pgfplotstable@curline@FLUSH
		\fi
		%
		% Step 1.2: Collect FIRST ROW (column names)
		\begingroup
		\pgfplotstableset{every head row}%
		\pgfkeysgetvalue{/pgfplots/table/before row}{\pgfplotstable@before}%
		\pgfkeysgetvalue{/pgfplots/table/after row}{\pgfplotstable@after}%
		\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
		\xdef\pgfplots@glob@TMPc{%
			\noexpand\def\noexpand\pgfplotstable@before{\the\t@pgfplots@toka}%
			\noexpand\def\noexpand\pgfplotstable@after{\the\t@pgfplots@tokb}%
		}%
		\endgroup
		\pgfplots@glob@TMPc
		% insert 'before row' here:
		\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
		\edef\pgfplotstable@curline{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
		%
		\def\pgfplotstablecolname{\pgfplotstable@colname@out}%
		\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@colnames\as\pgfplotstable@colname@out{%
			%
			\advance\c@pgfplotstable@colindex by1\relax
			% typeset the cell:
			\pgfkeysgetvalue{/pgfplots/table/typeset cell/.@cmd}\pgfplots@loc@TMPa
			\expandafter\pgfplots@loc@TMPa\pgfplotstable@colname@out\pgfeov
			\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
			%
			% append this cell:
			\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
			\t@pgfplots@tokb=\expandafter{\pgfmathresult}%
			\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
		}%
		% insert 'after row' here:
		\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
		%
		\pgfplotstable@curline@FLUSH
		%
	%\message{I have now \meaning\pgfplotstable@result.}%
		% Step 2: column contents.
		% I will first convert \pgfplotstabletypeset@final@cols into an array.
		\c@pgfplotstable@colindex=0\relax
		\pgfplotsarraynewempty\pgfplotstabletypeset@final@cols@array
		\pgfplotslistforeachungrouped\pgfplotstabletypeset@final@cols\as\pgfplotstable@col@processed{%
			\expandafter\pgfplotsarraypushback\expandafter{\pgfplotstable@col@processed}\to\pgfplotstabletypeset@final@cols@array
		}%
		% init numrows:
		\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
		\pgfplotslistsize\pgfplotstable@col@processed\to\c@pgfplotstable@numrows
		%
		% Now, we loop over every column as long as there are still rows
		% left. We assemble rows while we go.
		%
		\c@pgfplotstable@rowindex=0\relax
		\ifnum\c@pgfplotstable@colindex<\c@pgfplotstable@numcols
			\pgfplots@loop@CONTINUEtrue
		\else
			\pgfplots@loop@CONTINUEfalse
		\fi
		\def\pgfplotstablecolname{\pgfplotstable@error{Sorry, you can't evaluate \string\pgfplotstablecolname\space in this context.}}%
		\pgfutil@loop
		\ifpgfplots@loop@CONTINUE
			\pgfplotsarrayselect\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array\to\pgfplotstable@col@processed
			\pgfplotslistcheckempty\pgfplotstable@col@processed
			\ifpgfplotslistempty
				% assume that each column has the same number of entries
				% (normalised tables):
				\pgfplots@loop@CONTINUEfalse
			\else
				\ifnum\c@pgfplotstable@colindex=0\relax
					% Install styles for the next row.
					\begingroup
					\ifodd\c@pgfplotstable@rowindex
						\t@pgfplots@toka={every odd row}%
					\else
						\t@pgfplots@toka={every even row}%
					\fi
					\ifnum\c@pgfplotstable@rowindex=0\relax
						\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every first row}%
					\fi
					\ifpgfplotstable@disable@rowcolstyles
					\else
						\edef\pgfplotstable@loc@TMPa{\the\t@pgfplots@toka,every row no \the\c@pgfplotstable@rowindex/.try}%
						\t@pgfplots@toka=\expandafter{\pgfplotstable@loc@TMPa}%
					\fi
					% misuse as temporary variable:
					\c@pgfplotstable@colindex=\c@pgfplotstable@rowindex
					\advance\c@pgfplotstable@colindex by1\relax
					\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numrows
						\t@pgfplots@toka=\expandafter{\the\t@pgfplots@toka,every last row}%
					\fi
					\expandafter\pgfplotstableset\expandafter{\the\t@pgfplots@toka}%
					\pgfkeysgetvalue{/pgfplots/table/before row}{\pgfplotstable@before}%
					\pgfkeysgetvalue{/pgfplots/table/after row}{\pgfplotstable@after}%
					\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
					\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
					\xdef\pgfplots@glob@TMPc{%
						\noexpand\def\noexpand\pgfplotstable@before{\the\t@pgfplots@toka}%
						\noexpand\def\noexpand\pgfplotstable@after{\the\t@pgfplots@tokb}%
					}%
					\endgroup
					\pgfplots@glob@TMPc
					% insert 'before row' here:
					\t@pgfplots@toka=\expandafter{\pgfplotstable@before}%
					\t@pgfplots@tokb=\expandafter{\pgfplotstable@curline}%
					\edef\pgfplotstable@curline{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
				\fi
				%
				%
				\pgfplotslistpopfront\pgfplotstable@col@processed\to\pgfplotstable@entry
				\pgfplotsarrayletentry\c@pgfplotstable@colindex\of\pgfplotstabletypeset@final@cols@array=\pgfplotstable@col@processed
				\advance\c@pgfplotstable@colindex by1\relax
				% typeset the cell:
				\pgfkeysgetvalue{/pgfplots/table/typeset cell/.@cmd}\pgfplots@loc@TMPa
				\expandafter\pgfplots@loc@TMPa\pgfplotstable@entry\pgfeov
				\pgfkeysgetvalue{/pgfplots/table/@cell content}\pgfmathresult
				%
				% append this cell:
				\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
				\t@pgfplots@tokb=\expandafter{\pgfmathresult}%
				\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
				%
				\ifnum\c@pgfplotstable@colindex=\c@pgfplotstable@numcols\relax
					\c@pgfplotstable@colindex=0\relax
					% insert 'after row' here:
					\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
					\t@pgfplots@tokb=\expandafter{\pgfplotstable@after}%
					\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
					\advance\c@pgfplotstable@rowindex by1\relax
					\pgfplotstable@curline@FLUSH
				\fi
	%\message{I have now \meaning\pgfplotstable@result.}%
			\fi
		\pgfutil@repeat
		\t@pgfplots@toka=\expandafter{\pgfplotstable@curline}%
		\pgfkeysgetvalue{/pgfplots/table/end table}{\pgfplotstable@entry}%
		\t@pgfplots@tokb=\expandafter{\pgfplotstable@entry}%
		\edef\pgfplotstable@curline{\the\t@pgfplots@toka\the\t@pgfplots@tokb}%
		\ifx\pgfplotstable@curline\pgfutil@empty
		\else
			\pgfplotstable@curline@FLUSH
		\fi
		%
		\ifx\pgfplotstable@font\pgfutil@empty
		\else
			\edef\pgfplotstable@curline{\noexpand\endgroup}%
			\pgfplotstable@curline@FLUSH
		\fi
		\ifx\pgfplotstable@outfilename\pgfutil@empty
		\else
			\immediate\closeout\pgfplotstable@outfile
		\fi
	%\message{I have now \meaning\pgfplotstable@result.}%
		\def\pgfplotstablecol{\pgfplotstable@error{Sorry, you can't access the \string\pgfplotstablecol\ in this context. It is ONLY valid during the preparation routines (please check the 'display columns/<index>' style in the manual).}}%
		\def\pgfplotstablerow{\pgfplotstable@error{Sorry, you can't access the \string\pgfplotstablerow\ in this context. It is ONLY valid during the preparation routines (please check the 'every row no <index>' style).}}%
		\ifpgfplotstabletypesetresult
			\pgfplotstable@result
		\fi
	\fi
	\pgfkeysgetvalue{/pgfplots/table/write to macro}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\global\let\pgfplots@glob@TMPa=\relax
	\else
		\t@pgfplots@toka=\expandafter{\pgfplotstable@result}%
		\xdef\pgfplots@glob@TMPa{\noexpand\def\expandafter\noexpand\pgfplots@loc@TMPa{\the\t@pgfplots@toka}}%
	\fi
	\fi
	\endgroup
	\pgfplots@glob@TMPa% execute 'write to macro' if set.
}%

\newif\ifpgfplotstable@isfirstrow
\newif\ifpgfplotstable@islastrow
\newif\ifpgfplotstablecreatecol@isreallynew

\def\pgfplotstablecreatecol@opt[#1]#2#3{%
	\begingroup
	\pgfplotstableset{columns=,#1,%
		/pgf/fpu/handlers/empty number/.code 2 args={%
			\pgfmathfloatcreate{0}{0.0}{0}%
		}%
	}%
	\pgfkeysgetvalue{/pgfplots/table/columns}{\pgfplotstable@colnames}%
	\ifx\pgfplotstable@colnames\pgfutil@empty
		\pgfplotstablegetcolumnlist#3\to\pgfplotstable@colnames
	\else
		\expandafter\pgfplotslistnew\expandafter\pgfplotstable@colnames\expandafter{\pgfplotstable@colnames}%
	\fi
	\pgfplotslistnewempty\pgfplotstable@colnames@real
	\t@pgfplots@toka=\expandafter{#2}% this should handle macro names in '#2'.
	\edef\pgfplotstable@newcolname{\the\t@pgfplots@toka}%
	\global\pgfplotstablecreatecol@isreallynewtrue
	\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@colname{%
		\pgfplotstable@is@colname\pgfplotstable@colname
		\ifpgfplotstableread@foundcolnames
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@colname}\to\pgfplotstable@colnames@real
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplotstable@colname\of#2\to\pgfplotstable@colname
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@colname}\to\pgfplotstable@colnames@real
		\fi
		\ifx\pgfplotstable@colname\pgfplotstable@newcolname
			\global\pgfplotstablecreatecol@isreallynewfalse
		\fi
	}%
	\pgfplotstable@isfirstrowtrue
	\pgfplotstable@islastrowfalse
	\pgfplotslistnewempty\pgfplotstable@newcol
	%
	\let\c@pgfplotstable@numrows=\c@pgf@countd
	\let\c@pgfplotstable@rowindex=\c@pgf@countc
	\c@pgfplotstable@numrows=-1\relax
	\c@pgfplotstable@rowindex=0\relax
	\def\pgfplotstablerow{\the\c@pgfplotstable@rowindex}%
	\def\pgfplotstablerows{\the\c@pgfplotstable@numrows}%
	%
	\def\prevrow##1{\pgfplotstable@thisrow@impl{##1}{pgfplotstablecreate@prev@}{\pgfplotstable@thisrow@impl@}}%
	\def\thisrow##1{\pgfplotstable@thisrow@impl{##1}{pgfplotstablecreate@cur@}{\pgfplotstable@thisrow@impl@}}%
	\def\nextrow##1{\pgfplotstable@thisrow@impl{##1}{pgfplotstablecreate@next@}{\pgfplotstable@thisrow@impl@}}%
	\def\getprevrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@prev@##1\endcsname}%
	\def\getthisrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@cur@##1\endcsname}%
	\def\getnextrow##1##2{\expandafter\let\expandafter##2\csname pgfplotstablecreate@next@##1\endcsname}%
	%
	\pgfplots@loop@CONTINUEtrue
	% allow this here to accumulate something.
	\pgfutil@ifundefined{pgfmathaccuma}{%
		\let\pgfmathaccuma=\pgfutil@empty
	}{}%
	\pgfutil@ifundefined{pgfmathaccumb}{%
		\let\pgfmathaccumb=\pgfutil@empty
	}{}%
	\pgfutil@loop% loop over each row until there are no more rows.
	\ifpgfplots@loop@CONTINUE
		\ifnum\c@pgfplotstable@numrows=-1\relax
			\pgfplotslistfront\pgfplotstable@colnames\to\pgfplotstable@colname
			\expandafter\pgfplotslistsize\csname\string#3@\pgfplotstable@colname\endcsname\to\c@pgfplotstable@numrows
		\fi
		\pgfplotslistforeachungrouped\pgfplotstable@colnames\as\pgfplotstable@colname{%
			\expandafter\pgfplotstableresolvecolname\expandafter{\pgfplotstable@colname}\of#3\to\pgfplotstable@real@colname
			\ifpgfplotstable@isfirstrow
				\expandafter\pgfplotslistcheckempty\csname\string#3@\pgfplotstable@real@colname\endcsname
				\ifpgfplotslistempty
					% the table is completely empty. break.
					\pgfplots@loop@CONTINUEfalse
				\else
					\expandafter\let\csname pgfplotstablecreate@prev@\pgfplotstable@colname\endcsname=\pgfutil@empty
					\expandafter\pgfplotslistpopfront\csname\string#3@\pgfplotstable@real@colname\endcsname\to\pgfplotstable@entry
					\expandafter\let\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname=\pgfplotstable@entry
				\fi
			\else
				\expandafter\let\expandafter\pgfplotstable@prev\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname
				\expandafter\let\csname pgfplotstablecreate@prev@\pgfplotstable@colname\endcsname=\pgfplotstable@prev
				%
				\expandafter\let\expandafter\pgfplotstable@next\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname
				\expandafter\let\csname pgfplotstablecreate@cur@\pgfplotstable@colname\endcsname=\pgfplotstable@next
			\fi
			\expandafter\pgfplotslistcheckempty\csname\string#3@\pgfplotstable@real@colname\endcsname
			\ifpgfplotslistempty
				\expandafter\let\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname=\pgfutil@empty
				\pgfplotstable@islastrowtrue
			\else
				\expandafter\pgfplotslistpopfront\csname\string#3@\pgfplotstable@real@colname\endcsname\to\pgfplotstable@entry
				\expandafter\let\csname pgfplotstablecreate@next@\pgfplotstable@colname\endcsname=\pgfplotstable@entry
			\fi
		}%
		\ifpgfplots@loop@CONTINUE
			% Compute content:
			%
			\begingroup
			\ifpgfplotstable@isfirstrow
				\pgfkeysvalueof{/pgfplots/table/create col/assign first/.@cmd}\pgfeov
			\else
				\ifpgfplotstable@islastrow
					\pgfkeysvalueof{/pgfplots/table/create col/assign last/.@cmd}\pgfeov
				\else
					\pgfkeysvalueof{/pgfplots/table/create col/assign/.@cmd}\pgfeov
				\fi
			\fi
			\pgfkeysgetvalue{/pgfplots/table/create col/next content}{\pgfplotstable@entry}%
			\t@pgfplots@toka=\expandafter{\pgfplotstable@entry}%
			\t@pgfplots@tokb=\expandafter{\pgfmathaccuma}%
			\xdef\pgfplots@glob@TMPc{%
				\noexpand\def\noexpand\pgfplotstable@entry{\the\t@pgfplots@toka}%
				\noexpand\def\noexpand\pgfmathaccuma{\the\t@pgfplots@tokb}%
			}%
			\pgfmath@smuggleone\pgfmathaccumb
			\endgroup
			\pgfplots@glob@TMPc
			\expandafter\pgfplotslistpushback\expandafter{\pgfplotstable@entry}\to\pgfplotstable@newcol
			%
			\ifpgfplotstable@islastrow
				\pgfplots@loop@CONTINUEfalse
			\fi
		\fi
		\pgfplotstable@isfirstrowfalse
		\advance\c@pgfplotstable@rowindex by1\relax
	\pgfutil@repeat
	\global\let\pgfplots@glob@TMPc=\pgfplotstable@newcol
	\global\let\pgfplots@glob@TMPb=\pgfplotstable@newcolname
	\endgroup
	\ifpgfplotstablecreatecol@isreallynew
		\expandafter\pgfplotslistpushback\expandafter{\pgfplots@glob@TMPb}\to#3
	\fi
	\expandafter\let\csname\string#3@\pgfplots@glob@TMPb\endcsname=\pgfplots@glob@TMPc
}%


%-----------------------------------------------------------
%
% Implementation of '/pgfplots/table/create col/function graph cut y':
%
%-----------------------------------------------------------

%	create on use/cut/.style={create col/function graph cut y={7e-4}{x=Basis,ymode=log,xmode=log}{{table=regtable,y=special-L2}}},
% #1 = value of fixed line (I call it epsilon)
% #2 = options
% #3 = specification where to get the y from. It is a comma separated
% list of key-value sets, on set for every y(x) graph which shall be
% used.
% #4 = the direction in which the line does NOT vary (either 'x' or 'y')
% #5 = the direction in which the line DOES vary (either 'x' or 'y')
\def\pgfplotstable@fgc@init#1#2#3#4#5{%
	\def\pgfplotstable@fgc@xmode{0}%
	\def\pgfplotstable@fgc@ymode{0}%
	%
	\pgfkeysalso{/pgf/fpu=true}%
	%
	\pgfqkeys{/pgfplots/table/create col/function graph cut}{#2}%
	\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/table}\pgfplotstable@fgc@table
	\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/x}\pgfplotstable@fgc@x
	\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/y}\pgfplotstable@fgc@y
	\ifx\pgfplotstable@fgc@table\pgfutil@empty
		% no table here, ok.
	\else
		% ok, we need to query (or load) a table!
		\expandafter\pgfplotstable@isloadedtable\expandafter{\pgfplotstable@fgc@table}{%
			\expandafter\let\expandafter\pgfplotstable@fgc@table\pgfplotstable@fgc@table
		}{%
			\expandafter\pgfplotstableread\expandafter{\pgfplotstable@fgc@table}{\pgfplotstable@fgc@table}%
		}%
	\fi
	%
	\ifnum\csname pgfplotstable@fgc@#4mode\endcsname=1
		\pgfmathparse{ln(#1)}%
	\else
		\pgfmathparse{#1}%
	\fi
	\let\pgfplotstable@fgc@eps=\pgfmathresult
	\pgfplots@assign@list\pgfmathaccumb{#3}%
	\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/foreach}\pgfplotstable@fgc@foreach@
	\ifx\pgfplotstable@fgc@foreach@\pgfutil@empty
	\else
		\edef\pgfplotstable@fgc@foreach@process@append{x={\pgfplotstable@fgc@x},y={\pgfplotstable@fgc@y}}%
		% we have something like 
		%   foreach={\d in {1,2,3,4}}{table\d}
		% -> process it!
		%  This will modify \pgfmathaccumb
		\expandafter\pgfplotstable@fgc@foreach@process\pgfplotstable@fgc@foreach@\pgfplots@EOI
		\pgfkeyssetvalue{/pgfplots/table/create col/function graph cut/foreach}{}%
	\fi
	%
	\pgfkeysdef{/pgfplots/table/create col/assign}{%
%\message{working on next cell ...}%
		\pgfplotslistcheckempty\pgfmathaccumb
		\ifpgfplotslistempty
			\pgfkeyslet{/pgfplots/table/create col/next content}\pgfutil@empty%
		\else
			\pgfplotslistpopfront\pgfmathaccumb\to\pgfmathresult
%\message{working on next cell: \meaning\pgfmathresult ...}%
			\global\let\pgfplotstable@fgc@foreach=\pgfutil@empty
			\begingroup
				% set local keys:
				\def\pgfplots@loc@TMPa{\pgfqkeys{/pgfplots/table/create col/function graph cut}}%
				\expandafter\pgfplots@loc@TMPa\expandafter{\pgfmathresult}%
				% acquire any sources:
				\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/table}\pgfplotstable@fgc@table
				\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/x}\pgfplotstable@fgc@x
				\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/y}\pgfplotstable@fgc@y
				\pgfkeysgetvalue{/pgfplots/table/create col/function graph cut/foreach}\pgfplotstable@fgc@foreach@
				\ifx\pgfplotstable@fgc@foreach@\pgfutil@empty
					\ifx\pgfplotstable@fgc@table\pgfutil@empty
					\else
						% ok, we need to query (or load) a table!
						\expandafter\pgfplotstable@isloadedtable\expandafter{\pgfplotstable@fgc@table}{%
							\expandafter\let\expandafter\pgfplotstable@fgc@table\pgfplotstable@fgc@table
						}{%
							\expandafter\pgfplotstableread\expandafter{\pgfplotstable@fgc@table}{\pgfplotstable@fgc@table}%
						}%
					\fi
					\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplotstable@fgc@x}\of\pgfplotstable@fgc@table\to\pgfplotstable@fgc@x@col
					\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplotstable@fgc@y}\of\pgfplotstable@fgc@table\to\pgfplotstable@fgc@y@col
					%
					% search for epsilon in the y values:
					\expandafter\pgfplotstable@fgc@findintervalwitheps\expandafter{\csname pgfplotstable@fgc@#4@col\endcsname}{\csname pgfplotstable@fgc@#4mode\endcsname}%
					\ifx\pgfplotstable@fgc@second\pgfutil@empty
						\let\pgfmathresult=\pgfutil@empty
					\else
						%
						% acquire the associated x values:
						\expandafter\pgfplotstable@fgc@getassociated\expandafter{\csname pgfplotstable@fgc@#5@col\endcsname}{\csname pgfplotstable@fgc@#5mode\endcsname}%
						%
						% Interpolate:
						\pgfmathparse{
							\pgfplotstable@fgc@abscissafirst + 
							(\pgfplotstable@fgc@eps - \pgfplotstable@fgc@first) / (\pgfplotstable@fgc@second-\pgfplotstable@fgc@first) 
							* (\pgfplotstable@fgc@abscissasecond - \pgfplotstable@fgc@abscissafirst) }%
						\if\pgfplotstable@fgc@xmode1
							\pgfmathfloatexp@{\pgfmathresult}%
						\fi
						\pgflibraryfpuifactive{\pgfmathfloattosci{\pgfmathresult}}{}%
%\message{FGC: found \pgfplotstable@fgc@eps\space in no \pgfplotstable@fgc@index; \pgfplotstable@fgc@first:\pgfplotstable@fgc@second; lastwasless=\pgfplotstable@fgc@lastwasless; abscissa interval = \pgfplotstable@fgc@abscissafirst:\pgfplotstable@fgc@abscissasecond; result = \pgfmathresult}%
					\fi
				\else
					\global\let\pgfplotstable@fgc@foreach=\pgfplotstable@fgc@foreach@
					\edef\pgfmathresult{x={\pgfplotstable@fgc@x},y={\pgfplotstable@fgc@y}}%
				\fi
				%
				\pgfmath@smuggleone\pgfmathresult
			\endgroup
			\ifx\pgfplotstable@fgc@foreach\pgfutil@empty
				\pgfkeyslet{/pgfplots/table/create col/next content}\pgfmathresult%
			\else
				% we have something like 
				%   foreach={\d in {1,2,3,4}}{table\d}
				% -> process it!
				%  This will modify \pgfmathaccumb
				\let\pgfplotstable@fgc@foreach@process@append=\pgfmathresult
				\expandafter\pgfplotstable@fgc@foreach@process\pgfplotstable@fgc@foreach\pgfplots@EOI
			\fi
		\fi
	}%
}%

\def\pgfplotstable@fgc@foreach@process{%
	\pgfutil@ifnextchar\bgroup
		{\pgfplotstable@fgc@foreach@process@a}{%
		\pgfplotstable@fgc@foreach@process@error}%
}%
\def\pgfplotstable@fgc@foreach@process@a#1{%
	\pgfutil@ifnextchar\bgroup
		{\pgfplotstable@fgc@foreach@process@b{#1}}{%
		\pgfplotstable@fgc@foreach@process@error}%
}%
\def\pgfplotstable@fgc@foreach@process@error#1\pgfplots@EOI{%
	\def\pgfplots@loc@TMPa{#1}%
	\pgfplots@command@to@string\pgfplots@loc@TMPa\pgfplots@loc@TMPb
	\pgfplotsthrow{invalid argument}{\pgfplots@loc@TMPa}{Sorry, I expected two arguments for /pgfplots/table/create col/function graph cut/foreach, but I found 'foreach=\pgfplots@loc@TMPb'. Perhaps the braces are not as expected?}\pgfeov%
}%
\def\pgfplotstable@fgc@foreach@process@b#1#2#3\pgfplots@EOI{%
	\global\pgfplotslistnewempty\pgfplots@glob@TMPa
	\begingroup
	\foreach #1 {%
		\edef\pgfplots@loc@TMPa{#2}%
		\expandafter\pgfplotslistpushfrontglobal\pgfplots@loc@TMPa\to\pgfplots@glob@TMPa
	}%
	\endgroup
	\pgfplotslistforeachungrouped\pgfplots@glob@TMPa\as\pgfplots@loc@TMPa{%
		\edef\pgfplots@loc@TMPa{table={\pgfplots@loc@TMPa},\pgfplotstable@fgc@foreach@process@append}%
		\expandafter\pgfplotslistpushfront\pgfplots@loc@TMPa\to\pgfmathaccumb
	}%
}%

% #1 : the coordinate list to query
% #2 : the mode
%
% POSTCONDITION:
% 	- \pgfplotstable@fgc@abscissafirst and	\pgfplotstable@fgc@abscissasecond
% 	contain the abscissa values
%
\def\pgfplotstable@fgc@getassociated#1#2{%
	\c@pgfplotstable@counta=\pgfplotstable@fgc@index
	\pgfplotslistselect\c@pgfplotstable@counta\of#1\to\pgfplotstable@fgc@abscissasecond
	\advance\c@pgfplotstable@counta by-1
	\pgfplotslistselect\c@pgfplotstable@counta\of#1\to\pgfplotstable@fgc@abscissafirst
	\pgfmathfloatparsenumber{\pgfplotstable@fgc@abscissafirst}%
	\let\pgfplotstable@fgc@abscissafirst=\pgfmathresult
	\pgfmathfloatparsenumber{\pgfplotstable@fgc@abscissasecond}%
	\let\pgfplotstable@fgc@abscissasecond=\pgfmathresult
	\if1#2
		\pgfmathln@{\pgfplotstable@fgc@abscissafirst}%
		\let\pgfplotstable@fgc@abscissafirst=\pgfmathresult
		\pgfmathln@{\pgfplotstable@fgc@abscissasecond}%
		\let\pgfplotstable@fgc@abscissasecond=\pgfmathresult
	\fi
}%

% Search for the (first) interval in #1 containing epsilon and return
% \pgfplotstable@fgc@first and \pgfplotstable@fgc@second.
%
% #1 : the list of values.
% #2 : the mode (0 = linear, 1 = log)
%
% PRECONDITION:
% 	- \pgfplotstable@fgc@eps contains the value to search for
%
% POSTCONDITION
% 	On success,
% 	- \pgfplotstable@fgc@first and \pgfplotstable@fgc@second contain the interval.
% 	- \pgfplotstable@fgc@index contains the index of the @second coordinate.
% 	- \pgfplotstable@fgc@lastwasless is
% 	     1 if \pgfplotstable@fgc@second < eps
% 	     0 if \pgfplotstable@fgc@second >= eps
% 	If there was no such interval,
% 	\pgfplotstable@fgc@second will be empty.
\def\pgfplotstable@fgc@findintervalwitheps#1#2{%
	\global\let\pgfplotstable@fgc@first=\pgfutil@empty
	\global\let\pgfplotstable@fgc@second=\pgfutil@empty
	\global\def\pgfplotstable@fgc@lastwasless{2}%
	\global\def\pgfplotstable@fgc@break{0}%
	\global\def\pgfplotstable@fgc@index{0}%
	\pgfplotslistforeach#1\as\pgfplotstable@fgc@val{%
		\if\pgfplotstable@fgc@break0
			\pgfmathfloatparsenumber{\pgfplotstable@fgc@val}%
			\let\pgfplotstable@fgc@val=\pgfmathresult
			\ifnum#2=1
				\pgfmathln@{\pgfplotstable@fgc@val}%
				\let\pgfplotstable@fgc@val=\pgfmathresult
			\fi
			\pgfmathfloatlessthan@{\pgfplotstable@fgc@val}{\pgfplotstable@fgc@eps}%
			\ifpgfmathfloatcomparison
				\pgfplotstable@fgc@findintervalwitheps@updateresult 01
			\else
				\pgfplotstable@fgc@findintervalwitheps@updateresult 10
			\fi
		\fi
	}%
}

% #1 : the value of \pgfplotstable@fgc@lastwasless for which the loop
% shall break.
% #2 : the next value for \pgfplotstable@fgc@lastwasless
\def\pgfplotstable@fgc@findintervalwitheps@updateresult#1#2{%
	\if\pgfplotstable@fgc@lastwasless#1
		% found it !
		\global\let\pgfplotstable@fgc@second=\pgfplotstable@fgc@val
		\global\def\pgfplotstable@fgc@break{1}%
	\else
		\global\let\pgfplotstable@fgc@first=\pgfplotstable@fgc@val
		\c@pgfplotstable@counta=\pgfplotstable@fgc@index
		\advance\c@pgfplotstable@counta by1
		\xdef\pgfplotstable@fgc@index{\the\c@pgfplotstable@counta}%
	\fi
	\global\def\pgfplotstable@fgc@lastwasless{#2}%
}%



\def\pgfplotstabletranspose@[#1]#2#3{%
	%\begingroup is already in \pgfplotstabletranspose
		\def\pgfplotstable@loc@TMPa{#1}%
		\ifx\pgfplotstable@loc@TMPa\pgfutil@empty
		\else
			\pgfplotstableset{#1}%
		\fi
		%
		\pgfkeysgetvalue{/pgfplots/table/colnames from}\pgfplotstabletranspose@outcolnames
		\pgfkeysgetvalue{/pgfplots/table/input colnames to}\pgfplotstabletranspose@incolnames
		\pgfkeysgetvalue{/pgfplots/table/columns}\pgfplotstable@colnames
		%
		\ifx\pgfplotstable@colnames\pgfutil@empty
			\pgfplotstableforeachcolumn{#3}\as\pgfplots@colname{%
				\ifnum\pgfplotstablecol=0
					\let\pgfplotstable@colnames=\pgfplots@colname
				\else
					\t@pgfplots@toka=\expandafter{\pgfplots@colname}%
					\t@pgfplots@tokb=\expandafter{\pgfplotstable@colnames}%
					\edef\pgfplotstable@colnames{\the\t@pgfplots@tokb,\the\t@pgfplots@toka}%
				\fi
			}%
		\fi
		%
		% sanity checking:
		\ifx\pgfplotstabletranspose@outcolnames\pgfutil@empty
		\else
			\def\pgfplotstable@loc@TMPa{\expandafter\pgfutil@in@\expandafter{\pgfplotstabletranspose@outcolnames}}%
			\expandafter\pgfplotstable@loc@TMPa\expandafter{\pgfplotstable@colnames}%
			\ifpgfutil@in@
			\else
				% insert the 'colnames from' column into 'columns':
				\pgfplots@warning{table transposition: the 'colnames from=\pgfplotstabletranspose@outcolnames' is not part of 'columns'. Adding it.}%
				\t@pgfplots@toka=\expandafter{\pgfplotstabletranspose@outcolnames}%
				\t@pgfplots@tokb=\expandafter{\pgfplotstable@colnames}%
				\edef\pgfplotstable@colnames{\the\t@pgfplots@tokb,\the\t@pgfplots@toka}%
			\fi
		\fi
		%
		\global\pgfplotslistnewempty\pgfplotstable@colnames@glob
		% this thing counts output columns:
		\let\c@pgfplotstable@numoutcols=\c@pgf@countd
		\c@pgfplotstable@numoutcols=0
		\let\c@pgfplotstable@rowindex=\c@pgf@counta
		\c@pgfplotstable@rowindex=0
		%
		\ifx\pgfplotstabletranspose@incolnames\pgfutil@empty
		\else
			\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotstabletranspose@incolnames}\to\pgfplotstable@colnames@glob
			\def\pgfplots@loc@TMPa{\pgfplotsapplistXnewempty[to global]}%
			\expandafter\pgfplots@loc@TMPa\csname pgfp@numtable@glob@col@0\endcsname
			\advance\c@pgfplotstable@numoutcols by1
		\fi
		\def\pgfplotstable@isfirstcol{1}%
		\expandafter\pgfplotsutilforeachcommasep\expandafter{\pgfplotstable@colnames}\as\pgfplots@colname{%
			\c@pgfplotstable@rowindex=0
			\ifx\pgfplotstabletranspose@incolnames\pgfutil@empty
			\else
				\def\pgfplotstabletranspose@useit{1}%
				\ifx\pgfplotstabletranspose@outcolnames\pgfutil@empty
				\else
					\ifx\pgfplotstabletranspose@outcolnames\pgfplots@colname
						\def\pgfplotstabletranspose@useit{0}%
					\fi
				\fi
				\if1\pgfplotstabletranspose@useit
					\expandafter\pgfplotslist@assembleentry\expandafter{\pgfplots@colname}\into\t@pgfplots@tokc
					\def\pgfplotstableread@TMP{\expandafter\pgfplotsapplistXpushback\expandafter{\the\t@pgfplots@tokc}\to}%
					\expandafter\pgfplotstableread@TMP\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@rowindex\endcsname
					\advance\c@pgfplotstable@rowindex by1
				\fi
			\fi
			%
			\pgfplotstableforeachcolumnelement\pgfplots@colname\of#3\as\pgfplots@cell{%
				\if1\pgfplotstable@isfirstcol
					% prepare a new column for the output:
					\def\pgfplots@loc@TMPa{\pgfplotsapplistXnewempty[to global]}%
					\expandafter\pgfplots@loc@TMPa\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@rowindex\endcsname
					%
					\ifx\pgfplotstabletranspose@outcolnames\pgfutil@empty
						\edef\pgfplotstable@loc@TMPa{\pgfplotstablerow}%
						\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplotstable@loc@TMPa}\to\pgfplotstable@colnames@glob
					\fi
					\advance\c@pgfplotstable@numoutcols by1
				\fi
				\def\pgfplotstabletranspose@useit{1}%
				\ifx\pgfplotstabletranspose@outcolnames\pgfutil@empty
				\else
					\ifx\pgfplotstabletranspose@outcolnames\pgfplots@colname
						\pgfutil@ifundefined{pgfplotstabletranspose@@\pgfplots@cell}{%
						}{%
							\let\pgfplots@loc@TMPa=\pgfplots@cell
							\pgfplotsthrow{non unique colname}{\pgfplots@loc@TMPa}{Sorry, 'colnames from=\pgfplotstabletranspose@outcolnames' doesn't yield unique column names (`\pgfplots@cell' comes twice)}\pgfeov%
							\ifx\pgfplots@loc@TMPa\pgfutil@empty
								\edef\pgfplots@cell{row no \pgfplotstablerow}%
							\fi
						}%
						\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplots@cell}\to\pgfplotstable@colnames@glob
						\expandafter\def\csname pgfplotstabletranspose@@\pgfplots@cell\endcsname{1}%
						\def\pgfplotstabletranspose@useit{0}%
					\fi
				\fi
				\if1\pgfplotstabletranspose@useit
					% append everything to the output column with index
					% \pgfplotstablerow
					\expandafter\pgfplotslist@assembleentry\expandafter{\pgfplots@cell}\into\t@pgfplots@tokc
					\def\pgfplotstableread@TMP{\expandafter\pgfplotsapplistXpushback\expandafter{\the\t@pgfplots@tokc}\to}%
					\expandafter\pgfplotstableread@TMP\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@rowindex\endcsname
					\advance\c@pgfplotstable@rowindex by1
				\fi
			}%
			\def\pgfplotstable@isfirstcol{0}%
		}%
		%
		% flush the buffers of the applistX things:
		\c@pgfplotstable@rowindex=0
		\pgfutil@loop
		\ifnum\c@pgfplotstable@rowindex<\c@pgfplotstable@numoutcols
			\expandafter\pgfplotsapplistXflushbuffers\csname pgfp@numtable@glob@col@\the\c@pgfplotstable@rowindex\endcsname
			\advance\c@pgfplotstable@rowindex by1
		\pgfutil@repeat
		% finalize the global buffers:
		\def\pgfplotsscanlinelength{-1}%
		\edef\pgfplots@loc@TMPa{\pgfplotstablenameof{#3}_transposed}%
		\expandafter\pgfplotstable@copy@to@globalbuffers@simple\expandafter{\pgfplots@loc@TMPa}%
	\endgroup
	\pgfplotstable@copy@globalbuffers@to{#2}%
}%

\endinput
