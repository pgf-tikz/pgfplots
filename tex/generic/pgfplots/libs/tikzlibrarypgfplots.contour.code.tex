%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2010 by Nick Papior Andersen.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

\newif\ifpgfplots@contour@calc@linear
\pgfplots@contour@calc@lineartrue
\newif\ifpgfplots@contour@process
\newif\ifpgfplots@contour@first@point

\usetikzlibrary{calc}

\pgfkeys{
    /pgfplots/contour/.is family,
    /pgfplots/calculation method/.is choice,
    /pgfplots/calculation method/linear/.is if=\ifpgfplots@contour@calc@linear,
    /pgfplots/contour/levels/.store in=\pgfplots@contour@levels,
}


\let\E=\expandafter

\let\wcontour=\message

\newcount\c@pgfplots@row
\newcount\c@pgfplots@col
\newcount\c@pgfplots@contour@row@f
\newcount\c@pgfplots@contour@col@f
%\newcount\c@pgfplots@contour@edge
\newcount\c@pgfplots@contour@edge@loop
\newcount\c@pgfplots@contour@start@edge
%\newcount\c@pgfplots@contour@cur
\def\pgfplots@contour@runned@mark{x}

\def\pgfplots@contour@start{%
    %
    % Obtain the size of the data matrix
    %
    \pgfplotsmatrixsize\pgfplots@data@matrixX\to\c@pgfplots@row\c@pgfplots@col
    \advance\c@pgfplots@row by-1
    \advance\c@pgfplots@col by-1
    \xdef\c@pgfplots@row@end{\the\c@pgfplots@row}
    \xdef\c@pgfplots@col@end{\the\c@pgfplots@col}
    \advance\c@pgfplots@row by1
    \advance\c@pgfplots@col by1
    \wcontour{Starting the contour calculation with size \c@pgfplots@row@end,\c@pgfplots@col@end}
    %
    % Determine the right calculation method
    %
    \ifpgfplots@contour@calc@linear
      \wcontour{Setting the contour calculation to use the linear method.}
      \let\pgfplots@contour@calc@method=\pgfplots@contour@calc@linear
    \fi
    %
    % This matrix will hold every point and see that it has been checked.
    %
    \pgfplotsmatrixnewempty\pgfplots@contour@matrix@runned
    \pgfplotsmatrixresize\pgfplots@contour@matrix@runned\c@pgfplots@row@end\c@pgfplots@col@end
    % 
    % The list which holds the levels has been giving.
    \E\pgfplotsarraynew\E\pgfplots@contour@levels@array\E{\pgfplots@contour@levels}
    \edef\pgfplots@contour@lvls{\pgfplotsarraysizeof\pgfplots@contour@levels@array}
    \pgfplotsmatrixnewempty\pgfplots@contour@matrix@points
    % 
    % Only start with 1 rows and a 2 column matrix. Build up as in Matlab
    % and Octave etc.
    % Matrix m:
    % -------
    % m(0,0) = number of elements in first contour
    % m(0,1) = contour value of first contour
    % m(m(0,0),0) = number of elements in second contour
    % m(m(0,0),1) = contour value of second contour
    % 
    % Only in our case we will build it up reversibly.
    % This makes it easier to handle as one does not need to count and reset in the end.
    % TODO consider changing this
    % 
    \pgfplotsmatrixresize\pgfplots@contour@matrix@points{1}{2}
    %
    % In the end we resize the matrix to its real size! The resize does not change any elements.
    % Only the information regarding the size.
    %
    \let\c@pgfplots@contour@level=\c@pgf@countc
    \let\c@pgfplots@contour@cur=\c@pgf@countd
    \let\pgfplots@contour@run=\relax
    \c@pgfplots@contour@level=0
    \c@pgfplots@contour@cur=0
    \edef\c@pgfplots@contour@cur@init{\the\c@pgfplots@contour@cur}
    \pgfplotsloop{%
        \ifnum\c@pgfplots@contour@level<\pgfplots@contour@lvls\relax
          \pgfplotsloopcontinuetrue
        \else
          \pgfplotsloopcontinuefalse
        \fi
    }{%
        %
        % As we use this loop over the levels we have to reset the "runned" matrix.
        % For very large arrays it could be better so make a list in each point which states which contours it has passed
        % Currently it is very inconvenient for very large arrays.
        %
        \pgfplots@contour@reset@runned%
        \pgfplotsarrayselect{\the\c@pgfplots@contour@level}\of\pgfplots@contour@levels@array\to\pgfplots@contour@curlevel
        \wcontour{Running the array at \the\c@pgfplots@contour@level\space with value \pgfplots@contour@curlevel}
        \pgfplots@contour@calc@method%
%         % 
%         % Save the number of points in the matrix of contour levels, as in the above description.
%         % 
%         \E\xdef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,0\endcsname{\pgfplots@contour@curlevel}
%         % Calculate the number of points on the contour
%         \pgfmathsubtract{\the\c@pgfplots@contour@cur}{\c@pgfplots@contour@cur@init}
% %        \E\pgfmathsubtract\E{\pgfmathresult}{1}
%         \pgfmathint{\pgfmathresult}
%         \E\xdef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,1\endcsname{\pgfmathresult}
        \advance\c@pgfplots@contour@level by1
    }
    %
    % We now have informed pgfplots of the genuine size of the matrix which holds the contours.
    \pgfplotsmatrixresize\pgfplots@contour@matrix@points{\the\c@pgfplots@contour@cur}{2}%
}

\def\pgfplots@contour@calc@linear{%
    \wcontour{Linear contour calc now.}
    \c@pgfplots@col=-1%
    \c@pgfplots@row=0%
    \pgfplotsloop{%
        \ifnum\the\c@pgfplots@col=\c@pgfplots@col@end\relax
          \ifnum\the\c@pgfplots@row=\c@pgfplots@row@end\relax
            \pgfplotsloopcontinuefalse%
          \else
            \advance\c@pgfplots@row by1
            \c@pgfplots@col=-1
            \pgfplotsloopcontinuetrue
          \fi%
        \else%
          \pgfplotsloopcontinuetrue%
        \fi%
        \advance\c@pgfplots@col by1%
    }{%
        \wcontour{Started linear findings with (\the\c@pgfplots@row,\the\c@pgfplots@col) of (\c@pgfplots@row@end,\c@pgfplots@col@end) }%
        % 
        % Begin calculation of the contour, this is not the best implementation but it should work.
        % The wrong doing is looping through the entire matrix for each contour level. This is O(N)*lvls
        % 
        % If the matrix element has already been processed then just continue.
        % 
        % \edef\pgfplots@contour@tmpA{%
        %     \noexpand\pgfplotsmatrixvalueofelem\the\c@pgfplots@row,\the\c@pgfplots@col\noexpand\of\noexpand\pgfplots@contour@runned}
        \pgfplots@contour@first@pointtrue
        \edef\pgfplots@contour@tmpA{\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col\endcsname}
        \wcontour{Checked in main loop for \pgfplots@contour@tmpA}
        \ifx\pgfplots@contour@tmpA\pgfplots@contour@runned@mark
          \wcontour{Has been runned!}
        \else
        % I can now call \pgfplots@contour@calc@linear@
        % Use a temporary command to call after. This ensures that we do not have endless groups! This command gets defined in
        % Thus \pgfplots@contour@follow@contours will be called afterwards.
        % If it has been redefined to follow a contour it will carry on.
          \pgfplots@contour@calc@linear@{\the\c@pgfplots@row}{\the\c@pgfplots@col}{-1}
          % Remember to finish of the contour now!
          % Ex. \pgfplots@contour@follow@contours
          % Needs to be called out here due to the limitation of nested calls
          \pgfplots@contour@follow@contours%
        \fi%
        \wcontour{The col counter is \the\c@pgfplots@col}%
    }%
}%

%
% This command is called by:
% \pgfplots@contour@calc@linear@<row><col><start edge>
% The startedge parameter is used to figure out where the contour came from. A negative value would
% show the macro that it is the first point.
% 
\def\pgfplots@contour@calc@linear@#1#2#3{%
    \let\pgfplots@contour@follow@contours=\relax
    \wcontour{Calculating with data: (#1,#2) with edge: #3 at the level \pgfplots@contour@curlevel}
    \pgfplots@contour@processtrue
    % 
    % First retreive the X and Y points in the quadro point segment of the current row and column.
    %
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixX\to{\pgfplots@contour@0@X}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixX\to{\pgfplots@contour@1@X}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixX\to{\pgfplots@contour@2@X}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixX\to{\pgfplots@contour@3@X}
    %
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixY\to{\pgfplots@contour@0@Y}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixY\to{\pgfplots@contour@1@Y}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixY\to{\pgfplots@contour@2@Y}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixY\to{\pgfplots@contour@3@Y}
    % 
    % There is an error parsing the point which does not exist. We correct this by subtracting one from the row and col end
    \pgfplots@matrix@get@offset#1,#2\offset1,0\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \E\xdef\csname\string\pgfplots@contour@0@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset0,0\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \E\xdef\csname\string\pgfplots@contour@1@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset0,1\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \E\xdef\csname\string\pgfplots@contour@2@Z\endcsname{\pgfmathresult}
    \pgfplots@matrix@get@offset#1,#2\offset1,1\of\pgfplots@data@matrixZ\to{\pgfplots@contour@0@tmp}
    \pgfmathsubtract{\pgfplots@contour@get@macro0{tmp}}{\pgfplots@contour@curlevel}
    \E\xdef\csname\string\pgfplots@contour@3@Z\endcsname{\pgfmathresult}
    %
    %
    % \pgfplots@tmpa % tmp counter
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@0@Z}{\pgfplots@contour@1@Z}\to{\pgfplots@contour@0@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@1@Z}{\pgfplots@contour@2@Z}\to{\pgfplots@contour@1@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@2@Z}{\pgfplots@contour@3@Z}\to{\pgfplots@contour@2@edge}
    \pgfplots@contour@calc@edge@prod{\pgfplots@contour@3@Z}{\pgfplots@contour@0@Z}\to{\pgfplots@contour@3@edge}
    % 
    \edef\pgfplots@contour@tmpA{\noexpand\wcontour{ %
            0=\pgfplots@contour@get@macro0{edge} (\pgfplots@contour@get@macro0X,\pgfplots@contour@get@macro0Y,\pgfplots@contour@get@macro0Z)
            1=\pgfplots@contour@get@macro1{edge} (\pgfplots@contour@get@macro1X,\pgfplots@contour@get@macro1Y,\pgfplots@contour@get@macro1Z)
            2=\pgfplots@contour@get@macro2{edge} (\pgfplots@contour@get@macro2X,\pgfplots@contour@get@macro2Y,\pgfplots@contour@get@macro2Z)
            3=\pgfplots@contour@get@macro3{edge} (\pgfplots@contour@get@macro3X,\pgfplots@contour@get@macro3Y,\pgfplots@contour@get@macro3Z)
        }%
    }\pgfplots@contour@tmpA
    % 
    % Mark it as runned
    % I am not using the \pgfplotsmatrixset due to speed!
    \pgfplots@contour@mark@runned(\the\c@pgfplots@row,\the\c@pgfplots@col)%
    \wcontour{Mark runned!\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col\endcsname}
    % Check if we should at all process the current point?
    \ifnum\pgfplots@contour@get@macro0{edge}=\pgfplots@contour@get@macro1{edge}
      \ifnum\pgfplots@contour@get@macro2{edge}=\pgfplots@contour@get@macro3{edge}
        \ifnum\pgfplots@contour@get@macro1{edge}=\pgfplots@contour@get@macro2{edge}
          \ifnum\pgfplots@contour@get@macro0{edge}=-1
          % We are in the case of all edges the same and with value -1
            \wcontour{All edges are below or over the contour. INVALID}
            \pgfplots@contour@processfalse
          \fi
        \fi
      \fi
    \fi
    % This below test probably have errors when numbers are close to zero but not exactly. Maybe it should use the fpu lib?
    % it is because the Z points have data like 0.9... So the = sign is never found as ifnum only checks for integers
    \pgfplots@contour@check@zero\pgfplots@contour@get@macro0Z\to\pgfplots@contour@tmpA
    \ifnum\pgfplots@contour@tmpA=0
      \pgfplots@contour@check@zero\pgfplots@contour@get@macro1Z\to\pgfplots@contour@tmpA
      \ifnum\pgfplots@contour@tmpA=0
        \pgfplots@contour@check@zero\pgfplots@contour@get@macro2Z\to\pgfplots@contour@tmpA
        \ifnum\pgfplots@contour@tmpA=0
          \pgfplots@contour@check@zero\pgfplots@contour@get@macro3Z\to\pgfplots@contour@tmpA
          \ifnum\pgfplots@contour@tmpA=0
          % We are in the case of all edges the same and with value 0
            \wcontour{All edges are on the contour, i.e. a flat square. INVALID}
            \pgfplots@contour@processfalse
          \fi
        \fi
      \fi
    \fi
    % 
    % So now we have tested whether or not we should process the point.
    % Loop over the edges
    %
    \ifpgfplots@contour@process
      \wcontour{Valid point}%
      \c@pgfplots@contour@edge@loop=-1
      \ifnum#3<0
        \xdef\c@pgfplots@contour@edge{1}
      \else
        \pgfmathadd{#3}{1}%
        \pgfmathint{\pgfmathresult}%
        \xdef\c@pgfplots@contour@edge{\pgfmathresult}
      \fi
      % Comparing with contour.c we have :
      % \c@pgfplots@contour@edge@loop = k
      % \c@pgfplots@contour@edge      = i
      \wcontour{Just before calc loop \the\c@pgfplots@contour@edge@loop\space and \c@pgfplots@contour@edge}
      \pgfplotsloop@contour{%
          \ifnum\c@pgfplots@contour@edge=0
            \xdef\c@pgfplots@contour@edge{3}
          \else
            \pgfmathsubtract{\c@pgfplots@contour@edge}{1}%
            \pgfmathint{\pgfmathresult}%
            \xdef\c@pgfplots@contour@edge{\pgfmathresult}%
          \fi%
          \ifnum\the\c@pgfplots@contour@edge@loop>3\relax% so for 4 or above?
            \pgfplots@loopcontourfalse%
          \else
            \pgfplots@loopcontourtrue%
          \fi%          
          \advance\c@pgfplots@contour@edge@loop by1%
      }{%
          \wcontour{Run with \c@pgfplots@contour@edge\space on loop: \the\c@pgfplots@contour@edge@loop\space and found edge \pgfplots@contour@get@macro\c@pgfplots@contour@edge{edge}}%
          \ifnum\c@pgfplots@contour@edge=#3\relax
            % the contour followed from the edge so we shouldn't go back
          \else
          % 
          % We check that if the contour lies on the edge and checks if it has been runned 
          % First we extract the edge corresponding point state.
            \let\pgfplots@contour@tmpB=\relax
            \pgfplots@contour@check@zero\pgfplots@contour@get@macro\c@pgfplots@contour@edge Z\to\pgfplots@contour@tmpA
            \wcontour{Hello \pgfplots@contour@tmpA}
            \ifnum\pgfplots@contour@tmpA=0
              \pgfmathparse{\c@pgfplots@contour@edge + 1}
              \pgfmathMod{\pgfmathresult}{4}
              \pgfmathint{\pgfmathresult}
              \ifnum\pgfmathresult=0
                \pgfplots@contour@calc@edge@matrix@elem#1,#2\of\c@pgfplots@contour@edge\to\pgfplots@contour@tmpB%
                \E\edef\E\pgfplots@contour@tmpB\E{\pgfplots@contour@tmpB}
                \wcontour{HelloA \pgfplots@contour@tmpB\ifx\pgfplots@contour@tmpB\pgfplots@contour@runned@mark Has been runned for sure\else Go through\fi}
              \fi
            \fi
            \ifx\pgfplots@contour@tmpB\pgfplots@contour@runned@mark
              \wcontour{The point has ALREADY been runned!}
            \else
            % 
            % We now have to check if the current edge has a contour
              \pgfplots@contour@processfalse
              \ifnum\pgfplots@contour@get@macro\c@pgfplots@contour@edge{edge}=1
              % We are in the case of a contour on the exact point:
                \pgfplots@contour@processtrue
              \fi
              % If the point value is on the contour
              \pgfplots@contour@check@zero\pgfplots@contour@get@macro\c@pgfplots@contour@edge Z\to\pgfplots@contour@tmpC
              \ifnum\pgfplots@contour@tmpC=0 % reused down at "two cases". See where we "follow the contour" further down.
                \pgfplots@contour@processtrue
              \fi
              % the two above if statements checks whether we should process the contour, they are linked through a binary or check, in this case two ifs.
              \wcontour{We are going to process: \pgfplots@contour@tmpC \ifpgfplots@contour@process TRUE \else FALSE \fi}
              \ifpgfplots@contour@process
              % First calculate the intersection point x[i] and y[i]
                \ifnum\pgfplots@contour@tmpC=0 % The contour is located on the point
                  \edef\pgfplots@contour@tmpA{\pgfplots@contour@get@macro\c@pgfplots@contour@edge{X}}
                  \edef\pgfplots@contour@tmpB{\pgfplots@contour@get@macro\c@pgfplots@contour@edge{Y}}
                \else % The contour is located in between two points and needs to be interpolated
                  \pgfplots@contour@interp@points\c@pgfplots@contour@edge\of X\to\pgfplots@contour@tmpA
                  \pgfplots@contour@interp@points\c@pgfplots@contour@edge\of Y\to\pgfplots@contour@tmpB
                \fi
                % 
                % Here we add the found contour x and y coordinate to the matrix! And advance counter
                % 
                \pgfplots@contour@add@contour@point(\pgfplots@contour@tmpA,\pgfplots@contour@tmpB)
                % 
                \c@pgfplots@contour@row@f=#1
                \c@pgfplots@contour@col@f=#2
                % Therefore we should follow the contour in!
                % 
                % There is two cases:
                % 1. The contour passes through the edge and NOT the points. (easy case)
                % 2. The contour passes through one of the points. (hard case)
                % First we find the next starting edge state:
                \ifnum\c@pgfplots@contour@edge=0
                  \c@pgfplots@contour@start@edge=2
                \else\ifnum\c@pgfplots@contour@edge=1
                  \c@pgfplots@contour@start@edge=3
                \else\ifnum\c@pgfplots@contour@edge=2
                  \c@pgfplots@contour@start@edge=0
                \else\ifnum\c@pgfplots@contour@edge=3
                  \c@pgfplots@contour@start@edge=1
                \fi\fi\fi\fi % end next edge check
                % Then we do case 1.:
                \ifnum\pgfplots@contour@tmpC=1 % so not passing through the point
                  \ifnum\c@pgfplots@contour@edge=0
                    \advance\c@pgfplots@contour@col@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=2
                    \advance\c@pgfplots@contour@col@f by1
                  \else\ifnum\c@pgfplots@contour@edge=3
                    \advance\c@pgfplots@contour@row@f by1
                  \fi\fi\fi\fi % end edge contour check
                \else % case number 2.:
                  \ifnum\c@pgfplots@contour@edge=0
                    \advance\c@pgfplots@contour@col@f by-1
                    \advance\c@pgfplots@contour@row@f by1
                  \else\ifnum\c@pgfplots@contour@edge=1
                    \advance\c@pgfplots@contour@col@f by-1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=2
                    \advance\c@pgfplots@contour@col@f by1
                    \advance\c@pgfplots@contour@row@f by-1
                  \else\ifnum\c@pgfplots@contour@edge=3
                    \advance\c@pgfplots@contour@col@f by1
                    \advance\c@pgfplots@contour@row@f by1
                  \fi\fi\fi\fi % end edge contour check
                \fi % the end of the two cases check. The \pgfplots@contour@follow@contours will now be redefined
                % The below checks ensure that we follow a contour which actually is permitted, i.e. the boundaries of the matrix is checked against the
                % followed matrix
                \ifnum\c@pgfplots@contour@col@f=\c@pgfplots@col@end\else
                \ifnum\c@pgfplots@contour@col@f>\c@pgfplots@col@end\else
                \ifnum\c@pgfplots@contour@col@f<0\else
                \ifnum\c@pgfplots@contour@row@f=\c@pgfplots@row@end\else
                \ifnum\c@pgfplots@contour@row@f>\c@pgfplots@row@end\else
                \ifnum\c@pgfplots@contour@row@f<0\else
                % 
                % We have to check that the thing we go into has not been runned
                \edef\pgfplots@contour@tmpA{\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f\endcsname}%
                \wcontour{Before last check: \pgfplots@contour@tmpA}
                \ifx\pgfplots@contour@tmpA\pgfplots@contour@runned@mark
                  % in this case do nothing as the next site has already been runned
                \else
                  \xdef\pgfplots@contour@follow@contours{%
                      % 
                      % Example
                      % 
                      \noexpand\wcontour{Following in on contour (\the\c@pgfplots@contour@row@f,\the\c@pgfplots@contour@col@f) at edge \the\c@pgfplots@contour@start@edge}%
                      \noexpand\pgfplots@contour@calc@linear@{\the\c@pgfplots@contour@row@f}{\the\c@pgfplots@contour@col@f}{\the\c@pgfplots@contour@start@edge} % the rows and stuff needs to be expanded?
                      \noexpand\pgfplots@contour@follow@contours % this is needed as otherwise it would end the call!
                  }
                \fi
                \fi\fi\fi\fi\fi\fi % the end of the boundary check
              \fi % the end of the contour process
            \fi% the end of the current point runned check
          \fi% end of the contour edge check against the start edge #3
    }% this is the outer pgfplotsloop@contour, explains the indent
    \fi % end of \ifpgfplots@contour@process
}

%
% Calculates the edge states. There are 4 cases, where 2 of them are entwined:
%  1. The points are both above or both below the contour level. This yields > 0
%  2. The points are both equal to the contour level. This yields = 0
%  3. One is above the contour and one is below the contour. This yields < 0
%
% As we are interested in the case where we can find the contour we always only 
% consider option 2. and 3.
%
\def\pgfplots@contour@calc@edge@prod#1#2\to#3{%
    \pgfmathmultiply{\csname\string#1\endcsname}{\csname\string#2\endcsname}%
    \pgfmathparse{ifthenelse(\pgfmathresult>0,int(-1),ifthenelse(\pgfmathresult<0,int(1),int(0)))}%
    % \E\xdef\csname\string#3\endcsname{\pgfmathresult}
    % \pgfmathmultiply{\csname\string#1\endcsname}{\csname\string#2\endcsname}%
    % \pgfmathparse{%
    %     ifthenelse(
    %       \csname\string#1\endcsname>0 && \csname\string#2\endcsname>0,
    %       int(-1),
    %       ifthenelse(
    %         \csname\string#1\endcsname<0 && \csname\string#2\endcsname<0,
    %         int(0),
    %         int(1)
    %       )
    %     )
    % }%
    \wcontour{Calculating \string#1 x \string#2 and found \pgfmathresult =\csname\string#1\endcsname x\csname\string#2\endcsname}
    \E\xdef\csname\string#3\endcsname{\pgfmathresult}
}

%
% An interpolation calculator. It does so by having that the Z values already have subtracted the contour level
% so that the result gives the X or Y coordinate of the intersection on the contour.
% 
\def\pgfplots@contour@interp@points#1\of#2\to#3{%
    \ifnum#1=3
      \pgfmathparse{(\pgfplots@contour@get@macro{3}{#2} * abs(\pgfplots@contour@get@macro{0}{Z}) +
          \pgfplots@contour@get@macro{0}{#2} * abs(\pgfplots@contour@get@macro{3}{Z}) )
          / abs(\pgfplots@contour@get@macro{0}{Z} - \pgfplots@contour@get@macro{3}{Z})
      }%
    \else\ifnum#1=0
      \pgfmathparse{(\pgfplots@contour@get@macro{0}{#2} * abs(\pgfplots@contour@get@macro{1}{Z}) +
          \pgfplots@contour@get@macro{1}{#2} * abs(\pgfplots@contour@get@macro{0}{Z}) )
          / abs(\pgfplots@contour@get@macro{1}{Z} - \pgfplots@contour@get@macro{0}{Z})
      }%
    \else\ifnum#1=1
      \pgfmathparse{(\pgfplots@contour@get@macro{1}{#2} * abs(\pgfplots@contour@get@macro{2}{Z}) +
          \pgfplots@contour@get@macro{2}{#2} * abs(\pgfplots@contour@get@macro{1}{Z}) )
          / abs(\pgfplots@contour@get@macro{2}{Z} - \pgfplots@contour@get@macro{1}{Z})
      }%
    \else\ifnum#1=2
      \pgfmathparse{(\pgfplots@contour@get@macro{2}{#2} * abs(\pgfplots@contour@get@macro{3}{Z}) +
          \pgfplots@contour@get@macro{3}{#2} * abs(\pgfplots@contour@get@macro{2}{Z}) )
          / abs(\pgfplots@contour@get@macro{3}{Z} - \pgfplots@contour@get@macro{2}{Z})
      }%
    \fi\fi\fi\fi
    \xdef#3{\pgfmathresult}
}

%
% Gets the namedef macro out
%
\def\pgfplots@contour@get@macro#1#2{\csname\string\pgfplots@contour@#1@#2\endcsname}

%
% Marks the point as runned
%
\def\pgfplots@contour@mark@runned(#1,#2){%
    \begingroup
    \edef\pgfplots@contour@tmpA{%
        \noexpand\E\noexpand\xdef\noexpand\csname\noexpand\string\noexpand\pgfplots@contour@matrix@runned@#1,#2\noexpand\endcsname\noexpand{\pgfplots@contour@runned@mark}\endgroup
    }
    \wcontour{HELLO \meaning\pgfplots@contour@tmpA}
    \pgfplots@contour@tmpA
    \wcontour{HELLO}
}

%
% This macro returns in #4 the corresponding element of the runned matrix
% for the case of certain edge values. A specific edge corresponds to certain points.
%
\def\pgfplots@contour@calc@edge@matrix@elem#1,#2\of#3\to#4{%
    \def\pgfmathresult{-1}
    \ifnum#3=0
      \pgfmathsubtract{#2}{1}
      \pgfmathint{\pgfmathresult}
      \xdef#4{\noexpand\csname\string\pgfplots@contour@matrix@runned@#1,\pgfmathresult\endcsname}%
    \else
    \ifnum#3=1
      \pgfmathsubtract{#1}{1}
      \pgfmathint{\pgfmathresult}
      \xdef#4{\noexpand\csname\string\pgfplots@contour@matrix@runned@\pgfmathresult,#2\endcsname}%
    \else
    \ifnum#3=2
      \pgfmathadd{#2}{1}
      \pgfmathint{\pgfmathresult}
      \xdef#4{\noexpand\csname\string\pgfplots@contour@matrix@runned@#1,\pgfmathresult\endcsname}%
    \else
    \ifnum#3=3
      \pgfmathadd{#1}{1}
      \pgfmathint{\pgfmathresult}
      \xdef#4{\noexpand\csname\string\pgfplots@contour@matrix@runned@\pgfmathresult,#2\endcsname}%
    \fi\fi\fi\fi% the end of num tests
    \ifnum\pgfmathresult<0
      \xdef#4{\pgfplots@contour@runned@mark}%
    \fi
}

%
% Gets the macro from the matrix with an offset.
% So actually: \def#6{#5@#1+#3,#2+#4}
%
\def\pgfplots@matrix@get@offset#1,#2\offset#3,#4\of#5\to#6{%
    \pgfmathadd{#1}{#3}
    \pgfmathint{\pgfmathresult}
%    \pgfmathparse{int(#1+#3)}% I suspect the above two commands are faster.
    \edef\pgfplots@contour@tmpA{\pgfmathresult}%
    \pgfmathadd{#2}{#4}
    \pgfmathint{\pgfmathresult}
%    \pgfmathparse{int(#2+#4)}% I suspect the above two commands are faster.
    \edef\pgfplots@contour@tmpB{\pgfmathresult}%
%    \wcontour{Returning from #1, #2 to \pgfplots@contour@tmpA,\pgfplots@contour@tmpB}
    \E\xdef\csname\string#6\endcsname{\noexpand\csname\string#5@\pgfplots@contour@tmpA,\pgfplots@contour@tmpB\endcsname}%
}

%
% Resets the \pgfplots@contour@matrix@runned
%
\def\pgfplots@contour@reset@runned{%
    \c@pgfplots@col=-1\relax%
    \c@pgfplots@row=0\relax%
    \pgfplotsloop{%
%        \wcontour{Hello \the\c@pgfplots@col}
        \ifnum\the\c@pgfplots@col=\c@pgfplots@col@end\relax
          \ifnum\the\c@pgfplots@row=\c@pgfplots@row@end\relax
            \pgfplotsloopcontinuefalse%
          \else
            \advance\c@pgfplots@row by1\relax
            \c@pgfplots@col=-1\relax
            \pgfplotsloopcontinuetrue
          \fi%
        \else%
          \pgfplotsloopcontinuetrue%
        \fi%
        \advance\c@pgfplots@col by1%
    }{%
%        \wcontour{Resetting runned MATRIX with (\c@pgfplots@row@end,\c@pgfplots@col@end) on column \the\c@pgfplots@row,\the\c@pgfplots@col}%
        \pgfutil@namelet{\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col}{relax}%
%        \E\gdef\csname\string\pgfplots@contour@matrix@runned@\the\c@pgfplots@row,\the\c@pgfplots@col\endcsname{\relax}%
    }%
}

%
% This routine returns 1 if the number it receives is different than 0, return 0 if 0.
%
\def\pgfplots@contour@check@zero#1\to#2{%
    \pgfmathparse{ifthenelse(#1==0.00,int(0),int(1))}
    \edef#2{\pgfmathresult}
}


\newif\ifpgfplots@loopcontour

% A loop construct which invokes '#1' and continues the loop if the
% boolean \ifpgfplotsloopcontinue is true and stops if it is false.
%
% #1: a statement which is expected to set \ifpgfplotsloopcontinue
% #2: the loop body.
\def\pgfplotsloop@contour#1#2{%
    #1\relax
    \ifpgfplots@loopcontour
      #2\relax
      \def\pgfplotsloop@contour@{\pgfplotsloop@contour{#1}{#2}}%
      \expandafter\pgfplotsloop@contour@
    \fi
}%

% This macro updates the list of current numbers in the contour list.
% Thus one updates the number of points in the previous "list" and adds the corresponding numbers.
\def\pgfplots@contour@start@contour{
    \wcontour{We start a new contour!}
    % 
    % Save the number of points in the matrix of contour levels, as in the above description.
    % 
    \expandafter\xdef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,0\endcsname{\pgfplots@contour@curlevel}
    % Calculate the number of points on the contour
    \pgfmathsubtract{\the\c@pgfplots@contour@cur}{\c@pgfplots@contour@cur@init}
    \pgfmathint{\pgfmathresult}
    \expandafter\xdef\csname\string\pgfplots@contour@matrix@points@\c@pgfplots@contour@cur@init,1\endcsname{\pgfmathresult}
    \ifnum\pgfmathresult>1 % As a contour at least has to have 2 points! If not it results in just overwriting the previous lvl statement.
      \advance\c@pgfplots@contour@cur by1
      \xdef\c@pgfplots@contour@cur@init{\the\c@pgfplots@contour@cur}
    \fi
}
% Add point to the current contour list
\def\pgfplots@contour@add@contour@point(#1,#2){
    \ifpgfplots@contour@first@point
      \pgfplots@contour@start@contour
      \global\pgfplots@contour@first@pointfalse
    \fi
    \global\advance\c@pgfplots@contour@cur by1
    \wcontour{Contour point: adding (#1,#2), to \the\c@pgfplots@contour@cur}
    \expandafter\xdef\csname\string\pgfplots@contour@matrix@points@\the\c@pgfplots@contour@cur,0\endcsname{#1}
    \expandafter\xdef\csname\string\pgfplots@contour@matrix@points@\the\c@pgfplots@contour@cur,1\endcsname{#2}
}

\endinput
