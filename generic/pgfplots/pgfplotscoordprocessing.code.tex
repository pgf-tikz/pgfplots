%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007/2008 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% This file contains the code to process coordinates
% - coordinate input: \addplot and its variants,
% - coordinate loops,
% - single coordinate processing


% To be called inside of an axis as soon as the axis is ready and all
% point commands can be invoked.
\def\pgfplotspoint@initialisation{%
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v00\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v01\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v10\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v11\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@0v0\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@0v1\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@1v0\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@1v1\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@00v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@01v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@10v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@11v\endcsname\relax
	%
	% Installs e_x, e_y and e_z such that (0,0) is the 'south west'
	% anchor of the axis and (1,1) the 'north east'.
	% It is used inside of descriptions.
	\def\pgfplots@install@description@xyzvec{%
		\ifpgfplots@deprecated@anchors
			\pgfpointadd{\pgfplotspointxaxis}{\pgfplotspointyaxis}%
		\else
			\pgfplotspointbbdiagonal
		\fi
		\pgf@xx=\pgf@x
		\pgf@xy=0pt
		\pgf@yx=0pt
		\pgf@yy=\pgf@y
		\pgf@zx=0pt
		\pgf@zy=0pt
	}%
	\let\pgfpointxy@orig=\pgfpointxy
	\let\pgfqpointxy@orig=\pgfqpointxy
	\let\pgfpointxyz@orig=\pgfpointxyz
	\let\pgfqpointxyz@orig=\pgfqpointxyz
	%
	% A point command such that (0,0) is the 'south west' and (1,1)
	% the 'north east' point of an axis.
	\def\pgfplotspointdescriptionxy##1##2{%
		\pgf@process{%
			\pgfplots@install@description@xyzvec
			\pgfpointadd
				{\ifpgfplots@deprecated@anchors
					\pgfplotspointminminmin
				\else
					\pgfplotspointbblowerleft
				\fi}%
				{\pgfpointxy@orig{##1}{##2}}% 
				%I use the '@orig' variant here because descriptions may 
				%\let\pgfpointxy=\pgfplotspointdescriptionxy
		}%
	}%
	% the 'q' variant:
	\def\pgfplotsqpointdescriptionxy##1##2{%
		\pgf@process{%
			\pgfplots@install@description@xyzvec
			\pgfpointadd
				{\ifpgfplots@deprecated@anchors
					\pgfplotspointminminmin
				\else
					\pgfplotspointbblowerleft
				\fi}%
				{\pgfqpointxy@orig{##1}{##2}}% 
		}%
	}%
	\def\pgfplotspointunitx{\pgf@x=\pgf@xx\pgf@y=\pgf@xy}%
	\def\pgfplotspointunity{\pgf@x=\pgf@yx\pgf@y=\pgf@yy}%
	\let\pgfplotsunitxlength=\pgfplots@x@veclength
	\let\pgfplotsunitylength=\pgfplots@y@veclength
	\let\pgfplotsunitxinvlength=\pgfplots@x@inverseveclength
	\let\pgfplotsunityinvlength=\pgfplots@y@inverseveclength
	\ifpgfplots@threedim
		\def\pgfplotspointunitz{\pgf@x=\pgf@zx\pgf@y=\pgf@zy}%
		\let\pgfplotsunitzlength=\pgfplots@z@veclength
		\let\pgfplotsunitzinvlength=\pgfplots@z@inverseveclength
	\fi
	%
	% declare the '[xyz]ticklabel cs'
	\tikzdeclarecoordinatesystem{xticklabel}{\pgfplotspointticklabelcs{x}{##1}}%
	\tikzdeclarecoordinatesystem{yticklabel}{\pgfplotspointticklabelcs{y}{##1}}%
	\tikzdeclarecoordinatesystem{zticklabel}{\pgfplotspointticklabelcs{z}{##1}}%
	%
	% FIXME : this is probably expensive?
	\pgfplotsdeclareborderanchorforticklabelaxis{x}{near xticklabel}%
	\pgfplotsdeclareborderanchorforticklabelaxis{y}{near yticklabel}%
	\pgfplotsdeclareborderanchorforticklabelaxis{z}{near zticklabel}%
	%
	\pgfkeysdef{/tikz/sloped like x axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection{x}}}%
	\pgfkeysdef{/tikz/sloped like y axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection{y}}}%
	\pgfkeysdef{/tikz/sloped like z axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection{z}}}%
	%
}%

% \pgfplotspointticklabelcs{<axis>}{<coordinate>}
% or
% \pgfplotspointticklabelcs[<default shift>]{<axis>}{<coordinate>}
%
% Yields a point in the '<axis>ticklabel cs'.
%
% The 'xticklabel cs' is a coordinate system which expects either one
% or two coordinates. The first is the coordinate on the axis where
% x tick label will be placed (or would be placed). The first
% coordinate '0' means the lower aixs site and the value '1' the upper
% range. The second (optional) coordinate of 'xticklabel cs' is a
% shift in direction of the outer normal vector of the axis. The
% minimum shift is the largest' tick labels dimensions. If the second
% argument is omitted, the <default shift> will be used (0pt if this
% argument has been omitted as well).
%
% \pgfplotspointticklabelcs#1#2: 
% #1 is the axis (either x,y or z)
% #2 is the coordinate (either <relative coord> or <relative coord>,<shift>)
\def\pgfplotspointticklabelcs{\pgfutil@ifnextchar[%
	{\pgfplotspointticklabelcs@opt}%
	{\pgfplotspointticklabelcs@opt[0pt]}%
}%
\def\pgfplotspointticklabelcs@opt[#1]#2#3{%
	\pgfutil@in@{,}{#3}%
	\ifpgfutil@in@
		\edef\pgfplots@loc@TMPa{#3}%
	\else
		\edef\pgfplots@loc@TMPa{#3,#1}%
	\fi
	\def\pgfplots@loc@TMPb##1,##2\relax{%
		% invoke
		% \pgfplotsqpointoutsideofticklabelaxisrel{#2}{##1}{ticklabel dimen + ##2}:
		\begingroup
			\afterassignment\pgfplots@gobble@until@relax
			\pgf@xa=##2pt\relax
			\advance\pgf@xa by\pgfplotsvalueoflargesttickdimen{#2} %<- keep this space!
			\xdef\pgfplots@glob@TMPa{\pgf@sys@tonumber\pgf@xa}%
		\endgroup
		\def\pgfplots@loc@TMPa{\pgfplotsqpointoutsideofticklabelaxisrel{#2}{##1}}%
		\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@glob@TMPa}%
	}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\relax
}%


% Converts a dimen (with unit!) to a corresponding x, y or z
% coordinate.
% The result will be written to \pgfmathresult (without units).
%
% It is possible to use the result within the \pointxyz command(s).
%
% #1: the axis (x,y or z)
% #2: the dimen
%
% example:
% \pgfplotsconvertunittocoordinate{x}{5pt}
\def\pgfplotsconvertunittocoordinate#1#2{%
	\begingroup
	\pgf@xa=#2\relax
	\pgf@xa=\csname pgfplots@#1@inverseveclength\endcsname\pgf@xa
	\edef\pgfmathresult{\pgf@sys@tonumber\pgf@xa}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

% This is the same as using \pgfplotsconvertunittocoordinate for each
% component #1, #2 and #3. The results are directly communicated to
% \pgfplotsqpointxyz.
%
% Expects #1, #2 and #3 to be numbers with units and issues a \pgfplotsqpointxyz 
\def\pgfplotsqpointxyzabsolutesize#1#2#3{%
	\begingroup
	\pgf@xa=#1\relax
	\pgf@xa=\pgfplots@x@inverseveclength\pgf@xa
	\pgf@xb=#2\relax
	\pgf@xb=\pgfplots@y@inverseveclength\pgf@xb
	\pgf@ya=#3\relax
	\pgf@ya=\pgfplots@z@inverseveclength\pgf@ya
	\xdef\pgfplots@glob@TMPa{{\pgf@sys@tonumber\pgf@xa}{\pgf@sys@tonumber\pgf@xb}{\pgf@sys@tonumber\pgf@ya}}%
	\endgroup
	\expandafter\pgfplotsqpointxyz\pgfplots@glob@TMPa
}%

% Denotes a point in a twodimensional hyperplane. The hyperplane is
% one of the six planes of the threedimensional axis cube.
% 
% The meaning of coordinates #1 and #2 will be redefined depending on
% which surface we are currently processing. You can get the axis
% names for '#1' (a) and '#2' (b) using the macros
% \pgfplotspointonorientedsurfaceA (one of the characters x,y or z)
% and
% \pgfplotspointonorientedsurfaceB.
% The surface normal direction is
% \pgfplotspointonorientedsurfaceN.
%
% Example:
% \pgfplotspointonorientedsurfaceabsetupforxyz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
%
% ->
%  \pgfplotspointonorientedsurfaceA = x
%  \pgfplotspointonorientedsurfaceB = y
%  \pgfplotspointonorientedsurfaceN = z
%  \pgfplotspointonorientedsurfacespec = {ab0}
%  \pgfplotspointonorientedsurfacespecunordered = {vv0}
%  \pgfplotspointonorientedsurfaceab{3}{4} =\pgfqpointxyz{3}{4}{<lower z limit>}
%
% \pgfplotspointonorientedsurfaceabsetupforyxz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
% ->
%  \pgfplotspointonorientedsurfaceA = y
%  \pgfplotspointonorientedsurfaceB = x
%  \pgfplotspointonorientedsurfaceN = z
%  \pgfplotspointonorientedsurfacespec = {ba0}
%  \pgfplotspointonorientedsurfacespecunordered = {vv0}
%  \pgfplotspointonorientedsurfaceab{3}{4} =\pgfqpointxyz{4}{3}{<lower z limit>}
%
% @see \pgfplotspointonorientedsurfaceabsetupforxyz
\def\pgfplotspointonorientedsurfaceab#1#2{%
	\pgfplots@error{Internal logic error: \string\pgfplotspointonorientedsurfaceab\ used although surface has not been declared! You need to call \string\pgfplotspointonorientedsurfaceabsetupforxyz\ or its friends to do so.}%
}%

% This macro will be defined after
% \pgfplotspointonorientedsurfaceabsetupfor...
% routines. It expands to a three-character string 
% where the first character contains information about the x axis,
% the second about the y axis and the third about the z axis.
%
% The single characters can be one of
% - 'a'  - the corresponding axis is the PRIMARY direction of the
%   oriented surface.
% - 'b'  - the corresponding axis is the SECONDARY direction of the
%   oriented surface.
% - anything else - the characters provides as second argument for
%   \pgfplotspointonorientedsurfaceabsetupforsetz{}{}, for example.
%   Common choices are '0' for lower limit, '1' for upper limit and
%   '2' for other.
\def\pgfplotspointonorientedsurfacespec{}%

% Similar to \pgfplotspointonorientedsurfacespec, this macro encodes
% the currently active oriented surface.
% However, it only contains the characters 'v', '0' and '1' and '2'.
% The distinction 'v in {a,b}' is eliminated.
\def\pgfplotspointonorientedsurfacespecunordered{}%

% Initialises \pgfplotspointonorientedsurfaceab such that 'a' is the x
% axis and 'b' is the y axis and the z coordinate has been fixed with
% \pgfplotspointonorientedsurfaceabsetupforsetz{}.
%
% The Z value needs to be fixed with 
% \pgfplotspointonorientedsurfaceabsetupforsetz .
%
\def\pgfplotspointonorientedsurfaceabsetupforxyz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedZ}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyxz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedZ}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforxzy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedY}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\def\pgfplotspointonorientedsurfaceN{y}%
	\edef\pgfplotspointonorientedsurfacespec{a\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol b}%
	\edef\pgfplotspointonorientedsurfacespecunordered{v\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol v}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforzxy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedY}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{y}%
	\edef\pgfplotspointonorientedsurfacespec{b\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol a}%
	\edef\pgfplotspointonorientedsurfacespecunordered{v\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol v}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyzx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedX}{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\def\pgfplotspointonorientedsurfaceN{x}%
	\edef\pgfplotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ab}%
	\edef\pgfplotspointonorientedsurfacespecunordered{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol vv}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforzyx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedX}{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{x}%
	\edef\pgfplotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ba}%
	\edef\pgfplotspointonorientedsurfacespecunordered{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol vv}%
}%

% Fixes 'x' to #1 for use in
% \pgfplotspointonorientedsurfaceabsetupforzyx and 
% \pgfplotspointonorientedsurfaceabsetupforyzx.
%
% #1: The fixed value for 'x' (a coordinate in transformed range).
% #2: a one-character symbol describing 'x'.
% Command characters are
% 	 0 : x is the lower x-axis range.
% 	 1 : x is the upper x-axis range.
% 	 2 : other.
\def\pgfplotspointonorientedsurfaceabsetupforsetx#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedX{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsety#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedY{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsetz#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedZ{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%

% Helper methods which should be used if no Z component exists (pure
% 2d plots).
\def\pgfplotspointonorientedsurfaceabsetupforxy{%
	\def\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{0}%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforyx{%
	\def\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{0}%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
}%


% Assuming that an oriented surface has been initialised, say 'a0b',
% we have the following possible axis lines which can be drawn:
% - b=0: 'v00'
% - b=1: 'v01'
% - b=2: 'v02'
%
% To check which of them should be drawn, this macro here converts 'a'
% to 'v' and 'b' to '#1'. The remaining possible character will be
% copied as-is.
%
% The resulting three-character-string is written into '#2'.
%
% #1 : the replacement value which will be inserted instead of 'b' in
% the currently active oriented surface.
% #2 : the macro which will contain the output axis line specification
% (three-char-string).
% 
% Example:
% \pgfplotspointonorientedsurfaceabsetupforxyz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
% -> the oriented surface is 'ab0'
%  ...
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{0}\pgfplotslocretval
% -> \pgfplotslocretval = 'v00'
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{1}\pgfplotslocretval
% -> \pgfplotslocretval = 'v10'
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{2}\pgfplotslocretval
% -> \pgfplotslocretval = 'v20'
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline#1#2{%
	\expandafter\pgfplotspointonorientedsurfaceabgetcontainedaxisline@\pgfplotspointonorientedsurfacespec\relax{#1}%
	\let#2=\pgfplots@loc@TMPa
}%
% writes into \pgfplots@loc@TMPa:
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline@#1#2#3\relax#4{%
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#1}{#4}\to\pgfplots@loc@TMPa
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#2}{#4}\to\pgfplots@loc@TMPb
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#3}{#4}\to\pgfplots@loc@TMPc
	\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa\pgfplots@loc@TMPb\pgfplots@loc@TMPc}%
}%
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single#1#2\to#3{%
	\if#1a%
		\def#3{v}%
	\else
		\if#1b%
			\def#3{#2}%
		\else
			\def#3{#1}%
		\fi
	\fi
}%


% Finds the two surfaces which are adjacent to an axis line encoded as
% three-character-string.
%
% There are the following possibilities:
% #1 = 'v**' where '*' is not 'v'.
% 	-> #2 = 'vv*'  and #3 = 'v*v'
%
% #1 = '*v*'
% 	-> #2 = 'vv*'  and #3 = '*vv'
%
% #1 = '**v'
% 	-> #2 = 'v*v'  and #3 = '*vv'
\def\pgfplotsgetadjacentsurfsforaxisline#1\to#2#3{%
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotsgetadjacentsurfsforaxisline@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%
\def\pgfplotsgetadjacentsurfsforaxisline@#1#2#3\relax#4#5{%
	\if#1v%
		\def#4{vv#3}%
		\def#5{v#2v}%
	\else
		\if#2v%
			\def#4{vv#3}%
			\def#5{#1vv}%
		\else
			\def#4{v#2v}%
			\def#5{#1vv}%
		\fi
	\fi
}%

% Executes code '#2' if the axis surface denoted by the
% three-character-string '#1' is a foreground surface and code '#3' if
% the surface '#1' is a background surface.
%
% #1: a three-char-string with the keys 
% 	'v' = 'varying', 
% 	'0' = 'lower axis limit',
% 	'1' = 'upper axis limit'.
% 	The string 'v0v' means that x and z are varying in that surface
% 	and 'y' is fixed to the lower axis limit.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
\def\pgfplotsifaxissurfaceisforeground#1#2#3{%
	\pgfutil@ifundefined{pgfplots@surfviewdepth@#1}{%
		\pgfplots@error{\string\pgfplotsifaxissurfaceisforeground{#1}: undefined three-character-string '#1' provided.}%
	}{%
		\if f\csname pgfplots@surfviewdepth@#1\endcsname #2\else #3\fi
	}%
}%

% As \pgfplotsifaxissurfaceisforeground, but for axis lines.
%
% #1: a three-character string with the same keys as in
% \pgfplotsifaxissurfaceisforeground. However, there should be only
% one varying direction as we are dealing with an axis line.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
%
\def\pgfplotsifaxislineisforeground#1#2#3{%
	\pgfplotsgetadjacentsurfsforaxisline#1\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	\if f\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPb\endcsname
		#2%
	\else
		\if f\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPc\endcsname
			#2%
		\else
			#3%
		\fi
	\fi
}%
% Executes code '#2' if the axis surface denoted by the
% three-char-string '#1' is on the convex hull of the projected axis
% cube or code '#3' if that is not the case.
%
% The arguments are the same as for \pgfplotsifaxislineisforeground:
% #1: a three-character string with the same keys as in
% \pgfplotsifaxissurfaceisforeground. However, there should be only
% one varying direction as we are dealing with an axis line.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
\def\pgfplotsifaxislineisonconvexhull#1#2#3{%
	\pgfplotsgetadjacentsurfsforaxisline#1\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	% '#1' is on the convex hull if ONE of the adjacent surfs is
	% foreground and the other one is background.
	\pgfplots@loc@tmpfalse
	\if f\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPb\endcsname
		\if b\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPc\endcsname
			\pgfplots@loc@tmptrue
		\fi
	\fi
	\if b\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPb\endcsname
		\if f\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPc\endcsname
			\pgfplots@loc@tmptrue
		\fi
	\fi
	\ifpgfplots@loc@tmp #2\else #3\fi
}%

% Returns either '' (empty) or '-' (minus) for each of the two variing sides of the
% oriented surface described by #1.
%
% The output value #2 = '' means that the positive b axis points to
% the direction of the convex hull of the projected figure.
%
% The output value #2 = '-' means that the NEGATIVE b axis points to
% the direction of the convex hull of the projected figure.
%
% The output value #3 is also either '' or '-'. It refers to the
% direction of the 'n' axis of the surface which points to the convex
% hull of the projected figure.
%
% The returned values are used to decide how to align tick labels such
% that they are always outside of the convex hull of the projected
% axis.
%
% #1: three characters denoting an oriented surface.
% #2: a macro name. Will be filled either with '' (empty string) or
% '-', encoding the direction of the 'b' axis of surface #1 which
% points to the convex hull.
% #3: a macro name. It takes the same values as '#2', but it refers to
% the 'n' axis of surface #1.
\def\pgfplotsgetdirectionstoconvexhullforsurf#1#2#3{%
	\pgfplotsgetdirectionstoconvexhullforsurf@#1\relax{#2}{#3}%
}

% Executes code '#2' if the axis line with 'b=#1' on the current
% oriented surface shall be drawn.
% If that is not the case, the code '#3' will be executed.
%
% Example:
% Let's assume the current oriented surface is 'b0a'.
% Then,
%   \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn{0}{draw it!}{\relax}
% will check whether the line '00v' shall be drawn while
%   \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn{1}{draw it!}{\relax}
% will check whether the line '10v' shall be drawn.
%
% @see \pgfplotspointonorientedsurfaceabgetcontainedaxisline
%
% @ATTENTION : this command will be always true for the 2D case. (it
% will be overwritten, see \pgfplots@decide@which@figure@surfaces@are@drawn)
\def\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn#1#2#3{%
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline#1\pgfplots@loc@TMPc
	\pgfplotsgetadjacentsurfsforaxisline\pgfplots@loc@TMPc\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	\if b\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPb\endcsname
		#2%
	\else
		\if b\csname pgfplots@surfviewdepth@\pgfplots@loc@TMPc\endcsname
			#2%
		\else
			#3%
		\fi
	\fi
}%


% Checks whether the line specified by a three-character-string '#1'
% is inside of the currently set-up oriented surface.
%
% The return value is encoded as integer into the macro #2 as
% described below.
%
% #1 : a three-character string uniquely identifing an axis line.
%      Each of the three characters can be 'v', '0' or '1'.
%      The value '0' denotes the lower axis range while '1' denotes
%      the upper axis range. The character 'v' stands for 'varying'
%      and indicates the direction in which the line varies. The first
%      character contains the values for the 'x' axis, the second
%      character for the 'y' axis and the third character for the 'z'
%      axis.
%      Example:
%      	'v01' is the axis line with 'y=lower y limit' and 'z=upper z limit'
%      	'10v' is the axis line with 'x=upper x limit' and 'y=lower y limit'
%      The 'v' character indicates the varying component. There may be
%      only one 'v'.
% #2 : a macro name. It will be empty if the line is NOT on the
% 		current surface. If will be non-empty if it IS on the current
% 		surface.
% 		To be more precise, If the line IS on the current surface, '#2' will be set to
% 		the character in '#1' which belongs to the second oriented
% 		surface axis (which is called the 'b' axis).
% 		Thus, the following values for '#2' can be expected:
% 		- '' (empty) if the line is not on the surface,
% 		- 'v' if the line IS on the surface, and '#1' contains a 'v' 
% 		in direction of the surface's 'b' axis.
% 		- '0' if the line IS on the surface and '#1' contains a '0' in
% 		direction of the surface's 'b' axis,
% 		- '1' if the line IS on the surface and '#1' contains a '1' in
% 		direction of the surface's 'b' axis.
% 		No other values are possible.
%
% 		Example:
% 		\pgfplotspointonorientedsurfaceabsetupforsetz{\zmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupforyxz
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be 'v' because 'x=v' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsety{\ymin}{0}
% 		\pgfplotspointonorientedsurfaceabsetupforxzy
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be '1' because 'z=1' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsety{\ymax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupforxzy
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be empty because 'y=0' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsetx{\xmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupforyzx
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{10v}{\result}
% 		-> \result will be 'v' because 'z=v' in '{10v}
\def\pgfplotspointonorientedsurfaceabmatchaxisline#1#2{%
	\pgfplotsmatchcubeparts{#1}{\pgfplotspointonorientedsurfacespec}{#2}%
}%

% Checks whether the line or surface specified by a three-character-string '#1'
% is inside of the surface designated by the three-character-string '#2'.
%
%
% Arguments:
% #1  a cube-part (axis line or surface) encoded as three character
%     string. Can be '0v1' or 'vv0' or so (see above).
% #2  a surface, also  encoded as three character string. Maybe
%     oriented.
% #3  The return value is encoded as char into the macro #3 as
%     described in \pgfplotspointonorientedsurfaceabmatchaxisline:
%     '#3' will be EMPTY if '#1' is NOT in '#2'.
%     '#3' will be NON-EMPTY if '#1' IS in '#2'.
\def\pgfplotsmatchcubeparts#1#2#3{%
	\edef\pgfplots@loc@TMPa{#1:#2}%
	\expandafter\pgfplotspointonorientedsurfaceabmatchaxisline@\pgfplots@loc@TMPa\pgfplots@EOI
	\let#3=\pgfplots@loc@TMPa
}%

% IMPLEMENTATION: 
% The return value is 'yes, #1#2#3 is on the oriented surface #4#5#6'
% if and only if for all three character pairs, the following single
% relations hold.
% Input char   oriented surface char
%  'v' :         is either a or b or v
%  '0' :         is either 0, a, b, v or 2 (i.e. NOT 1)
%  '1' :         is either 1, a, b, v or 2 (i.e. NOT 0)
% That's all. 
%
% If the 'oriented surface char' is 'v', then we actually don't have
% an oriented surface but just a surface.
% So, 'a0b' is the same surface as 'v0v', but the first choice has
% designated orientations.
%
% @POST \pgfplots@loc@TMPa contains the return value macro.
\def\pgfplotspointonorientedsurfaceabmatchaxisline@#1#2#3:#4#5#6\pgfplots@EOI{%
	% Search for the 'b' character:
	\if#4b%
		\def\pgfplots@loc@TMPa{#1}%
	\else
		\if#5b%
			\def\pgfplots@loc@TMPa{#2}%
		\else
			\if#6b%
				\def\pgfplots@loc@TMPa{#3}%
			\else
				\def\pgfplots@loc@TMPa{v}% FALLBACK solution.
			\fi
		\fi
	\fi
	% Now, check whether we need to clear the return value (i.e.
	% return false)
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#1}{#4}%
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#2}{#5}%
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#3}{#6}%
}
\def\pgfplotspointonorientedsurfaceabmatchaxisline@single#1#2{%
	\if#1v%
		\if#2a%
		\else
			\if#2b%
			\else
				\if#2v%
				\else
					\let\pgfplots@loc@TMPa=\pgfutil@empty
				\fi
			\fi
		\fi
	\else
		\if0#1%
			\if1#2%
				\let\pgfplots@loc@TMPa=\pgfutil@empty
			\fi
		\else
			\if1#1%
				\if0#2%
					\let\pgfplots@loc@TMPa=\pgfutil@empty
				\fi
			\else
				\pgfplots@error{The character '#1' is no valid element for a three-character axis line or surface description!}%
			\fi
		\fi
	\fi
}%

% Provides a point on an arbitrary axis (identified by a
% three-character-string) which can take any value on that axis and
% which is shifted in the direction of the outer normal vector. 
%
% #1: a three-character-string denoting the desired axis
% #2: the coordinate on that axis (the coordinate for the 'v'
% direction in '#1'). It needs to be given as it would be supplied to
% an \addplot or 'axis cs' coordinate; any logs or data
% transformations will be applied.
% #3: the distance (a dimension) describing how much we should move
% away from that axis. This points to the outside normal vector of the
% axis cube.
%
% @see \pgfplotsqpointoutsideofticklabelaxis
%
% If, in addition, the boolean \ifpgfslopedattime is true, the same
% transformations which would have been applied by
% \pgftransformlineattime will be applied, that means the 'sloped'
% feature of tikz is applied.
%
% @see \pgftransformlineattime -- it is quite similar.
\def\pgfplotsqpointoutsideofaxis#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{\csname pgfplotstransformcoordinate##1\endcsname{##2}}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% A variant of \pgfplotsqpointoutsideofaxis with relative values for
% #2.
% That means  
%   '#2 = 0' === lower axis limit 
% and 
%   '#2 = 1' === upper axis limit.
\def\pgfplotsqpointoutsideofaxisrel#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{%
		\begingroup
			% compute ##1min + ##2 * (##1max - ##1min) :
			%
			\afterassignment\pgfplots@gobble@until@relax
			\pgf@xa=##2pt\relax
			\edef\pgfplots@loc@TMPa{\pgf@sys@tonumber\pgf@xa}%
			%
			\pgf@xa=\csname pgfplots@##1min\endcsname pt %
			\pgf@xb=\csname pgfplots@##1max\endcsname pt %
			\pgf@xc=\pgf@xb
			\advance\pgf@xc by-\pgf@xa
			\pgf@xc=\pgfplots@loc@TMPa\pgf@xc
			\advance\pgf@xc by\pgf@xa
			\edef\pgfmathresult{\pgf@sys@tonumber\pgf@xc}%
			\pgfmath@smuggleone\pgfmathresult
		\endgroup
	}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% A variant of \pgfplotsqpointoutsideofaxis which accepts transformed
% values for '#2' (i.e. any data transformations and logs are already
% applied).
\def\pgfplotsqpointoutsideofaxistransformed#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{\def\pgfmathresult{##2}}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% Computes the unit outer normal vector of the axis identified by a
% three-character-string '#1'.
%
% This is the same normal vector which is used inside of
% \pgfplotsqpointoutsideofaxis and its variants.
%
% The output of this command will be cached and re-used during the
% lifetime of an axis.
%
% The returned normal vector has length 1 (computed with
% \pgfpointnormalised).
\def\pgfplotspointouternormalvectorofaxis#1{%
	\expandafter\ifx\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname\relax
		\begingroup
		\edef\pgfplots@loc@TMPa{#1}%
		\expandafter\pgfplotspointouternormalvectorofaxis@\pgfplots@loc@TMPa\relax%
		% \endgroup in \pgfplotspointouternormalvectorofaxis@.
		\expandafter\xdef\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	\else
		\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname
	\fi
}%

% FIXME : this doesn't work if one of the three characters is '2' (for
% center)
\def\pgfplotspointouternormalvectorofaxis@#1#2#3\relax{%
	\if v#1%
		\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
			\pgfplotsqpointxyz{0}{##1}{##2}%
		}%
		\def\pgfplots@loc@char@for@baxis{#2}%
		\def\pgfplots@loc@char@for@naxis{#3}%
		\def\pgfplots@loc@baxis{y}%
		\def\pgfplots@loc@naxis{z}%
	\else
		\if v#2%
			\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
				\pgfplotsqpointxyz{##1}{0}{##2}%
			}%
			\def\pgfplots@loc@char@for@baxis{#1}%
			\def\pgfplots@loc@char@for@naxis{#3}%
			\def\pgfplots@loc@baxis{x}%
			\def\pgfplots@loc@naxis{z}%
		\else
			\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
				\pgfplotsqpointxyz{##1}{##2}{0}%
			}%
			\def\pgfplots@loc@char@for@baxis{#1}%
			\def\pgfplots@loc@char@for@naxis{#2}%
			\def\pgfplots@loc@baxis{x}%
			\def\pgfplots@loc@naxis{y}%
		\fi
	\fi
	\if0\pgfplots@loc@char@for@baxis%
		% this means : the '##1' direction of the surface
		% orthogonal to the 'v' vector is on the lower axis
		% limit. Since I need a vector pointing to the OUTSIDE of
		% the axis, I need sign = -1
		\def\pgfplots@loc@baxissign{-}%
	\else
		% in this case, the OUTSIDE area requires a plus sign - the b
		% axis already points to the inside.
		\def\pgfplots@loc@baxissign{+}%
	\fi
	\pgfplotsmath@ifzero{\csname pgfplots@\pgfplots@loc@baxis @veclength\endcsname}{%
		\def\pgfplots@loc@baxissign{0}%
		\def\pgfplots@loc@baxisscale{0}%
	}{%
		\edef\pgfplots@loc@baxisscale{\pgfplots@loc@baxissign\csname pgfplots@\pgfplots@loc@baxis @inverseveclength\endcsname}%
	}%
	%
	% Now the same game for the other axis:
	\if0\pgfplots@loc@char@for@naxis%
		% this means : the '##2' direction of the surface
		% orthogonal to the 'v' vector is on the lower axis
		% limit. Since I need a vector pointing to the OUTSIDE of
		% the axis, I need sign = -1
		\def\pgfplots@loc@naxissign{-}%
	\else
		% in this case, the OUTSIDE area requires a plus sign - the n
		% axis already points to the inside.
		\def\pgfplots@loc@naxissign{+}%
	\fi
	\pgfplotsmath@ifzero{\csname pgfplots@\pgfplots@loc@naxis @veclength\endcsname}{%
		\def\pgfplots@loc@naxissign{0}%
		\def\pgfplots@loc@naxisscale{0}%
	}{%
		\edef\pgfplots@loc@naxisscale{\pgfplots@loc@naxissign\csname pgfplots@\pgfplots@loc@naxis @inverseveclength\endcsname}%
	}%
	%
	% Ok, compute and normalize the vector:
	\pgf@process{%
		\pgfpointnormalised
			{\pgfplots@loc@point@orthogonal@to@v{\pgfplots@loc@baxisscale}{\pgfplots@loc@naxisscale}}%
	}%
	\endgroup
}%

% very-low-level internal routine. Never invoke it directly.
% @PRECONDITION:
% 	an \begingroup has been opened.
% @POSTCONDITION
% 	an \endgroup has been closed and \pgf@x and \pgf@y are assigned.
%
% This grouping stuff has the intention to keep the "plug" things
% local.
%
% #1#2#3 are the three characters for the line, delimited by \relax.
% #4: the argument supplied as coordinate on that axis.
% #5: the shift along the outer unit normal.
\def\pgfplotspointoutsideofaxis@#1#2#3\relax#4#5{%
	\if v#1%
		\def\pgfplots@loc@point@orthogonal@to@v{%
			\pgfplotspointoutsideofaxis@plug@trafo{x}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@TMPb=\pgfmathresult
			\ifpgfplots@threedim
				\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@TMPc=\pgfmathresult
			\else
				\def\pgfplots@loc@TMPc{0}%
			\fi
			\pgfplotsqpointxyz{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
		}%
	\else
		\if v#2%
			\def\pgfplots@loc@point@orthogonal@to@v{%
				\pgfplotspointoutsideofaxis@plug@trafo{y}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
				\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@TMPb=\pgfmathresult
				\ifpgfplots@threedim
					\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@TMPc=\pgfmathresult
				\else
					\def\pgfplots@loc@TMPc{0}%
				\fi
				\pgfplotsqpointxyz{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPc}%
			}%
		\else
			\def\pgfplots@loc@point@orthogonal@to@v{%
				\ifpgfplots@threedim
					\pgfplotspointoutsideofaxis@plug@trafo{z}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
				\else
					\def\pgfplots@loc@TMPa{0}%
				\fi
				\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@TMPb=\pgfmathresult
				\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@TMPc=\pgfmathresult
				\pgfplotsqpointxyz{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}{\pgfplots@loc@TMPa}%
			}%
		\fi
	\fi
	%
	% read dimen argument #5:
	\afterassignment\pgfplots@gobble@until@relax
	\pgf@xa=#5pt\relax
	\edef\pgfplots@loc@distalong@normal{\pgf@sys@tonumber\pgf@xa}%
	%
	%
	\pgf@process{%
		\pgfpointadd
			{\pgfplots@loc@point@orthogonal@to@v}
			{%
				\pgfqpointscale
					{\pgfplots@loc@distalong@normal}%
					{\pgfplotspointouternormalvectorofaxis{#1#2#3}}%
			}%
	}%
	\endgroup
}%

% Helper method for \pgfplotsqpointoutsideofaxis and its variants.
% #1: an axis (x,y or z)
% #2: one of '0', '1' or '2' where
% 	0 == add lower #1 axis limit,
% 	1 == add upper #1 axis limit,
% 	2 == add nothing.
% #3: the value to add.
\def\pgfplotspointoutsideofaxis@getlimit@#1#2{%
	\if#20%
		\expandafter\let\expandafter\pgfmathresult\csname pgfplots@#1min\endcsname
	\else
		\if#21%
			\expandafter\let\expandafter\pgfmathresult\csname pgfplots@#1max\endcsname
		\fi
	\fi
}%

% Installs a rotation transformation matrix such that labels or
% whatever are aligned precisely in direction of one of the two/three
% coordinate directions.
%
% #1: the coordinate direction (one of x,y or z)
%
% The code is pretty much the same as \pgftransformlineattime, except
% that the computation is considerably simpler as axis directions are
% a well known quantity.
%
% This command assumes \ifpgfallowupsidedownattime = false and
% \ifpgfresetnontranslationattime = true
\def\pgfplotstransformtoaxisdirection#1{%
	\pgftransformresetnontranslations
	%
	% compute unit length vector pointing into the direction of
	% '#1#2#3':
	\pgfqpointscale{\csname pgfplotsunit#1invlength\endcsname}{\csname pgfplotspointunit#1\endcsname}%
	%
	% do not allow upside down labels:
	\ifdim\pgf@x<0pt%   
		\pgf@x=-\pgf@x%
		\pgf@y=-\pgf@y%
	\fi%
	%
	\pgf@ya=-\pgf@y%
	% set up rotation matrix 
	%  [ cos(alpha) sin(alpha); 
	%   -sin(alpha) cos(alpha) ]
	% where cos(alpha) = n_x and sin(alpha) = n_y:
	\pgftransformcm%
	{\pgf@sys@tonumber{\pgf@x}}{\pgf@sys@tonumber{\pgf@y}}%
	{\pgf@sys@tonumber{\pgf@ya}}{\pgf@sys@tonumber{\pgf@x}}{\pgfpointorigin}%
}

% Takes Pitch '#1' and Yaw '#2' (both in degrees) and computes 
% x,y and z vectors which define the view in the direction
% defined by '#1' and '#2'.
%
% 'Pitch' means a rotation around the viewport's x axis. 'Yaw' means
% a rotation around the original coordinate system's z axis.
%
% The method works by computing 
% Az = [ cos(azimuth) -sin(azimuth) 0; ...
%     sin(azimuth) cos(azimuth) 0; ...
%     0 0 1 ];
% 
%
% Ax = [ 1 0 0; ...
%     0 cos(elevation) -sin(elevation) ;...
%     0 sin(elevation) cos(elevation) ];
%
% v= Ax * Az;
% = [ ...
% 	cosaz  -sinaz cosel  sinaz sinel; ...
% 	sinaz  cosaz cosel   -sinel cosaz; ...
% 	0	  sinel         cosel ];
%
% Then, we use the rotated XZ plane as viewport, that means 
%   xvec = v * [1 0 0]' = <first column of v>
%   zvec = v * [0 0 1]' = <third column of v>
% and we define the projection onto the twodimensional surface
% spanned by 'xvec' and 'zvec' as
%   P( q ) = [ q^T xvec,  q^T zvec ]'
% for q in R^3.
% As a consequence, we compute the three unit vectors as
%  x = P( [1 0 0] )
%  	 = [ cosaz,  sinaz sinel ]'
%  y = P( [0 1 0] )
%    = [ sinaz,  -sinel cosaz ]'
%  z = P( [0 0 1] )
%    = [ 0,  cosel]'
%
% Furthermore, the 3D view vector which points into the direction of the view
% is
%   n = v * [0 1 0 ]' = <second column of v> =  [-sinaz cosel,  cosaz cosel,  sinel]' 
% because the normal view point was the XZ plane with y as its normal
% vector.
% The 3D vector n is returned by this routine as well - it is
% necessary for some kind of z buffering (determining what is
% foreground and what is background).
%
% INPUT:
% - #1 : azimuth ("yaw")
% - #2 : elevation ("pitch")
% OUTPUT:
% - #3 : a macro which will be set to '1' if and only if 
%      the viewport is the standard XY axis (i.e. azimuth=0, elevation=90).
% - [xyz] vectors,
%   \pgfplots@[xyz]@veclength,
%   \pgfplots@[xyz]@inverseveclength
%   are set properly
%   \pgfplots@view@dir@threedim@[xyz] will contain the three components
%   of 'n'.
\def\pgfplotssetaxesfromazel#1#2#3{%
	\begingroup
	\pgfmathsin@{#1}%
	\let\sinaz=\pgfmathresult
	\pgfmathcos@{#1}%
	\let\cosaz=\pgfmathresult
	\pgfmathsin@{-#2}%
	\let\sinel=\pgfmathresult
	\pgfmathcos@{-#2}%
	\let\cosel=\pgfmathresult
	% x:
	\pgfmathmultiply@{\sinaz}{\sinel}%
	\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpoint{\cosaz pt}{\pgfmathresult pt}}%
	% y:
	\pgfmathmultiply@{-\sinel}{\cosaz}%
	\xdef\pgfplots@glob@TMPb{\noexpand\pgfqpoint{\sinaz pt}{\pgfmathresult pt}}%
	% z:
	\xdef\pgfplots@glob@TMPc{\noexpand\pgfqpoint{0pt}{\cosel pt}}%
	%
	\pgfkeysgetvalue{/pgfplots/x dir/value}\pgfplots@loc@dirvalue@x
	\pgfkeysgetvalue{/pgfplots/y dir/value}\pgfplots@loc@dirvalue@y
	\pgfkeysgetvalue{/pgfplots/z dir/value}\pgfplots@loc@dirvalue@z
	\if r\pgfplots@loc@dirvalue@x
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
		\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	\if r\pgfplots@loc@dirvalue@y
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPb}%
		\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	\if r\pgfplots@loc@dirvalue@z
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPc}%
		\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	%
	% n (3D!)
	\pgfmathmultiply@{-\sinaz}{\cosel}%
	\let\pgfmathresultNx=\pgfmathresult
	\pgfmathmultiply@{\cosaz}{\cosel}%
	\xdef\pgfplots@glob@TMPd{{\pgfmathresultNx pt}{\pgfmathresult pt}{\sinel pt}}%
	\endgroup
%\message{Setting x,y and z from {#1}{#2} to x = \meaning\pgfplots@glob@TMPa, y = \meaning\pgfplots@glob@TMPb, z = \meaning\pgfplots@glob@TMPc...n = \pgfplots@glob@TMPd.}%
	\pgfsetxvec{\pgfplots@glob@TMPa}%
	\pgfsetyvec{\pgfplots@glob@TMPb}%
	\pgfsetzvec{\pgfplots@glob@TMPc}%
	\def\pgfplots@loc@TMPa##1##2##3{%
		\def\pgfplots@view@dir@threedim@x{##1}%
		\def\pgfplots@view@dir@threedim@y{##2}%
		\def\pgfplots@view@dir@threedim@z{##3}%
	}%
	\expandafter\pgfplots@loc@TMPa\pgfplots@glob@TMPd\relax
	\def#3{0}%
\iftrue
	\pgfplots@initsizes@get@width@withoutlabels
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplots@initsizes@get@height@withoutlabels
	\edef\pgfplots@loc@TMPa{{\pgfplots@loc@TMPa}{\pgfmathresult}}%
	\expandafter\pgfplots@scaleaxes@to@BB\pgfplots@loc@TMPa
\else
	% FIXME :
	\def\pgfplots@x@veclength{200}%
	\pgfmath@basic@reciprocal@{\pgfplots@x@veclength}%
	\let\pgfplots@x@inverseveclength=\pgfmathresult
	\def\pgfplots@y@veclength{200}%
	\pgfmath@basic@reciprocal@{\pgfplots@y@veclength}%
	\let\pgfplots@y@inverseveclength=\pgfmathresult
	\def\pgfplots@z@veclength{200}%
	\pgfmath@basic@reciprocal@{\pgfplots@z@veclength}%
	\let\pgfplots@z@inverseveclength=\pgfmathresult
	\pgfsetxvec{\pgfpointscale{\pgfplots@x@veclength}{\pgfplots@glob@TMPa}}%
	\pgfsetyvec{\pgfpointscale{\pgfplots@y@veclength}{\pgfplots@glob@TMPb}}%
	\pgfsetzvec{\pgfpointscale{\pgfplots@z@veclength}{\pgfplots@glob@TMPc}}%
\fi
%\message{After scaling: 
%	x = (\the\pgf@xx,\the\pgf@xy), 
%	y = (\the\pgf@yx,\the\pgf@yy),
%	z = (\the\pgf@zx,\the\pgf@zy).}%
}%

% Takes the current PGF x,y and z unit vectors and scales them such
% that the bounding box of the final image has width #1 and height #2.
%
% The relative length of the input vectors is important for the 3D case: it
% will be scaled as-is. 
%
% PRECONDITION
% 	- the x, y and z unit vectors have been set to the proper
% 	DIRECTIONS. Their relative vector lengths are set-up properly
% 	(i.e. y is twice as large as x and half as large as z or so).
%	- \pgfplots@[xyz]@veclength and
%	  \pgfplots@[xyz]@inverseveclength
%	  are set correctly.
%	- the \ifpgfplots@threedim boolean is set.
%	- the data limits have been initialised and transformed according
%	to the data transformation.
% 
% POSTCONDITION
% 	- the unit vectors have been re-scaled such that the final plot
% 	has the desired dimensions.
% 	- the @veclength and @inverseveclength have been re-scaled as
% 	well.
\def\pgfplots@scaleaxes@to@BB#1#2{%
	\begingroup
	\pgfinterruptboundingbox
	% STEP 1: compute the bounding box for UNITS. We just need the
	% relative sizes:
	\ifpgfplots@threedim
		\pgfpathmoveto{\pgfqpointxyz000}%
		\pgfpathmoveto{\pgfqpointxyz001}%
		\pgfpathmoveto{\pgfqpointxyz010}%
		\pgfpathmoveto{\pgfqpointxyz011}%
		\pgfpathmoveto{\pgfqpointxyz100}%
		\pgfpathmoveto{\pgfqpointxyz101}%
		\pgfpathmoveto{\pgfqpointxyz110}%
		\pgfpathmoveto{\pgfqpointxyz111}%
	\else
		\pgfpathmoveto{\pgfqpointxy00}%
		\pgfpathmoveto{\pgfqpointxy01}%
		\pgfpathmoveto{\pgfqpointxy10}%
		\pgfpathmoveto{\pgfqpointxy11}%
	\fi
	% TMPa = width
	\pgf@xa=\pgf@pathmaxx
	\advance\pgf@xa by-\pgf@pathminx
	% TMPb = height
	\pgf@xb=\pgf@pathmaxy
	\advance\pgf@xb by-\pgf@pathminy
	\pgf@ya=#1\relax
	\pgf@yb=#2\relax
%\message{PGFPLOTS: the current unit vectors result in a UNIT BB of (\the\pgf@xa,\the\pgf@xb). Scaling it to (\the\pgf@ya,\the\pgf@yb)...}%
	% STEP 2: compute the scales for x and y such 
	% that the UNIT-BB will have size #1,#2:
	\pgfplotsutil@edef@invoke\pgfmathdivide@{%
		{\pgf@sys@tonumber\pgf@ya}%
		{\pgf@sys@tonumber\pgf@xa}%
	}%
	% TMPa = scalex
	\global\let\pgfplots@glob@TMPa=\pgfmathresult
	\pgfplotsutil@edef@invoke\pgfmathdivide@{%
		{\pgf@sys@tonumber\pgf@yb}%
		{\pgf@sys@tonumber\pgf@xb}%
	}%
	% TMPb = scaley
	\global\let\pgfplots@glob@TMPb=\pgfmathresult
	\pgfusepath{discard}%
	\endpgfinterruptboundingbox
	\endgroup
%\message{got scalex = \pgfplots@glob@TMPa\space and scaley = \pgfplots@glob@TMPb.}%
	\pgfmathsubtract@{\pgfplots@xmax}{\pgfplots@xmin}%
	\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
%\message{and 1/(xmax-xmin) = 1/(\pgfplots@xmax-\pgfplots@xmin) = \pgfmathresult.}%
	\pgf@xx=\pgfplots@glob@TMPa\pgf@xx
	\pgf@xy=\pgfplots@glob@TMPb\pgf@xy
	\pgf@xx=\pgfmathresult\pgf@xx
	\pgf@xy=\pgfmathresult\pgf@xy
	%
	\pgfmathsubtract@{\pgfplots@ymax}{\pgfplots@ymin}%
	\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
%\message{and 1/(ymay-ymin) = 1/(\pgfplots@ymax-\pgfplots@ymin) = \pgfmathresult.}%
	\pgf@yx=\pgfplots@glob@TMPa\pgf@yx
	\pgf@yy=\pgfplots@glob@TMPb\pgf@yy
	\pgf@yx=\pgfmathresult\pgf@yx
	\pgf@yy=\pgfmathresult\pgf@yy
	%
	\ifpgfplots@threedim
		\pgfmathsubtract@{\pgfplots@zmax}{\pgfplots@zmin}%
		\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
%\message{and 1/(zmaz-zmin) = 1/(\pgfplots@zmax-\pgfplots@zmin) = \pgfmathresult.}%
		\pgf@zx=\pgfplots@glob@TMPa\pgf@zx
		\pgf@zy=\pgfplots@glob@TMPb\pgf@zy
		\pgf@zx=\pgfmathresult\pgf@zx
		\pgf@zy=\pgfmathresult\pgf@zy
	\fi
	\pgfplots@computeunitvectorlengths
}%

\def\pgfplots@computeunitvectorlengths{%
	\pgfplotsutil@edef@invoke\pgfmathveclen@{%
		{\pgf@sys@tonumber\pgf@xx}%
		{\pgf@sys@tonumber\pgf@xy}%
	}%
	\let\pgfplots@x@veclength=\pgfmathresult
	\pgfplotsmath@ifzero{\pgfplots@x@veclength}{%
		\def\pgfmathresult{infty}%
	}{%
		\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
	}%
	\let\pgfplots@x@inverseveclength=\pgfmathresult
	%
	\pgfplotsutil@edef@invoke\pgfmathveclen@{%
		{\pgf@sys@tonumber\pgf@yx}%
		{\pgf@sys@tonumber\pgf@yy}%
	}%
	\let\pgfplots@y@veclength=\pgfmathresult
	\pgfplotsmath@ifzero{\pgfplots@y@veclength}{%
		\def\pgfmathresult{infty}%
	}{%
		\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
	}%
	\let\pgfplots@y@inverseveclength=\pgfmathresult
	%
	\ifpgfplots@threedim
		\pgfplotsutil@edef@invoke\pgfmathveclen@{%
			{\pgf@sys@tonumber\pgf@zx}%
			{\pgf@sys@tonumber\pgf@zy}%
		}%
		\let\pgfplots@z@veclength=\pgfmathresult
		\pgfplotsmath@ifzero{\pgfplots@z@veclength}{%
			\def\pgfmathresult{infty}%
		}{%
			\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
		}%
		\let\pgfplots@z@inverseveclength=\pgfmathresult
	\fi
}%


% Internal stream methods.
%
% Please overwrite 
% - \pgfplots@coord@stream@start@,
% - \pgfplots@coord@stream@end@ and 
% - \pgfplots@coord@stream@coord@
% if you implement streams.
%
% REMARK:
% 	- the stream methods automatically collect first and last
% 	coordinates.
% 	- I have experimented with global \addplot accumulation to reduce
% 	copy operations. That experiment was not successfull (it was not
% 	faster :-(  ). However, the streaming methods still assign their
% 	things globally...
\newif\ifpgfplots@coord@stream@isfirst
\def\pgfplots@coord@stream@start{%
	\global\pgfplots@coord@stream@isfirsttrue
	\global\let\pgfplots@currentplot@firstcoord@x=\pgfutil@empty
	\global\let\pgfplots@currentplot@firstcoord@y=\pgfutil@empty
	\global\let\pgfplots@currentplot@firstcoord@z=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@x=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@y=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@z=\pgfutil@empty
	\let\pgfplots@current@point@x=\pgfutil@empty
	\let\pgfplots@current@point@y=\pgfutil@empty
	\let\pgfplots@current@point@z=\pgfutil@empty
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\let\pgfplots@current@point@x@error=\pgfutil@empty
	\let\pgfplots@current@point@y@error=\pgfutil@empty
	\let\pgfplots@current@point@z@error=\pgfutil@empty
	\pgfplots@coord@stream@start@}%
\def\pgfplots@coord@stream@end{\pgfplots@coord@stream@end@}

% Will be invoked for every point coordinate.
%
% It invokes \pgfplots@coord@stream@coord@.
%
% Arguments:
% \pgfplots@current@point@[xyz]
% \pgfplots@current@point@[xyz]@error (if in argument list)
% \pgfplots@current@point@meta
\def\pgfplots@coord@stream@coord{%
	\pgfplots@coord@stream@coord@%
	% FIXME : needs to be updated for 3D
	% FIXME : reduce \if's
	\ifx\pgfplots@current@point@x\pgfutil@empty
	\else
		\ifx\pgfplots@current@point@y\pgfutil@empty
		\else
			\ifpgfplots@coord@stream@isfirst
				\global\let\pgfplots@currentplot@firstcoord@x=\pgfplots@current@point@x
				\global\let\pgfplots@currentplot@firstcoord@y=\pgfplots@current@point@y
				\global\pgfplots@coord@stream@isfirstfalse
			\fi
			\global\let\pgfplots@currentplot@lastcoord@x=\pgfplots@current@point@x
			\global\let\pgfplots@currentplot@lastcoord@y=\pgfplots@current@point@y
		\fi
	\fi
}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Scanline management. The idea is to allow a simple syntax
% to provide matrix input - by means of scanlines.
%
% An empty line in 'addplot coordinates {}' indicates the end of a
% scan line. Similarly, an empty line in 'addplot file' or 'table'
% also indicates the end of a scan line.
%
% The following methods allow to update the scanline computation.
%
% Usage:
%
% \pgfplotsscanlinelengthinitzero
%
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinecomplete
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinecomplete
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinelengthincrease
% \pgfplotsscanlinecomplete
%
% \pgfplotsscanlinelengthcleanup
%
% Now, \pgfplotsscanlinelength expands to either 
% a) a negative number in which case there is no 
%  unique scanline length,
% b) the scanline length.
\def\pgfplotsscanlinelengthinitzero{%
	\c@pgfplots@scanlineindex=0
	\def\pgfplots@scanlinelength{-1}%
}
\def\pgfplotsscanlinelengthincrease{%
	\advance\c@pgfplots@scanlineindex by1
}
\def\pgfplotsscanlinecomplete{%
	\ifnum\pgfplots@scanlinelength>0
		\ifnum\c@pgfplots@scanlineindex=0
			% 
			% \pgfplotsscanlinecomplete
			% \pgfplotsscanlinecomplete
			% \pgfplotsscanlinecomplete
			% should have the same effect as a single statement. Do
			% nothing here.
		\else
			\ifnum\pgfplots@scanlinelength=\c@pgfplots@scanlineindex\relax
			\else
%\message{Found inconsistent scan line length: \pgfplots@scanlinelength\space vs. \the\c@pgfplots@scanlineindex\space near line \pgfplotstablelineno.}%
				% special marker which means 'inconsistent scan line length found'
				\def\pgfplots@scanlinelength{-2}%
			\fi
		\fi
	\else
		\ifnum\pgfplots@scanlinelength=-2
		\else
			\edef\pgfplots@scanlinelength{\the\c@pgfplots@scanlineindex}%
		\fi
	\fi
	\c@pgfplots@scanlineindex=0
}
\def\pgfplotsscanlinelengthcleanup{%
	\ifnum\c@pgfplots@scanlineindex=0
		% I assume the last scan line is already complete.
	\else
		\pgfplotsscanlinecomplete
	\fi
	\let\pgfplotsscanlinelength=\pgfplots@scanlinelength
}
\def\pgfplotsscanlinedisablechanges{%
	\let\pgfplotsscanlinecomplete=\relax
	\let\pgfplotsscanlinelengthincreas=\relax
	\let\pgfplotsscanlinelengthcleanup=\relax
	\let\pgfplotsscanlinelengthinitzero=\relax
}%

% Initialises 
% \pgfplots@coord@stream@start
% \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
% such that a following coordinate stream is processed properly. The
% following coordinate stream may come from different input methods.
%
% This coordinate stream is the first time a coordinate will be
% reported and processed by pgfplots. The task of this first pass is
% to
% - compute and update any axis limits,
% - collect and prepare ranges for color data,
% - handle stacked plots and error bars,
% - store the complete state of the plot's preprocessing in an
%   internal datastructure for later completion.
%
% Any \addplot command should issue \pgfplots@PREPARE@COORD@STREAM
% eventually.
%
% Arguments:
% #1:  any trailing path commands after the 'plot' command as such,
%      for example \addplot plot coordinates {...} -- (0,0);
%      would yield #1 =' -- (0,0)'
%
% PRECONDITION:
% 	- needs to be called inside of \addplot.
% 	- \pgfplots@addplot@survey@@optionlist contains the <options>
% 	provided to \addplot (all of them, including automatically
% 	determined ones)
%
% REMARK:
% 	The following code is permissable:
% 		\pgfplots@PREPARE@COORD@STREAM{...}
% 		\pgfplots@coord@stream@start
% 		...
% 		\pgfplots@coord@stream@coord
% 		..
%		\pgfplots@coord@stream@coord
%		..
% 		\pgfplots@coord@stream@end
% 	-> All need to be the SAME LEVEL OF SCOPING! The '@coord' commands
% 	may not be scoped deeper than 'begin' and 'end'!
% 	- I had a version which allowed that. it was actually slower!
% 	- For now, the following things are global / local:
% 		- point coordinate list: local
% 		- meta data limits: global,
% 		- recorded error bar commands: local,
% 		- what about stacked plot stuff: appears to be a combination
% 		of local/global.
% 		- all that will be serialized and written into
% 		\pgfplots@stored@plotlist in \pgfplots@coord@stream@end.
% 	This list is global, so, if I am not mistaken, the scoping
% 	level of the complete stream operation from setup to @end can
% 	be as deep as necessary - as long as all operations have the
% 	same level of scoping.
% 	FIXME : that's not completely clear. VERIFY! the
% 	\pgfplots@end@plot command issues an \endgroup. Is that ok?
%
\long\def\pgfplots@PREPARE@COORD@STREAM#1{%
	\ifpgfplots@curplot@threedim
		\global\pgfplots@threedimtrue
	\fi
	%
	\begingroup
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\let\E=\noexpand
	% 
	% Setup Just-In-Time-Macro Compilation:
	% I compile a set of macros which is highly optimized for this
	% particular plot.
	%
	% 1.\pgfplots@update@limits@for@one@point
	% Updates the current x and y limits for point (#1,#2).
	%
	% To eliminate all those case distinctions, it is created with
	% 'edef' and a lot of '\noexpand' calls here:
	%
	%
	% The point coordinates may be given in floating point format, see
	% below.
	%
	% Please note that if user specified limits are given, automatic
	% limits are only applied to points which fall into the user specified
	% clipping region.
	%
	% PRECONDITIONS:
	% - the input coordinates have been parsed correctly (floating point
	%   format for linear axis, log applied for logarithmic ones)
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	\xdef\pgfplots@update@limits@for@one@point{%
%\E\tracingmacros=2\E\tracingcommands=2
%\E\pgfplots@message{Updating limits for (\E\pgfplots@current@point@x,\E\pgfplots@current@point@y) ...}%
		%
		% VIM SEARCH PATTERN: 
		%   [^E]\zs\\\ze[^E]
		% -> this finds '\' which is neither '\E' nor is it prefixed
		%  by 'E'.
		%
		%
		%
		\E\pgfplots@update@limits@for@one@point@ISCLIPPEDfalse
		% check whether we need to clip limits:
		\ifpgfplots@clip@limits
			\ifpgfplots@autocompute@xmin
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@x}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@current@point@x}{\E\pgfplots@xmin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
			\else
				\ifpgfplots@xislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@y}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@current@point@y}{\E\pgfplots@ymin}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
			\else
				\ifpgfplots@yislinear
					\E\pgfmathfloatlessthan@{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\else
					\E\pgfplotsmathlessthan{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\ifpgfmathfloatcomparison
						\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
					\E\fi
				\fi
			\fi
			\ifpgfplots@curplot@threedim
			\else
				\ifpgfplots@autocompute@zmin
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{\E\pgfplots@current@point@z}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{\E\pgfplots@current@point@z}{\E\pgfplots@zmin}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
				\else
					\ifpgfplots@zislinear
						\E\pgfmathfloatlessthan@{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\else
						\E\pgfplotsmathlessthan{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\ifpgfmathfloatcomparison
							\E\pgfplots@update@limits@for@one@point@ISCLIPPEDtrue
						\E\fi
					\fi
				\fi
			\fi
		\fi
		%
		%
		%
		% Update limits:
		\E\ifpgfplots@update@limits@for@one@point@ISCLIPPED
		\E\else
			\ifpgfplots@autocompute@xmin
				\ifpgfplots@xislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@xmin}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@xmin}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@xmax
				\ifpgfplots@xislinear
					\E\pgfplotsmathfloatmax{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@xmax}{\E\pgfplots@current@point@x}%
					\E\global\E\let\E\pgfplots@xmax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymin
				\ifpgfplots@yislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@ymin}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\else
					\E\pgfplotsmathmin{\E\pgfplots@ymin}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymin=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@autocompute@ymax
				\ifpgfplots@yislinear
					\E\pgfplotsmathfloatmax{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\else
					\E\pgfplotsmathmax{\E\pgfplots@ymax}{\E\pgfplots@current@point@y}%
					\E\global\E\let\E\pgfplots@ymax=\E\pgfmathresult
				\fi
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@autocompute@zmin
					\ifpgfplots@zislinear
						\E\pgfplotsmathfloatmin{\E\pgfplots@zmin}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\else
						\E\pgfplotsmathmin{\E\pgfplots@zmin}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmin=\E\pgfmathresult
					\fi
				\fi
				\ifpgfplots@autocompute@zmax
					\ifpgfplots@zislinear
						\E\pgfplotsmathfloatmax{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\else
						\E\pgfplotsmathmax{\E\pgfplots@zmax}{\E\pgfplots@current@point@z}%
						\E\global\E\let\E\pgfplots@zmax=\E\pgfmathresult
					\fi
				\fi
			\fi
		\E\fi
		%
		% Compute data range:
		\ifpgfplots@autocompute@all@limits
			% the data range will be acquired simply from the axis
			% range, see below!
		\else
			% Attention: it is only done for linear axis!
			\ifpgfplots@xislinear
				\E\pgfplotsmathfloatmin{\E\pgfplots@data@xmin}{\E\pgfplots@current@point@x}%
				\E\global\E\let\E\pgfplots@data@xmin=\E\pgfmathresult
				\E\pgfplotsmathfloatmax{\E\pgfplots@data@xmax}{\E\pgfplots@current@point@x}%
				\E\global\E\let\E\pgfplots@data@xmax=\E\pgfmathresult
			\fi
			\ifpgfplots@yislinear
				\E\pgfplotsmathfloatmin{\E\pgfplots@data@ymin}{\E\pgfplots@current@point@y}%
				\E\global\E\let\E\pgfplots@data@ymin=\E\pgfmathresult
				\E\pgfplotsmathfloatmax{\E\pgfplots@data@ymax}{\E\pgfplots@current@point@y}%
				\E\global\E\let\E\pgfplots@data@ymax=\E\pgfmathresult
			\fi
			\ifpgfplots@curplot@threedim
				\ifpgfplots@zislinear
					\E\pgfplotsmathfloatmin{\E\pgfplots@data@zmin}{\E\pgfplots@current@point@z}%
					\E\global\E\let\E\pgfplots@data@zmin=\E\pgfmathresult
					\E\pgfplotsmathfloatmax{\E\pgfplots@data@zmax}{\E\pgfplots@current@point@z}%
					\E\global\E\let\E\pgfplots@data@zmax=\E\pgfmathresult
				\fi
			\fi
		\fi
%\E\pgfplots@message{Updated limits: (\E\pgfplots@xmin,\E\pgfplots@ymin) rectangle  (\E\pgfplots@xmax,\E\pgfplots@ymax).}%
%\E\tracingmacros=0\E\tracingcommands=0
	}%
%\message{Assembled update-limits macro to {\meaning\pgfplots@update@limits@for@one@point}}%
	\ifpgfplots@bb@isactive
	\else
		% we are inside of 
		% \pgfplotsinterruptdatabb 
		% ..
		% \endpgfinterruptboundingbox
		% -> don't change data limits!
		\global\let\pgfplots@update@limits@for@one@point=\relax
	\fi
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%
	% This here is the MAIN code of \pgfplots@process@one@point .
	% It is inserted below into the right, into one of two prepared
	% places.
	\def\pgfplots@loc@TMPa{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@datascaletrafo@initialised
				% apply data transformation directly.
				\ifpgfplots@apply@datatrafo@x
					\E\pgfplots@datascaletrafo@x\E\pgfplots@current@point@x
					\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
				\fi
				\ifpgfplots@apply@datatrafo@y
					\E\pgfplots@datascaletrafo@y\E\pgfplots@current@point@y
					\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
				\fi
				\ifpgfplots@curplot@threedim
					\ifpgfplots@apply@datatrafo@z
						\E\pgfplots@datascaletrafo@z\E\pgfplots@current@point@z
						\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
					\fi
				\fi
			\fi
		\fi
		% All following routines (limit updating/stacking/error
		% bars) will use float numerics if necessary (controlled
		% by ifs).
		\ifpgfplots@stackedmode
			\E\pgfplots@stacked@preparepoint@inmacro%
			\ifpgfplots@datascaletrafo@initialised% is also true if there is no scale trafo.
				\E\pgfplots@stacked@finishpoint
			\else
				% the finishpoint routine will be invoked at
				% \endaxis.
			\fi
		\fi
		%
		% Prepare \pgfplots@current@point@meta (see the preparation
		% routine above):
		\E\pgfplots@set@perpointmeta
		%
		% update also axis / data limits:
		% Arguments: \pgfplots@current@point@[xy]
		\E\pgfplots@update@limits@for@one@point
		\ifpgfplots@errorbars@enabled
			% This thing gets the 'current@point@...' context,
			% that means 
			% \pgfplots@current@point@[xy]
			% \pgfplots@current@point@[xy]@error
			% \pgfplots@current@point@[xy]@unfiltered
			\E\pgfplots@PREPARE@errorbar@process@x%
			\E\pgfplots@PREPARE@errorbar@process@y%
			\E\pgfplots@PREPARE@errorbar@process@z%
		\fi
		%
		% Store normalized point for list:
		% We need
		% xi,yi,zi,mi;
		% where zi and mi may be empty. mi is the per-point meta
		% information. It is used for per-coordinate marker
		% modifications (like colormaps for scatter plots).
		\E\edef\E\pgfplots@loc@TMPa{\E\pgfplots@current@point@x,\E\pgfplots@current@point@y,\E\pgfplots@current@point@z,\E\pgfplots@current@point@meta;}%
		\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfplots@loc@TMPa}%
		%
		\ifpgfplots@collect@firstplot@astick
			\ifnum\pgfplots@numplots=0
				\E\ifx\E\pgfplots@firstplot@coords@x\E\pgfutil@empty
					\E\t@pgfplots@tokc={}%
				\E\else
					\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@x,}%
				\E\fi
				\E\xdef\E\pgfplots@firstplot@coords@x{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@x}%
				\E\ifx\E\pgfplots@firstplot@coords@y\E\pgfutil@empty
					\E\t@pgfplots@tokc={}%
				\E\else
					\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@y,}%
				\E\fi
				\E\xdef\E\pgfplots@firstplot@coords@y{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@y}%
				%
				\ifpgfplots@curplot@threedim
					\E\ifx\E\pgfplots@firstplot@coords@z\E\pgfutil@empty
						\E\t@pgfplots@tokc={}%
					\E\else
						\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@z,}%
					\E\fi
					\E\xdef\E\pgfplots@firstplot@coords@z{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@z}%
				\fi
			\fi
		\fi
	}%
	% The following code assembles the command which is executed for
	% each coordinate.
	%
	% To eliminate all those case distinctions, it is created with
	% 'edef' and a lot of '\noexpand' calls here:
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	% \pgfplots@current@point@[xyz]@error (if in argument list)
	\xdef\pgfplots@process@one@point{%
		% These things are necessary for error bars:
		\E\let\E\pgfplots@current@point@x@unfiltered=\E\pgfplots@current@point@x
		\E\let\E\pgfplots@current@point@y@unfiltered=\E\pgfplots@current@point@y
		\ifpgfplots@curplot@threedim
		\E\let\E\pgfplots@current@point@z@unfiltered=\E\pgfplots@current@point@z
		\fi
		%
		\E\pgfplots@prepare@xcoord{\E\pgfplots@current@point@x}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{x}%
		\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
		%
		\E\pgfplots@prepare@ycoord{\E\pgfplots@current@point@y}%
		\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{y}%
		\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
		%
		\ifpgfplots@xislinear
			\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@x}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2 % this clears nan, inf and -inf points.
					\E\let\E\pgfplots@current@point@x=\E\pgfutil@empty
				\E\else
					\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@yislinear
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
			\E\else
				\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@y}%
				\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
				\E\ifnum\E\c@pgf@counta>2
					\E\let\E\pgfplots@current@point@y=\E\pgfutil@empty
				\E\else
					\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
				\E\fi
			\E\fi
		\fi
		%
		\ifpgfplots@curplot@threedim
			\E\pgfplots@prepare@zcoord{\E\pgfplots@current@point@z}%
			\E\expandafter\E\pgfplots@invoke@filter\E\expandafter{\E\pgfmathresult}{z}%
			\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
			%
			\ifpgfplots@zislinear
				\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
				\E\else
					\E\pgfmathfloatparsenumber{\E\pgfplots@current@point@z}%
					\E\expandafter\E\pgfmathfloat@decompose@F\E\pgfmathresult\E\relax\E\c@pgf@counta
					\E\ifnum\E\c@pgf@counta>2
						\E\let\E\pgfplots@current@point@z=\E\pgfutil@empty
					\E\else
						\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
					\E\fi
				\E\fi
			\fi
		\fi
		%
		\E\ifx\E\pgfplots@current@point@x\E\pgfutil@empty
			\ifpgfplots@warn@for@filter@discards
				\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi) has been dropped because of the x-coordinate filter.}%
			\fi
		\E\else
			\E\ifx\E\pgfplots@current@point@y\E\pgfutil@empty
				\ifpgfplots@warn@for@filter@discards
					\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi) has been dropped because of the y-coordinate filter.}%
				\fi
			\E\else
				\ifpgfplots@curplot@threedim
					\E\ifx\E\pgfplots@current@point@z\E\pgfutil@empty
						\ifpgfplots@warn@for@filter@discards
							\E\pgfplots@message{NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered,\E\pgfplots@current@point@z@unfiltered) has been dropped because of the z-coordinate filter.}%
						\fi
					\E\else
						% insert the main 3d code here:
						\pgfplots@loc@TMPa
					\E\fi
				\else
					% insert the main 2d code here:
					\pgfplots@loc@TMPa
				\fi
			\E\fi
		\E\fi
		%
		% increase \pgfplots@current@point@coordindex:
		\E\advance\E\c@pgfplots@coordindex by1
	}%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
%\message{Prepared macro \string\pgfplots@update@limits@for@one@point: {\meaning\pgfplots@update@limits@for@one@point}}%
%\message{Prepared macro \string\pgfplots@process@one@point: {\meaning\pgfplots@process@one@point}}%
	% 
	\let\pgfplots@coord@stream@start@=\pgfplots@PREPARE@COORD@STREAM@start@
	\let\pgfplots@coord@stream@coord@=\pgfplots@process@one@point
	\def\pgfplots@coord@stream@end@{\pgfplots@PREPARE@COORD@STREAM@end@{#1}}%
}%

% The \pgfplots@coord@stream@start@ routine used inside of
% \pgfplots@PREPARE@COORD@STREAM.
%
% It prepares everything for the first pass through all input
% coordinates.
\def\pgfplots@PREPARE@COORD@STREAM@start@{%
	% The current implementation of pgfplots stores the preprocessed
	% coordinate stream into a long list of coordinates.
	% Since macro append is an expensive operation, it uses the highly
	% optimized 'applistXX' structure:
	\pgfplotsapplistXXnewempty
	%
	%
	\ifpgfplots@errorbars@enabled
		% prepare error bar processing.
		%
		% The actual implementation stores every final drawing command
		% into a list. 
		%
		% Prepare that list:
		\pgfplots@streamerrorbar@recordto{\pgfplots@recordederrorbar}%
		\pgfplots@streamerrorbarstart
		%
		% Now, prepare the coordinate processing for errorbars:
		\pgfplots@PREPARE@errorbar@processing@in@dir x%
		\pgfplots@PREPARE@errorbar@processing@in@dir y%
		\ifpgfplots@curplot@threedim
			\pgfplots@PREPARE@errorbar@processing@in@dir z%
		\else
			\let\pgfplots@PREPARE@errorbar@process@z=\relax
		\fi
	\else
		\let\pgfplots@recordederrorbar=\pgfutil@empty
	\fi
	\ifpgfplots@stackedmode
		\pgfplots@stacked@beginplot
	\fi
	%
	% Inside of math expressions, 'x', 'y' and 'z' expand to the
	% current x,y and z coords respectively. Introduce these (and some
	% more) shortcuts:
	\pgfplotsmathdeclarepseudoconstant{x}{\let\pgfmathresult=\pgfplots@current@point@x}%
	\pgfplotsmathdeclarepseudoconstant{y}{\let\pgfmathresult=\pgfplots@current@point@y}%
	\pgfplotsmathdeclarepseudoconstant{z}{\let\pgfmathresult=\pgfplots@current@point@z}%
	\pgfplotsmathdeclarepseudoconstant{meta}{%
		\let\pgfmathresult=\pgfplots@current@point@meta
		\ifx\pgfmathresult\pgfutil@empty
			\pgfmathfloatcreate{0}{0.0}{0}%
		\fi
	}%
	%
	% %%%%%%%%%%%%%%
	%
	% Define \pgfplots@set@perpointmeta properly:
	\ifcase\pgfplots@perpointmeta@choice
		% disabled.
		\def\pgfplots@set@perpointmeta{%	
			\let\pgfplots@current@point@meta=\pgfutil@empty
		}%
	\or
		% point meta/x
		\def\pgfplots@set@perpointmeta{%	
			\let\pgfplots@current@point@meta=\pgfplots@current@point@x
		}%
		\ifpgfplots@xislinear
		\else	
			\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%	
				\pgfplots@set@perpointmeta
				\pgfmathfloatparsenumber{\pgfplots@current@point@meta}%
				\let\pgfplots@current@point@meta=\pgfmathresult
			}%
		\fi
	\or
		% point meta/y
		\def\pgfplots@set@perpointmeta{%	
			\let\pgfplots@current@point@meta=\pgfplots@current@point@y
		}%
		\ifpgfplots@yislinear
		\else	
			\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%	
				\pgfplots@set@perpointmeta
				\pgfmathfloatparsenumber{\pgfplots@current@point@meta}%
				\let\pgfplots@current@point@meta=\pgfmathresult
			}%
		\fi
	\or
		% point meta/z
		\def\pgfplots@set@perpointmeta{%	
			\let\pgfplots@current@point@meta=\pgfplots@current@point@z
		}%
		\ifpgfplots@zislinear
		\else	
			\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%	
				\pgfplots@set@perpointmeta
				\pgfmathfloatparsenumber{\pgfplots@current@point@meta}%
				\let\pgfplots@current@point@meta=\pgfmathresult
			}%
		\fi
	\or
		% point meta/explicit : parse the information found
		% somewhere:
		\def\pgfplots@set@perpointmeta{%	
			\ifx\pgfplots@current@point@meta\pgfutil@empty
			\else
				\pgfmathfloatparsenumber{\pgfplots@current@point@meta}%
			\fi
			\let\pgfplots@current@point@meta=\pgfmathresult
		}%
	\or
		% point meta/explicit symbolic : simply collect the
		% information, no math.
		\def\pgfplots@set@perpointmeta{}%
	\fi
	% check 
	%   if( we have point meta )...
	\pgfplots@loc@tmptrue
	\ifnum\pgfplots@perpointmeta@choice=0
		\pgfplots@loc@tmpfalse
	\else
		\ifnum\pgfplots@perpointmeta@choice=5
			\pgfplots@loc@tmpfalse
		\fi
	\fi
	\pgfkeysgetvalue{/pgfplots/point meta/expr}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\expandafter\def\expandafter\pgfplots@set@perpointmeta\expandafter{%	
			\pgfplots@set@perpointmeta
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/point meta/expr}}%
			\let\pgfplots@current@point@meta=\pgfmathresult
		}%
		% update limits in this case:
		\pgfplots@loc@tmptrue
		% make sure it is not 'none':
		\def\pgfplots@perpointmeta@choice{4}%
	\fi
	\ifpgfplots@loc@tmp
		% We need to work with per point meta data.
		% So, also compute the data range on a per-plot basis!
		% These limits are important later.
		\pgfkeysgetvalue{/pgfplots/point meta min}\pgfplots@metamin
		\t@pgfplots@tokb={}%
		\ifx\pgfplots@metamin\pgfutil@empty
			\global\let\pgfplots@metamin=\pgfplots@invalidrange@metamin
			\t@pgfplots@tokb=\expandafter{\the\t@pgfplots@tokb
				\pgfplotsmathfloatmin{\pgfplots@metamin}{\pgfplots@current@point@meta}%
				\global\let\pgfplots@metamin=\pgfmathresult
			}%
		\else
			\pgfmathfloatparsenumber{\pgfplots@metamin}%
			\global\let\pgfplots@metamin=\pgfmathresult
		\fi
		\pgfkeysgetvalue{/pgfplots/point meta max}\pgfplots@metamax
		\ifx\pgfplots@metamax\pgfutil@empty
			\global\let\pgfplots@metamax=\pgfplots@invalidrange@metamax
			\t@pgfplots@tokb=\expandafter{\the\t@pgfplots@tokb
				\pgfplotsmathfloatmax{\pgfplots@metamax}{\pgfplots@current@point@meta}%
				\global\let\pgfplots@metamax=\pgfmathresult
			}%
		\else
			\pgfmathfloatparsenumber{\pgfplots@metamax}%
			\global\let\pgfplots@metamax=\pgfmathresult
		\fi
		%
		\t@pgfplots@toka=\expandafter{\pgfplots@set@perpointmeta}%
		\edef\pgfplots@set@perpointmeta{%
			\the\t@pgfplots@toka
			\noexpand\ifx\noexpand\pgfplots@current@point@meta\noexpand\pgfutil@empty
			\noexpand\else
				\the\t@pgfplots@tokb
			\noexpand\fi
		}%
	\else
		% there is no point meta:
		\global\let\pgfplots@metamin=\pgfutil@empty
		\global\let\pgfplots@metamax=\pgfutil@empty
	\fi
}%
% This is the \pgfplots@coord@stream@end@ routine which is invoked by
% \pgfplots@PREPARE@COORD@STREAM. 
%
% It finalizes the first pass through the input coordinates and
% remembers the preprocessed \addplot command.
%
% Technical note: The parameters provided to
% \pgfplots@PREPARE@COORD@STREAM
% are needed here. This doesn't fit directly into the framework of
% coordinate streams, see \pgfplots@PREPARE@COORD@STREAM how this
% invocation works.
%
% #1,#2: see \pgfplots@PREPARE@COORD@STREAM
\def\pgfplots@PREPARE@COORD@STREAM@end@#1{%
	\ifx\pgfplots@metamin\pgfutil@empty
	\else
		\if\pgfplots@axiswide@metamin@autocompute1%
			\pgfplotsmathfloatmin{\pgfplots@axiswide@metamin}{\pgfplots@metamin}%
			\global\let\pgfplots@axiswide@metamin=\pgfmathresult
		\fi
		\if\pgfplots@axiswide@metamax@autocompute1%
			\pgfplotsmathfloatmax{\pgfplots@axiswide@metamax}{\pgfplots@metamax}%
			\global\let\pgfplots@axiswide@metamax=\pgfmathresult
		\fi
	\fi
	\ifpgfplots@autocompute@all@limits
		\global\let\pgfplots@data@xmin=\pgfplots@xmin
		\global\let\pgfplots@data@xmax=\pgfplots@xmax
		\global\let\pgfplots@data@ymin=\pgfplots@ymin
		\global\let\pgfplots@data@ymax=\pgfplots@ymax
		\global\let\pgfplots@data@zmin=\pgfplots@zmin
		\global\let\pgfplots@data@zmax=\pgfplots@zmax
	\fi
	\ifpgfplots@errorbars@enabled
		\pgfplots@streamerrorbarend
	\fi
	\ifpgfplots@stackedmode
		\pgfplots@stacked@endplot
	\fi
	\ifpgfplots@coord@stream@isfirst
		\pgfplots@warning{the current plot has no coordinates (or all have been filtered away)}%
	\fi
%		\else
		% Idea: use
		%   \scope[plot specification]
		%   <any paths for error bars>
		%   \endscope
		%   \draw plot coordinates {...};
		% to share plot specifications between error bars and plot
		% coordinates. Unfortunately, it is NOT sufficient to use
		% \tikzset
		\pgfkeyssetvalue{/pgfplots/mesh/num points}{\pgfplots@current@point@coordindex}%
		\pgfplotspreparemeshkeydefaults%
		\expandafter\pgfplots@rememberplotspec\expandafter{\pgfplots@addplot@survey@@optionlist}%
		% warning: rememberplotspec calls list macros which
		% overwrite \t@pgfplots@toka
		\t@pgfplots@toka=\expandafter{\pgfplots@addplot@survey@@optionlist}%
		\global\let\pgfplots@last@plot@style=\pgfplots@addplot@survey@@optionlist% store it for \label commands
		% ATTENTION: do NOT call list macros from here on!
		%
		\ifpgfplots@datascaletrafo@initialised
			\pgfplots@addplot@get@named@startendpoints@command\pgfplots@loc@TMPa
			\t@pgfplots@tokc=\expandafter{\pgfplots@loc@TMPa}%
		\else
			\t@pgfplots@tokc={}%
		\fi
		% SERIALIZE RESULT:
		%
		% everything which has been accumulated so far (including the
		% preprocessed coordinates) will be serialized into the
		% structure \pgfplots@stored@plotlist (globally).
		%
		% assembe a \pgfplots@addplot@enqueue@coords command ...
		% BEGIN HERE ...
		% vvvvvvvvvv
		\xdef\pgfplots@glob@TMPa{%
			\noexpand\pgfplots@addplot@enqueue@coords
			{% precommand(s):
				\expandafter\noexpand\csname pgfplots@curplot@threedim\ifpgfplots@curplot@threedim true\else false\fi\endcsname
				\noexpand\def\noexpand\plotnum{\the\pgfplots@numplots}%
				\noexpand\def\noexpand\numcoords{\pgfplots@current@point@coordindex}%
				% \pgfplots@current@point@coordindex will always contain the current index.
				% Maybe overwritten if not provided using \c@pgfplots@coordindex.
				\noexpand\def\noexpand\pgfplots@current@point@coordindex{\noexpand\the\noexpand\c@pgfplots@coordindex}%
				\noexpand\def\noexpand\coordindex{\noexpand\pgfplots@current@point@coordindex}% valid inside of \addplot
				%
				% save the possibly prepare/adjusted plot
				% variables [FIXME: move after \pgfplots@define@currentplotstyle@as ?]:
				\noexpand\pgfkeyssetvalue{/pgfplots/samples}{\pgfplots@plot@samples}%
				\noexpand\pgfkeyssetvalue{/pgfplots/domain}{\pgfplots@plot@domain}%
				\noexpand\pgfkeyssetvalue{/pgfplots/samples at}{\pgfplots@plot@samples@at}%
				\noexpand\pgfkeyssetvalue{/pgfplots/mesh/rows}{\pgfkeysvalueof{/pgfplots/mesh/rows}}%
				\noexpand\pgfkeyssetvalue{/pgfplots/mesh/cols}{\pgfkeysvalueof{/pgfplots/mesh/cols}}%
				%
				\noexpand\pgfplots@initzerolevelhandler
				\the\t@pgfplots@tokc% named start/end points (if already available)
				\noexpand\pgfplots@define@currentplotstyle@as{\the\t@pgfplots@toka}%
				% per-point meta data ranges which apply only to
				% this plot:
				\noexpand\xdef\noexpand\pgfplots@metamin{\pgfplots@metamin}%
				\noexpand\xdef\noexpand\pgfplots@metamax{\pgfplots@metamax}%
				\noexpand\def\noexpand\pgfplots@perpointmeta@choice{\pgfplots@perpointmeta@choice}%
			}%
			{% draw command:
				\noexpand\draw%
			}%
		}%
		\pgfplotsapplistXXlet\pgfplots@coord@stream@recorded
		\pgfplotsapplistXXclear
		\t@pgfplots@tokc=\expandafter{\pgfplots@coord@stream@recorded}%
		\t@pgfplots@tokb={#1;}%
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
		\xdef\pgfplots@glob@TMPa{%
			\the\t@pgfplots@toka
			{% coordinates which need to be processed in \endaxis.
			% See
			% \pgfplots@coord@stream@finalize@storedcoords@START
				normalized coordinates {\the\t@pgfplots@tokc}\the\t@pgfplots@tokb
			}%
		}%
		%
		% Ok, now assemble the POST COMMANDS. Error bar
		% commands will be append here (if any)
		\ifx\pgfplots@recordederrorbar\pgfutil@empty
			\pgfplots@glob@TMPa
				{%
					% Post commands are empty here.
				}%
		\else
			\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
			\t@pgfplots@tokb=\expandafter{\pgfplots@recordederrorbar}%
			\def\pgfplots@loc@TMPb{%
				\noexpand\pgfplots@errorbars@finishwithstyleoptions[current plot style]{\the\t@pgfplots@tokb}%
			}%
			\xdef\pgfplots@glob@TMPa{
				\the\t@pgfplots@toka
				{
					% Post commands: append error bar commands.
					\pgfplots@loc@TMPb
				}%
			}%
			\pgfplots@glob@TMPa
		\fi
		%^^^^^^^^^^^^ ... END of \pgfplots@addplot@enqueue@coords HERE
%		\fi
	\pgfplots@end@plot
}%

% Assigns default values to 'rows' and 'cols' in case
% their values are empty.
%
% PRECONDITION:
% 	The values of
% - '/pgfplots/mesh/rows' 
% - '/pgfplots/mesh/cols'
% - '/pgfplots/mesh/num points'
% - \pgfplotsscanlinelength
% - '/pgfplots/mesh/ordering'
%   are assigned properly.
%
% POSTCONDITION:
% 	'rows' and 'cols' now incorporates \pgfplotsscanlinelength if
% 	their values had been empty. However, there may still be empty
% 	values.
%
% @see \pgfplotsautocompletemeshkeys
\def\pgfplotspreparemeshkeydefaults{%
	\pgfplots@autocomplete@meshkeys0%
}%

% Completes and sanitizes 'mesh/rows' and 'mesh/cols' such that they
% have useful integer values afterwards.
%
% This method works similarly to \pgfplotspreparemeshkeydefaults.
% However, it really completes values and issues error messages if
% that proves to be impossible.
%
% PRECONDITION:
% 	The values of
% - '/pgfplots/mesh/rows' 
% - '/pgfplots/mesh/cols'
% - '/pgfplots/mesh/num points'
% - '/pgfplots/mesh/ordering'
%   are assigned properly.
%   If 
% - \pgfplotsscanlinelength
%   exists and is positive, it may also be used.
%
% POSTCONDITION:
% 	'rows' and 'cols' have useful integer values.
\def\pgfplotsautocompletemeshkeys{%
	\pgfplots@autocomplete@meshkeys1%
}%
\def\pgfplots@autocomplete@meshkeys#1{%
	\pgfkeysgetvalue{/pgfplots/mesh/rows}\pgfplotsplothandlermesh@rows
	\pgfkeysgetvalue{/pgfplots/mesh/cols}\pgfplotsplothandlermesh@cols
	\pgfkeysgetvalue{/pgfplots/mesh/num points}\pgfplotsplothandlermesh@numpoints
	\edef\pgfplotsplothandlermesh@numpoints{\pgfplotsplothandlermesh@numpoints}%
	\edef\pgfplotsplothandlermesh@cols{\pgfplotsplothandlermesh@cols}%
	\edef\pgfplotsplothandlermesh@rows{\pgfplotsplothandlermesh@rows}%
	\ifpgfplots@curplot@threedim
		\ifx\pgfplotsplothandlermesh@rows\pgfutil@empty
			\ifx\pgfplotsplothandlermesh@cols\pgfutil@empty
				\pgfutil@ifundefined{pgfplotsscanlinelength}{\def\pgfplotsscanlinelength{-1}}{}%
				\ifnum\pgfplotsscanlinelength>0
					% we have scanlinelength set! Use it:
					\if\pgfplots@plot@mesh@ordering0%
						% ordering = rowwise -> scanline is cols!
						\edef\pgfplotsplothandlermesh@cols{\pgfplotsscanlinelength}%
					\else
						% ordering = colwise: scanline is rows!
						\edef\pgfplotsplothandlermesh@rows{\pgfplotsscanlinelength}%
					\fi
				\else
					\if1#1%
						% try to get reasonable values:
						\ifx\pgfplotsplothandlermesh@numpoints\pgfutil@empty
							\pgfplots@error{Sorry, 'plot mesh' needs either '[mesh/rows=<N>]' or '[mesh/cols=<N>]' set - or at least '[mesh/num points=<N>]'. But it did not find any of them...}%
							\def\pgfplotsplothandlermesh@cols{5}%
							\def\pgfplotsplothandlermesh@rows{5}%
						\else
							% We don't have rows/cols. Well, try using
							% sqrt(num points) for both of them!
							\ifnum\pgfplotsplothandlermesh@numpoints<16380
								\pgfmath@basic@sqrt@{\pgfplotsplothandlermesh@numpoints}%
							\else
								\pgfmathfloatparsenumber{\pgfplotsplothandlermesh@numpoints}%
								\pgfmathfloatsqrt@{\pgfmathresult}%
								\pgfmathfloattofixed{\pgfmathresult}%
							\fi
							\begingroup
							% Try whether this rows*rows yields numpoints:
							\afterassignment\pgfplots@gobble@until@relax
							\c@pgf@counta=\pgfmathresult\relax
							\c@pgf@countb=\c@pgf@counta
							\multiply\c@pgf@counta by\c@pgf@counta
							\def\pgfplotslocretval{1}%
							\ifnum\c@pgf@counta=\pgfplotsplothandlermesh@numpoints\relax
								% ok, rows*rows = numpoints.
								\xdef\pgfplots@glob@TMPa{\the\c@pgf@countb}%
							\else
								% oh. Did not work. Check for rounding errors:
								\c@pgf@counta=\c@pgf@countb
								\advance\c@pgf@counta by1
								\c@pgf@countb=\c@pgf@counta
								\multiply\c@pgf@counta by\c@pgf@counta
								\ifnum\c@pgf@counta=\pgfplotsplothandlermesh@numpoints
									% ok, (rows+1)*(rows+1) = numpoints.
									\xdef\pgfplots@glob@TMPa{\the\c@pgf@countb}%
								\else
									% no... did not work. num points doesn't
									% appear to be a squared number.
									\def\pgfplotslocretval{0}%
									\xdef\pgfplots@glob@TMPa{5}%
								\fi
							\fi
							\if\pgfplotslocretval1
								\pgfplots@warning{%
									'plot mesh' did not find '[mesh/rows=<N>]' or '[mesh/cols=<N>]'. 
									Assuming [mesh/rows=\pgfplots@glob@TMPa,mesh/cols=\pgfplots@glob@TMPa] 
									as sqrt(num points) = sqrt(\pgfplotsplothandlermesh@numpoints) [ = \pgfmathresult].}%
							\else
								\pgfplots@error{Sorry, 'plot mesh' needs either '[mesh/rows=<N>]' or '[mesh/cols=<N>]' set,
									but it did not find any of them. 
									I also tried rows = sqrt(num points) = sqrt(\pgfplotsplothandlermesh@numpoints) = \pgfmathresult\space without success.}%
							\fi
							\endgroup
							\let\pgfplotsplothandlermesh@rows=\pgfplots@glob@TMPa
							\let\pgfplotsplothandlermesh@cols=\pgfplots@glob@TMPa
						\fi
					\else
						% #1=0 -> leave them empty.
					\fi
				\fi
			\fi
		\fi
		\if1#1%
			\ifx\pgfplotsplothandlermesh@rows\pgfutil@empty
				\ifx\pgfplotsplothandlermesh@cols\pgfutil@empty
				\else
					% Compute 'rows' out of 'num points' and 'cols':
					\ifx\pgfplotsplothandlermesh@numpoints\pgfutil@empty
						\pgfplots@error{Sorry, matrix input needs a valid '[mesh/num points=<N>]' variable if only one of '[mesh/rows=<N>]' or '[mesh/cols=<N>]' is given.}%
						\def\pgfplotsplothandlermesh@numpoints{100}%
					\fi
					\begingroup
					\c@pgf@counta=\pgfplotsplothandlermesh@numpoints\relax
					\divide\c@pgf@counta by\pgfplotsplothandlermesh@cols\relax
					\xdef\pgfplots@glob@TMPa{\the\c@pgf@counta}%
					\endgroup
					\let\pgfplotsplothandlermesh@rows=\pgfplots@glob@TMPa
				\fi
			\else
				\ifx\pgfplotsplothandlermesh@cols\pgfutil@empty
					% Compute 'cols' out of 'num points' and 'rows':
					\ifx\pgfplotsplothandlermesh@numpoints\pgfutil@empty
						\pgfplots@error{Sorry, matrix input needs a valid '[mesh/num points=<N>]' variable if only one of '[mesh/cols=<N>]' or '[mesh/rows=<N>]' is given.}%
						\def\pgfplotsplothandlermesh@numpoints{100}%
					\fi
					\begingroup
					\c@pgf@counta=\pgfplotsplothandlermesh@numpoints\relax
					\divide\c@pgf@counta by\pgfplotsplothandlermesh@rows\relax
					\xdef\pgfplots@glob@TMPa{\the\c@pgf@counta}%
					\endgroup
					\let\pgfplotsplothandlermesh@cols=\pgfplots@glob@TMPa
				\fi
			\fi
			\ifx\pgfplotsplothandlermesh@numpoints\pgfutil@empty
				\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@rows\relax
				\multiply\c@pgfplots@scanlineindex by \pgfplotsplothandlermesh@cols\relax
				\edef\pgfplotsplothandlermesh@numpoints{\the\c@pgfplots@scanlineindex}%
			\fi
			%
			\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@rows\relax
			\multiply\c@pgfplots@scanlineindex by\pgfplotsplothandlermesh@cols\relax
			\ifnum\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@numpoints\relax
			\else
				\pgfplots@error{the arguments of [mesh/rows=\pgfplotsplothandlermesh@rows,mesh/cols=\pgfplotsplothandlermesh@cols] assume  \the\c@pgfplots@scanlineindex\space points, but I got actually N = \pgfplotsplothandlermesh@numpoints\space points! The data matrix appears to be incomplete or overcomplete!?}%
			\fi
		\fi
	\else
		% 2d visualization has no mesh:
		\edef\pgfplotsplothandlermesh@rows{\pgfplotsplothandlermesh@numpoints}%
		\def\pgfplotsplothandlermesh@cols{1}%
	\fi
	%
	\def\pgfplots@loc@TMPa{\pgfkeyssetvalue{/pgfplots/mesh/rows}}%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplotsplothandlermesh@rows}%
	\def\pgfplots@loc@TMPa{\pgfkeyssetvalue{/pgfplots/mesh/cols}}%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplotsplothandlermesh@cols}%
}%

% Prepares a macro \pgfplots@PREPARE@process@errorbar@for@dir##1
% which can then be used to process error bars. The macro will be
% \relax if error bars are disabled for #1.
%
% #1: either x, y or z.
%
% POSTCONDITION:
%   the macro \pgfplots@PREPARE@errorbar@process@#1 will be defined.
%   It is supposed to be used inside of the pgfplots streaming methods
%   and depends on the arguments
% 		\pgfplots@current@point@[xyz]
%		\pgfplots@current@point@[xyz]@unfiltered
%		\pgfplots@current@point@[xyz]@error
%	The '@unfilterered' arguments are needed for log plots. I do not
%	want to compute exp(current@point@[xyz]) again.
\def\pgfplots@PREPARE@errorbar@processing@in@dir#1{%
	\if0\csname pgfplots@errorbars@#1direction\endcsname
		% no error bars. Ok. Do nothing here.
		\expandafter\let\csname pgfplots@PREPARE@errorbar@process@#1\endcsname=\relax
	\else
		%
		% Prepare a macro which invokes
		% \pgfplots@streamerrorbarcoords.
		%
		% This involves to assign point coordinates in the correct
		% ordering; prepare that:
		\if x#1%
			\ifpgfplots@curplot@threedim
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
						{(\pgfplots@error@coord,\pgfplots@current@point@y,\pgfplots@current@point@z)}
				}%
			\else
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
						{(\pgfplots@error@coord,\pgfplots@current@point@y)}
				}%
			\fi
		\else
			\if y#1%
				\ifpgfplots@curplot@threedim
					\t@pgfplots@toka={%
							{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
							{(\pgfplots@current@point@x,\pgfplots@error@coord,\pgfplots@current@point@z)}
					}%
				\else
					\t@pgfplots@toka={%
							{(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
							{(\pgfplots@current@point@x,\pgfplots@error@coord)}
					}%
				\fi
			\else
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@error@coord)}
				}%
			\fi
		\fi
		\begingroup
		% no, assemble the macro which will invoke
		% \pgfplots@streamerrorbarcoords:
		\let\E=\noexpand
		\expandafter\xdef\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname{%
			\E\ifx\E\pgfplots@error@coord\E\pgfutil@empty
			\E\else
				\E\let\E\pgfplots@current@point@@old\expandafter\E\csname pgfplots@current@point@#1\endcsname
				\E\let\expandafter\E\csname pgfplots@current@point@#1\endcsname=\E\pgfplots@error@coord
				\E\pgfplots@update@limits@for@one@point
				\E\let\expandafter\E\csname pgfplots@current@point@#1\endcsname=\E\pgfplots@current@point@@old
				\E\edef\E\pgfplots@loc@TMPa{\the\t@pgfplots@toka}%
				\E\expandafter\E\pgfplots@streamerrorbarcoords\E\pgfplots@loc@TMPa
			\E\fi
		}%
		\endgroup
		%
		% The routine which is invoked for every reported input
		% coordinate is \pgfplots@process@errorbar@for.
		%
		% This here prepares its helper macros for direction '#1':
		\pgfplots@if{pgfplots@#1islinear}{%
			\ifcase\csname pgfplots@errorbars@#1mode\endcsname\relax
				% fixed absolute error.
				\pgfmathfloatparsenumber{\csname pgfplots@errorbars@#1fixed\endcsname}%
				\expandafter\let\csname pgfplots@error@coord@#1\endcsname=\pgfmathresult
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\if +##1%
						\pgfmathfloatadd@
							{\csname pgfplots@current@point@#1\endcsname}%
							{\csname pgfplots@error@coord@#1\endcsname}%
					\else
						\pgfmathfloatsubtract@
							{\csname pgfplots@current@point@#1\endcsname}%
							{\csname pgfplots@error@coord@#1\endcsname}%
					\fi
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% fixed relative error:
				\pgfmathfloatparsenumber{\csname pgfplots@errorbars@#1rel\endcsname}%
				\let\pgfplots@loc@TMPb=\pgfmathresult
				%
				% +1:
				\pgfmathfloatcreate{1}{1.0}{0}%
				\let\pgfplots@loc@TMPa=\pgfmathresult
				%
				% Prepare '1 + err':
				\pgfmathfloatadd@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
				\expandafter\let\csname pgfplots@error@coord@#1@+\endcsname=\pgfmathresult
				%
				% Prepare '1 - err':
				\pgfmathfloatsubtract@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
				\expandafter\let\csname pgfplots@error@coord@#1@-\endcsname=\pgfmathresult
				%
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\pgfmathfloatmultiply@
						{\csname pgfplots@current@point@#1\endcsname}
						{\csname pgfplots@error@coord@#1@##1\endcsname}%
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% explicit absolute:
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfmathfloatparsenumber{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						\if +##1%
							\pgfmathfloatadd@
								{\csname pgfplots@current@point@#1\endcsname}%
								{\pgfplots@error@coord}%
						\else
							\pgfmathfloatsubtract@
								{\csname pgfplots@current@point@#1\endcsname}%
								{\pgfplots@error@coord}%
						\fi
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\or% explicit relative:
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfmathparse{1##1\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						\pgfmathfloatmultiply@
							{\csname pgfplots@current@point@#1\endcsname}
							{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\fi
		}{%
			% LOGARITHMIC scaling. All errors are interpreted as 
			%   log(x +- e_x)
			% or
			%   log( x*(1+-e_x) )
			%
			% That means any input argument is
			% given in log base e and in fixed point.
			% Furthermore, we expect the '@unfiltered' keys to be
			% present (I don't want to apply 'exp' again!).
			%
			\ifcase\csname pgfplots@errorbars@#1mode\endcsname
				% fixed absolute, log( x +- e_x )
				\pgfmathfloatparsenumber{\csname pgfplots@errorbars@#1fixed\endcsname}%
				\expandafter\let\csname pgfplots@error@coord@#1\endcsname=\pgfmathresult
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\pgfmathfloatparsenumber{\csname pgfplots@current@point@#1@unfiltered\endcsname}%
					\let\pgfplots@loc@TMPa=\pgfmathresult
					\if +##1%
						\pgfmathfloatadd@
							{\pgfplots@loc@TMPa}%
							{\csname pgfplots@error@coord@#1\endcsname}%
					\else
						\pgfmathfloatsubtract@
							{\pgfplots@loc@TMPa}%
							{\csname pgfplots@error@coord@#1\endcsname}%
					\fi
					\pgfmathlog@float{\pgfmathresult}%
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% fixed relative, log( x ( 1+-e_x ) ) = log(x) + log(1+-e_x)
				\pgfmathfloatparsenumber{\csname pgfplots@errorbars@#1rel\endcsname}%
				\let\pgfplots@loc@TMPb=\pgfmathresult
				%
				% +1:
				\pgfmathfloatcreate{1}{1.0}{0}%
				\let\pgfplots@loc@TMPa=\pgfmathresult
				%
				% Prepare '1 + err':
				\pgfmathfloatadd@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
					% 1 + err <= 0  and log(1+err) is undefined:
					\pgfmathfloattofixed{\pgfplots@loc@TMPb}%
					\pgfplots@error{Sorry, log(1+\pgfmathresult) is undefined. Please provide a different argument for '/pgfplots/error bar/#1 fixed relative'.}%
					\let\pgfmathresult=\pgfutil@empty
				\fi
				\expandafter\let\csname pgfplots@error@coord@#1@+\endcsname=\pgfmathresult
				%
				% Prepare '1 - err':
				\pgfmathfloatsubtract@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
				\pgfmathlog@float{\pgfmathresult}%
				\ifx\pgfmathresult\pgfutil@empty
					% 1 + err <= 0  and log(1+err) is undefined:
					\pgfmathfloattofixed{\pgfplots@loc@TMPb}%
					\pgfplots@error{Sorry, log(1-\pgfmathresult) is undefined. Please provide a different argument for '/pgfplots/error bar/#1 fixed relative'.}%
					\let\pgfmathresult=\pgfutil@empty
				\fi
				\expandafter\let\csname pgfplots@error@coord@#1@-\endcsname=\pgfmathresult
				%
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\expandafter\ifx\csname pgfplots@current@point@#1@##1\endcsname\pgfutil@empty
					\else
						\pgfmath@basic@add@
							{\csname pgfplots@current@point@#1\endcsname}
							{\csname pgfplots@error@coord@#1@##1\endcsname}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\or% explicit absolute
				% log( x +- e_x )
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfmathfloatparsenumber{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						\pgfmathfloatparsenumber{\csname pgfplots@current@point@#1@unfiltered\endcsname}%
						\let\pgfplots@loc@TMPa=\pgfmathresult
						\if +##1%
							\pgfmathfloatadd@
								{\pgfplots@loc@TMPa}%
								{\pgfplots@error@coord}%
						\else
							\pgfmathfloatsubtract@
								{\pgfplots@loc@TMPa}%
								{\pgfplots@error@coord}%
						\fi
						\pgfmathlog@float{\pgfmathresult}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
				%
			\or% explicit relative:
				% log( x ( 1+-e_x ) ) = log(x) + log(1+-e_x)
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfmathfloatparsenumber{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						%
						\pgfmathfloatcreate{1}{1.0}{0}%
						\let\pgfplots@loc@TMPa=\pgfmathresult
						\if +##1%
							\pgfmathfloatadd@
								{\pgfplots@loc@TMPa}%
								{\pgfplots@error@coord}%
						\else
							\pgfmathfloatsubtract@
								{\pgfplots@loc@TMPa}%
								{\pgfplots@error@coord}%
						\fi
						\pgfmathlog@float{\pgfmathresult}%
						\let\pgfplots@error@coord=\pgfmathresult
						\ifx\pgfplots@error@coord\pgfutil@empty
							% -> log( <= 0 ) -> do nothing.
						\else
							\pgfmath@basic@add@
								{\csname pgfplots@current@point@#1\endcsname}
								{\pgfplots@error@coord}%
							\let\pgfplots@error@coord=\pgfmathresult
							\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
						\fi
					\fi
				}%
				%
			\fi
		}%
		\ifcase\csname pgfplots@errorbars@#1direction\endcsname
			% none
		\or
			% plus
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname+%
			}%
		\or
			% minus
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname-%
			}%
		\or
			% both
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname+%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname-%
			}%
		\fi
	\fi
}

% Defines the linear transformation macro \pgfplots@perpointmeta@trafo,
%
% phi : [meta_min,meta,max] -> [0,10^k]
%
% which operates on the per-point meta data (if any).
% The trafo will be skipped if there is no such data.
%
% The trafo is expected to prepare meta information before it is used
% as input to \pgfplotscolormapaccess. Thus, the 10^k is chosen to be 
% the same as \pgfplotscolormaprange (which is 1000 per default).
%
% If there is no data range (for example because meta information is
% not available or is not of numeric type), the trafo will simply
% copy the input argument symbolically.
\def\pgfplots@perpointmeta@preparetrafo{%
	\pgfutil@ifundefined{pgfplots@metamax}{\let\pgfplots@metamax=\pgfutil@empty}{}
	\if m\pgfplots@colormap@access
		% colormap access=map
		\ifx\pgfplots@metamax\pgfutil@empty
			\def\pgfplots@perpointmeta@trafo##1{\def\pgfmathresult{##1}}%
			\def\pgfplots@perpointmeta@traforange{0:1000}%
			\edef\pgfplotspointmetarange{0:1000}%
		\else
			% The transformation is
			%
			% phi(m) = ( m- meta_min) * 1000/ (meta_max-meta_min).
			%
			% -> precompute the scaling factor!
			\edef\pgfplots@loc@TMPa{\pgfplotscolormaprange}%
			\ifnum\pgfplots@loc@TMPa=1000
			\else
				\pgfplots@error{LOGIC ERROR: sorry, I have hard-coded the assumption \string\pgfplotscolormaprange = 1000, but now it is \pgfplots@loc@TMPa.}%
			\fi
			\if\pgfplots@perpointmeta@rel@choice0%
				% point meta rel=axis wide:
				\edef\pgfplotspointmetarange{\pgfplots@axiswide@metamin:\pgfplots@axiswide@metamax}%
				% Now, prepare the trafo as such.
				% It assigns \pgfmathresult (in fixed point).
				\def\pgfplots@perpointmeta@trafo##1{%
					\pgfmathfloatsubtract@{##1}{\pgfplots@axiswide@metamin}%
					\expandafter\pgfmathfloatmultiply@\expandafter{\pgfmathresult}{\pgfplots@perpointmeta@trafo@factor}%
					\expandafter\pgfmathfloattofixed@\expandafter{\pgfmathresult}%
				}%
				\pgfmathfloatsubtract@{\pgfplots@axiswide@metamax}{\pgfplots@axiswide@metamin}%
			\else
				% point meta rel=per plot:
				\edef\pgfplotspointmetarange{\pgfplots@metamin:\pgfplots@metamax}%
				% Now, prepare the trafo as such.
				% It assigns \pgfmathresult (in fixed point).
				\def\pgfplots@perpointmeta@trafo##1{%
					\pgfmathfloatsubtract@{##1}{\pgfplots@metamin}%
					\expandafter\pgfmathfloatmultiply@\expandafter{\pgfmathresult}{\pgfplots@perpointmeta@trafo@factor}%
					\expandafter\pgfmathfloattofixed@\expandafter{\pgfmathresult}%
				}%
				\pgfmathfloatsubtract@{\pgfplots@metamax}{\pgfplots@metamin}%
			\fi
			\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfmathfloatcreate{1}{1.0}{3}%
			\expandafter\pgfmathfloatdivide@\expandafter{\pgfmathresult}{\pgfplots@loc@TMPa}%
			\let\pgfplots@perpointmeta@trafo@factor=\pgfmathresult
			%
			% Expands to the transformation range as 'a:b':
			\def\pgfplots@perpointmeta@traforange{0:1000}%
		\fi
	\else
		% colormap access=direct
		\def\pgfplots@perpointmeta@trafo##1{\pgfmathfloattofixed@{##1}}%
		\def\pgfplots@perpointmeta@traforange{0:0}%
		\edef\pgfplotspointmetarange{\pgfplots@metamin:\pgfplots@metamax}%
	\fi
	\edef\pgfplotspointmetatransformedrange{\pgfplots@perpointmeta@traforange}%
}%
\def\pgfplots@perpointmeta@trafo@APPLY{%
	\ifx\pgfplots@current@point@meta\pgfutil@empty%
		\pgfplots@error{'scatter' could not access its data source. Maybe you need to add '\string\addplot\space plot[scatter src=y]' or something like that?}%
		\pgfmathfloatcreate{1}{1.0}{0}%
		\def\pgfplotspointmetatransformed{1.0}%
	\else
		% prepare arguments:
		\let\pgfplotspointmeta=\pgfplots@current@point@meta
		\pgfplots@perpointmeta@trafo{\pgfplotspointmeta}%
		\let\pgfplotspointmetatransformed=\pgfmathresult
	\fi
}%

% A looping method which applies
% \pgfplots@coord@stream@start
% for each coordinate '(x,y)'  or '(x,y) +- (ex,ey)',
%    assign \pgfplots@current@point@[xyz]
%    assign \pgfplots@current@point@[xyz]@error (if in argument list)
%    assign \pgfplots@current@point@meta
%    call \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
%
% #1 a sequence of coordinates of the form 
%   '(x,y)' or '(x,y,z)'
%   or
%   '(x,y[,z]) +- (ex,ey)'
%   or
%   '(x,y) [meta]'
%   or
%   '(x,y) +- (ex,ey) [meta]'
%   separated by white-space.
%
% The per-point meta is not implemented yet.
\long\def\pgfplots@coord@stream@foreach#1{%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\pgfplots@foreach@plot@coord@ITERATE#1\pgfplots@EOI%
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
}%

% A looping command to loop through plot coordinates.
% For every point, #1{X}{Y} will be invoked.
%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfutil@ifnextchar\par{%
			\pgfplotsscanlinecomplete
			\pgfplots@foreach@plot@coord@ITERATE@gobbleone
		}{%
			\pgfutil@ifnextchar({%
				\pgfplotsscanlinelengthincrease
				\pgfplots@foreach@plot@coord@NEXT%
			}{%
				\pgfplots@foreach@plot@coord@error
			}%
		}%
	}%
}
\long\def\pgfplots@foreach@plot@coord@error#1\pgfplots@EOI{%
	\pgfplots@error{Sorry, I could not read the plot coordinates near '#1'. Please check for format mistakes.}%
}%
\long\def\pgfplots@foreach@plot@coord@ITERATE@gobbleone#1{\pgfplots@foreach@plot@coord@ITERATE}%
\def\pgfplots@foreach@plot@coord@NEXT(#1,#2){%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@#1,#2){%
	\def\pgfplots@current@point@x@error{#1}%
	\def\pgfplots@current@point@y@error{#2}%
	\pgfutil@ifnextchar[{%
		\pgfplots@foreach@plot@coord@NEXT@meta
	}{%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\pgfplots@coord@stream@coord
		\pgfplots@foreach@plot@coord@ITERATE
	}%
}
\def\pgfplots@foreach@plot@coord@FINISH\pgfplots@EOI{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% The same for three dim coords:
\long\def\pgfplots@coord@stream@foreach@threedim#1{%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\pgfplots@foreach@plot@coord@threedim@ITERATE#1\pgfplots@EOI%
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
}%
\def\pgfplots@foreach@plot@coord@threedim@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfutil@ifnextchar\par{%
			\pgfplotsscanlinecomplete
			\pgfplots@foreach@plot@coord@threedim@ITERATE@gobbleone
		}{%
			\pgfutil@ifnextchar({%
				\pgfplotsscanlinelengthincrease
				\pgfplots@foreach@plot@coord@threedim@NEXT%
			}{%
				\pgfplots@foreach@plot@coord@error
			}%
		}%
	}%
}
\long\def\pgfplots@foreach@plot@coord@threedim@ITERATE@gobbleone#1{\pgfplots@foreach@plot@coord@threedim@ITERATE}%
\def\pgfplots@foreach@plot@coord@threedim@NEXT(#1,#2,#3){%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@threedim@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@threedim@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@threedim@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@#1,#2,#3){%
	\def\pgfplots@current@point@x@error{#1}%
	\def\pgfplots@current@point@y@error{#2}%
	\def\pgfplots@current@point@z@error{#3}%
	\pgfutil@ifnextchar[{%
		\pgfplots@foreach@plot@coord@threedim@NEXT@meta
	}{%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\pgfplots@coord@stream@coord
		\pgfplots@foreach@plot@coord@threedim@ITERATE
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%
% The same in normalized coordinates of the form
%  x1,y1,z1,m1;x2,y2,z2,m2;...;xN,yN,zN,mN;
% if the plot is not threedim, zi is empty.
%
% The mi are Meta Values associated to point coordinates. They are
% usually empty, but can be used to realize per-point marker
% modifications (scatter plots, especially for colormaps).
\long\def\pgfplots@coord@stream@foreach@NORMALIZED#1{%
	\pgfplots@coord@stream@start
	\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE#1\pgfplots@EOI
	\pgfplots@coord@stream@end
}%

% A looping command to loop through plot coordinates.
% For every point, #1{X}{Y} will be invoked.
%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfplots@foreach@plot@coord@NORMALIZED@NEXT%
	}%
}
\def\pgfplots@foreach@plot@coord@NORMALIZED@NEXT#1,#2,#3,#4;{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@current@point@meta{#4}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE
}


\newif\ifpgfplots@curplot@threedim

% The main interface to draw a plot into an axis.
%
% Usage:
% \addplot 
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
% 
% or
%
% \addplot[color=blue,mark=*]
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
%
% or one of the other input types.
% 
% The first syntax will use the next plot specification in the list
% \autoplotspeclist
% and the first will use blue color and * markers. 
%
% \addplot [<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% \addplot3[<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% 
% The complete accumulation is done GLOBALLY. It should be safe to put
% '\addplot' into local groups.
%
%
% The linespec. will be used in the legend.
%
% Low-level implementation:
%
% \pgfplots@addplot 
% \pgfplots@addplotimpl
% \pgfplots@start@plot@with@behavioroptions <--- \begingroup
% ...
% ... remember options GLOBALLY
% ... update limits GLOBALLY
% ... \pgfplots@addplot@enqueue@coords GLOBALLY
% ...
% \pgfplots@end@plot <--- \endgroup
\def\pgfplots@addplot{%
	\pgfutil@ifnextchar3{%
		\pgfplots@curplot@threedimtrue
		\pgfplots@addplot@three
	}{%
		\pgfplots@curplot@threedimfalse
		\pgfplots@addplot@
	}%
}
\def\pgfplots@addplot@three3{\pgfplots@addplot@}%
\def\pgfplots@addplot@{%
	\pgfutil@ifnextchar+{%
		\pgfplots@getautoplotspec into\nextplotspec
		\pgfplots@addplotimplAPPEND
	}{%
		\pgfutil@ifnextchar[{%
			\pgfplots@addplotimpl%
		}{%
			\pgfplots@getautoplotspec into\nextplotspec
			% the space after ']' is required here:
			% FIXME: 
			% - \addplot[]plot coordinates is NOT allowed!?
			\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec]%
		}%
	}%
}

\long\def\pgfplots@addplotimplAPPEND+[{%
	\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec,%
}

\long\def\pgfplots@addplotimpl[#1]{%
	\pgfutil@ifnextchar p{%
		\pgfplots@addplotimpl@plot{#1}%
	}{%
		\pgfplots@addplotimpl@plot{#1}plot
	}%
}

\def\pgfplots@addplotimpl@plot#1plot{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@plot@withoptions{#1}%
	}{%
		\pgfplots@addplotimpl@plot@withoptions{#1}[]%
	}%
}

\def\pgfplots@addplotimpl@plot@withoptions#1[#2]{
	\begingroup% <-- This groups ends in \pgfplots@end@plot
	%
	% make sure it is reset, just in case it is not supported by the
	% input method. 
	\pgfplotsscanlinelengthinitzero
	%
	\pgfutil@ifnextchar c{%
		\pgfplots@addplotimpl@coordinates{#1}{#2}plot 
	}{%
		\pgfutil@ifnextchar f{%
			\pgfplots@addplotimpl@f{#1}{#2}%
		}{%
			\pgfutil@ifnextchar t{%
				\pgfplots@start@plot@with@behavioroptions{#1,#2}%
				\pgfplots@addplotimpl@table{#1,#2}%
			}{%
				\pgfutil@ifnextchar ({%
					\pgfplots@addplotimpl@expression{#1}{#2}%
				}{%
					\pgfutil@ifnextchar\bgroup{%
						\pgfplots@addplotimpl@expression@curly{#1}{#2}%
					}{%
						\pgfutil@ifnextchar e{%
							\pgfplots@addplotimpl@expression@e{#1}{#2}%
						}{%
							\pgfutil@ifnextchar g{%
								\pgfplots@addplotimpl@g{#1}{#2}%
							}{%
								\pgfplots@error{Sorry, the supplied plot command is unknown or unsupported by pgfplots! Ignoring it.}%
								\pgfplots@gobble@until@semicolon
							}%
						}%
					}%
				}%
			}%
		}%
	}%
}
\def\pgfplots@addplotimpl@f#1#2f{%
	\pgfutil@ifnextchar i{%
		\pgfplots@addplotimpl@file{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@function{#1}{#2}%
	}%
}%

\def\pgfplots@gobble@until@semicolon#1;{}

% Plot expression. It invokes the pgf math parser and a customized
% pgfplots point sampling routine. Combined with the 'fixed point
% library' of pgf, it results in highly accurate plots.
%
%
\long\def\pgfplots@addplotimpl@expression#1#2(#3,#4)#5;{\pgfplots@addplotimpl@expression@{#1}{#2}{#3}{#4}{#5}}%
% \addplot[#1] [#2] (#3,#4) #5;
\long\def\pgfplots@addplotimpl@expression@#1#2#3#4#5{%
	\pgfplots@start@plot@with@behavioroptions{#1,#2,/pgfplots/mesh/ordering/rowwise}%
	%
	\pgfkeysgetvalue{/pgfplots/domain}\pgfplots@plot@domain
	\pgfkeysgetvalue{/pgfplots/samples y}\pgfplots@plot@samples@y
	\pgfkeysgetvalue{/pgfplots/samples at}\pgfplots@plot@samples@at
	% 
	% \tikz@plot@var is '\x' be default:
	\pgfplots@gettikzinternal@keyval{variable}{tikz@plot@var}{\x}%
	%
	{%
		\escapechar=-1
		\xdef\pgfplots@glob@TMPa{\expandafter\string\tikz@plot@var}%
	}%
	% \pgfplots@plot@var@nonmacro is the value '\tikz@plot@var'
	% without the '\', i.e. 'x' by default:
	\let\pgfplots@plot@var@nonmacro=\pgfplots@glob@TMPa
	%
	% Check if we have to sample a line.
	\def\pgfplots@addplotimpl@expression@samplesLINE{0}%
	\ifpgfplots@curplot@threedim
		\pgfkeysgetvalue{/pgfplots/y domain}{\pgfplots@plot@ydomain}%
		\edef\pgfplots@plot@ydomain{\pgfplots@plot@ydomain}%
		\def\pgfplots@loc@TMPa{0:0}%
		\ifx\pgfplots@plot@ydomain\pgfplots@loc@TMPa
			\def\pgfplots@addplotimpl@expression@samplesLINE{1}%
		\fi
		\ifx\pgfplots@plot@samples@y\pgfutil@empty
		\else
			\ifnum\pgfplots@plot@samples@y<2
				\def\pgfplots@addplotimpl@expression@samplesLINE{1}%
			\fi
		\fi
	\else
		\def\pgfplots@addplotimpl@expression@samplesLINE{1}%
	\fi
	%
	\pgfkeyssetvalue{/pgfplots/mesh/rows}{\pgfkeysvalueof{/pgfplots/samples}}%
	\pgfkeyssetvalue{/pgfplots/mesh/cols}{\pgfkeysvalueof{/pgfplots/samples}}% FIXME: use samples y
	\if1\pgfplots@addplotimpl@expression@samplesLINE
		\pgfkeyssetvalue{/pgfplots/mesh/cols}{1}%
	\fi
	%
	\pgfplots@PREPARE@COORD@STREAM{#5}%
	%
	% Determine whether the x range is parameterized or uniform and
	% prepare a macro which assigns \pgfplots@current@point@x:
	\def\pgfplots@addplotimpl@expression@prepare@x{%
		\pgfmathparse{#3}%
		\let\pgfplots@current@point@x=\pgfmathresult
	}%
	\def\pgfplots@addplotimpl@expression@hasuniform@x{0}%
	\def\pgfplots@loc@TMPa{#3}%
	% do we have '\x' as x coordinate?
	\expandafter\def\expandafter\pgfplots@loc@TMPb\expandafter{\tikz@plot@var}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\def\pgfplots@addplotimpl@expression@hasuniform@x{1}%
	\else
		\def\pgfplots@loc@TMPb{x}%
		% do we have 'x' as x coordinate?
		\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
			\def\pgfplots@addplotimpl@expression@hasuniform@x{1}%
		\fi
	\fi
	\if\pgfplots@addplotimpl@expression@hasuniform@x1%
		% if '#3' is '\x' or 'x', we don't need the math parser -
		% we can simply take \tikz@plot@var.
		\def\pgfplots@addplotimpl@expression@prepare@x{%
			\edef\pgfplots@current@point@x{\tikz@plot@var}%
		}%
	\fi
	%
	%
	% Now, prepare the loops.
	%
	% I am using \pgfplotsforeachungrouped in favor of
	% \foreach because \foreach does NOT allow extended
	% precision. Besides, \pgfplotsforeachungrouped avoids
	% scoping problems.
	%
	\ifpgfplots@curplot@threedim
		\def\pgfplots@addplotimpl@expression@split@yz##1,##2\pgfplots@EOI{%
			\def\pgfplots@addplotimpl@expression@yEXPR{##1}%
			\def\pgfplots@addplotimpl@expression@zEXPR{##2}%
		}%
		\pgfplots@addplotimpl@expression@split@yz#4\pgfplots@EOI%
		%
		% we don't have 'samples at' for 3D plots -> use domain!
		\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@domain\relax
		\let\pgfplots@expression@xdomain=\pgfplotslocretval
		%
		\if0\pgfplots@addplotimpl@expression@samplesLINE
			% Samples twodimensionally (a lattice):
			\ifx\pgfplots@plot@ydomain\pgfutil@empty
				\let\pgfplots@plot@ydomain=\pgfplots@plot@domain
			\fi
			\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@ydomain\relax
			\let\pgfplots@expression@ydomain=\pgfplotslocretval
			%
			% Assemble a 
			% \pgfplots@plot@data##1 -> 
			% 	\foreach \x in {-5,-4.6,...,5} 
			% 		\foreach \y in {-5,-4.6,...,5} {##1}; 
			%  macro:
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachungrouped\noexpand\y in {\pgfplots@expression@ydomain} 
					{\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@expression@xdomain} {##1}}}%
		\else
			% sample a line:
			\def\pgfplots@plot@ydomain{0:0}%
			\def\y{y}% this provides an error message, see above.
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@expression@xdomain} {##1}}%
		\fi
	\else
		% Assemble a 
		% \pgfplots@plot@data##1 -> \foreach \x in {-5,-4.6,...,5} {##1} macro:
		%
		%
		% if( 	
		% 	x is logarithmic && 
		% 	#3 == '\x' && 
		% 	the 'samples at' key has not been used )
		%  -> sample logarithmically!
		\def\pgfplots@samples@logarithmically{0}%
		\ifpgfplots@xislinear
		\else
			\if\pgfplots@addplotimpl@expression@hasuniform@x1%
				\ifx\pgfplots@plot@samples@at\pgfutil@empty
					% we don't have 'samples at' -> use domain!
					\def\pgfplots@samples@logarithmically{1}%
				\fi
			\fi
		\fi
		\if\pgfplots@samples@logarithmically1%
			% sample logarithmically:
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachlogarithmicungrouped
				\expandafter\noexpand\tikz@plot@var/\noexpand\pgfplots@current@point@x@log 
					in {\pgfplots@plot@domain} {##1}}%
			%  we have a logarithmic sampling sequence,
			% \pgfplots@current@point@x@log is already available
			% logarithmic! We can safe time and accuracy for the x
			% coordinate by using that one instead of computing
			% log(exp(\x)) numerically:
			\pgfplots@disablelogfilter@xtrue
			\def\pgfplots@addplotimpl@expression@prepare@x{%
				\let\pgfplots@current@point@x=\pgfplots@current@point@x@log
			}%
			\pgflibraryfpuifactive
				{\relax}
				{%
					% ok, if the FPU is NOT active, we should return
					% results as fixed points.
					% We need to configure that for
					% \pgfplotsforeachlogarithmicungrouped manually:
					\pgfplotsforeachlogarithmicformatresultwith{%
						\pgfmathfloattofixed{\pgfmathresult}%
					}%
				}%
		\else
			\ifx\pgfplots@plot@samples@at\pgfutil@empty
				% we don't have 'samples at' -> use domain!
				\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@domain\relax
				\let\pgfplots@loc@TMPa=\pgfplotslocretval
			\else
				% use 'samples at':
				\let\pgfplots@loc@TMPa=\pgfplots@plot@samples@at
			\fi
			\edef\pgfplots@plot@data##1{
				\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@loc@TMPa} {##1}}%
		\fi
		\def\y{0}%
		\def\pgfplots@addplotimpl@expression@yEXPR{#4}%
		\def\pgfplots@current@point@z{}%
	\fi
	%
	% START:
	%  (NOTE: this does also define 'x', 'y', and 'z' math
	%  expressions!)
	\pgfplots@coord@stream@start
	%
	% create a backup of the 'x' and 'y' math expressions which 
	% have been defined in \pgfplots@coord@stream@start:
	\let\pgfplots@addplotimpl@expression@pseudoconst@old@x=\pgfmathx@
	\let\pgfplots@addplotimpl@expression@pseudoconst@old@y=\pgfmathy@
	%
	% Prepare 'x' and 'y' as pseudo constants in expressions:
	\gdef\pgfplots@noy@error{%
		\pgfplots@error{Sorry, you can't use 'y' in this context. PGFPlots expected to sample a line, not a mesh. Please use the [mesh] option combined with [samples y>0] and [domain y!=0:0] to indicate a twodimensional input domain.}%
		\global\let\pgfplots@noy@error=\relax
	}%
	% Define a "function" x which sets \pgfmathresult := \x :
	\pgfplotsmathdeclarepseudoconstant{\pgfplots@plot@var@nonmacro}{\edef\pgfmathresult{\tikz@plot@var}}%
	\if0\pgfplots@addplotimpl@expression@samplesLINE
		% surface:
		\pgfplotsmathdeclarepseudoconstant{y}{\let\pgfmathresult=\y}%
	\else
		\pgfplotsmathdeclarepseudoconstant{y}{\pgfplots@noy@error\def\pgfmathresult{0.0}}%
	\fi
	% remember them here:
	\let\pgfplots@addplotimpl@expression@pseudoconst@x=\pgfmathx@
	\let\pgfplots@addplotimpl@expression@pseudoconst@y=\pgfmathy@
	%
	%
	\pgfplots@plot@data{%
		\let\pgfmathx@=\pgfplots@addplotimpl@expression@pseudoconst@x
		\let\pgfmathy@=\pgfplots@addplotimpl@expression@pseudoconst@y
		% eval expressions:
		\pgfplots@addplotimpl@expression@prepare@x%
		\pgfmathparse{\pgfplots@addplotimpl@expression@yEXPR}%
		\let\pgfplots@current@point@y=\pgfmathresult
		\ifpgfplots@curplot@threedim
			\pgfmathparse{\pgfplots@addplotimpl@expression@zEXPR}%
			\let\pgfplots@current@point@z=\pgfmathresult
		\fi
		% restore 'x' and 'y':
		\let\pgfmathx@=\pgfplots@addplotimpl@expression@pseudoconst@old@x
		\let\pgfmathy@=\pgfplots@addplotimpl@expression@pseudoconst@old@y
		%
		% process coords as usual:
		\pgfplots@coord@stream@coord
	}%
	\pgfplots@coord@stream@end
}%
% \addplot[#1] [#2] {#3} #4;
\long\def\pgfplots@addplotimpl@expression@curly#1#2#3#4;{\pgfplots@addplotimpl@expression@curly@{#1}{#2}{#3}{#4}}%
\long\def\pgfplots@addplotimpl@expression@curly@#1#2#3#4{%
	\pgfplots@gettikzinternal@keyval{variable}{tikz@plot@var}{\x}%
	\ifpgfplots@curplot@threedim
		\def\pgfplots@loc@TMPa{\pgfplots@addplotimpl@expression@{surf,#1}{#2}}%
		\expandafter\pgfplots@loc@TMPa\expandafter{\tikz@plot@var}{\y,#3}{#4}%
	\else
		\def\pgfplots@loc@TMPa{\pgfplots@addplotimpl@expression@{#1}{#2}}%
		\expandafter\pgfplots@loc@TMPa\expandafter{\tikz@plot@var}{#3}{#4}%
	\fi
}%
% \addplot[#1] [#2] expression[#3] {#4} #5;
\def\pgfplots@addplotimpl@expression@e#1#2expression{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@expression@e@{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@expression@e@{#1}{#2}[]%
	}%
}%
\def\pgfplots@addplotimpl@expression@e@#1#2[#3]{%
	\pgfplots@addplotimpl@expression@curly{#1}{#2,#3}%
}%


\let\pgfplots@backupof@pgfplotxyfile=\pgfplotxyfile

% the following code 
% results finally in
%
% set format "%.7e";; set samples <...>; plot ...
%
% The windows port of gnuplot doesn't run without the second semicolon
% - for whatever reason.
{
  \catcode`\%=12
  \catcode`\"=12
  \catcode`\;=12
  \xdef\pgfplots@gnuplot@format{set format "%.7e";}
}
\def\pgfplots@addplotimpl@g#1#2g{%
	\pgfutil@ifnextchar r{%
		\pgfplots@addplotimpl@graphics{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@gnuplot{#1}{#2}%
	}%
}%

% |\addplot gnuplot| is an alias to |\addplot function|
\def\pgfplots@addplotimpl@gnuplot#1#2nuplot{\pgfplots@addplotimpl@function{#1}{#2}unction}%

% \addplot[#1] plot[#2] function[#3] {#4} #5;
\def\pgfplots@addplotimpl@function#1#2unction{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@function@opt{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@function@opt{#1}{#2}[]%
	}%
}%
\def\pgfplots@addplotimpl@function@opt#1#2[#3]#4#5;{\pgfplots@addplotimpl@function@opt@{#1}{#2}{#3}{#4}{#5}}%
% \addplot[#1] [#2] function[#3] {#4} #5;
\def\pgfplots@addplotimpl@function@opt@#1#2#3#4#5{%
	\pgfplots@start@plot@with@behavioroptions{#1,#2,#3}%
	\pgfplots@gettikzinternal@keyval{prefix}{tikz@plot@prefix}{\jobname.}%
	\pgfplots@gettikzinternal@keyval{id}{tikz@plot@id}{pgf-plot}%
	\pgfplots@gettikzinternal@keyval{raw gnuplot}{iftikz@plot@raw@gnuplot}{\iffalse}%
	\pgfplots@gettikzinternal@keyval{parametric}{iftikz@plot@parametric}{\iffalse}%
	\pgfkeysgetvalue{/pgfplots/domain}\pgfplots@plot@domain
	\pgfkeysgetvalue{/pgfplots/y domain}{\pgfplots@plot@ydomain}%
	\ifx\pgfplots@plot@domain\pgfutil@empty
		% this is a potential problem: 'plot gnuplot' doesn't support
		% the 'samples at' framework which should be in effect now.
		% -> acquire the /tikz/domain value!
		\pgfplots@gettikzinternal@keyval{domain}{tikz@plot@domain}{-5:5}%
		\let\pgfplots@plot@domain=\tikz@plot@domain
	\fi
	%
	\def\pgfplots@plot@filename{\tikz@plot@prefix\tikz@plot@id}%  
	\def\pgfplots@addplotimpl@gnuplotresult@isthreedim@withtwocoords{0}%
	\iftikz@plot@raw@gnuplot%
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{#4}}%
	\else%
		\def\pgfplots@gnuplot@logdirs{}%
		\ifpgfplots@xislinear
		\else
			\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs x}%
		\fi
		\ifpgfplots@yislinear
		\else
			\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs y}%
		\fi
		\ifpgfplots@curplot@threedim
			\ifpgfplots@zislinear
			\else
				\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs z}%
			\fi
			\pgfplots@disablelogfilter@ztrue
		\fi
		\pgfplots@disablelogfilter@xtrue
		\pgfplots@disablelogfilter@ytrue
		\ifpgfplots@curplot@threedim 
			\ifx\pgfplots@plot@ydomain\pgfutil@empty
				\pgfplots@error{Sorry, '\string\addplot3 plot function{}' can't be processed correctly because 'y domain' is empty.}%
				\def\pgfplots@plot@ydomain{0:1}%
			\fi
		\fi
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{%
			\pgfplots@gnuplot@format;
			set samples \pgfkeysvalueof{/pgfplots/samples};
			\ifx\pgfplots@gnuplot@logdirs\pgfutil@empty
			\else
				set logscale \pgfplots@gnuplot@logdirs\space 2.71828182845905; 
			\fi
			\iftikz@plot@parametric	set parametric;\fi
			\ifpgfplots@curplot@threedim 
				splot [x=\pgfplots@plot@domain] [y=\pgfplots@plot@ydomain] #4;%
			\else
				plot [x=\pgfplots@plot@domain] #4;%
			\fi
			}}%
	\fi%
	\def\pgfplotxyfile{\pgfplots@addplotimpl@gnuplotresult{#5}}%
	\pgfplots@plot@data
	\let\pgfplotxyfile=\pgfplots@backupof@pgfplotxyfile
}%

\def\pgfplots@addplotimpl@gnuplotresult#1#2{%
	\begingroup
	\openin1=#2
	\ifeof1
		\pgfplots@error{Sorry, the gnuplot-result file '#2' could not be found. Maybe you need to enable the shell-escape feature? For pdflatex, this is '>> pdflatex -shell-escape'. You can also invoke '>> gnuplot <file>.gnuplot' manually on the respective gnuplot file.}%
		\aftergroup\pgfplots@loop@CONTINUEfalse
	\else
		\aftergroup\pgfplots@loop@CONTINUEtrue
	\fi
	\closein1
	\endgroup
	\ifpgfplots@loop@CONTINUE
		 % Now, invoke 'plot file'.
		 %
		 % I invoke the private '@opt@' method because the semicolon ';' 
		 % character may cause problems due to catcode mismatches.
		 % *sigh*.
		\pgfplots@addplotimpl@file@opt@@{}{}{#2}{#1}% this does not invoke the \pgfplots@start@plot@with@behavioroptions method.
	\else
		\expandafter\pgfplots@end@plot
	\fi
}

% \addplot[#1] [#2] file{#3} #4;
\def\pgfplots@addplotimpl@file#1#2ile{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@file@opt{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@file@opt{#1}{#2}[]%
	}%
}

% \addplot[#1] [#2] file[#3] {#4} #5;
\def\pgfplots@addplotimpl@file@opt#1#2[#3]#4#5;{\pgfplots@addplotimpl@file@opt@{#1}{#2}{#3}{#4}{#5}}%
\def\pgfplots@addplotimpl@file@opt@#1#2#3#4#5{%
	% invoke this here - allows to share the 'plot file' impl with
	% 'plot gnuplot'.
	\pgfplots@start@plot@with@behavioroptions{#1,#2}%
	\pgfplots@addplotimpl@file@opt@@{#1,#2}{#3}{#4}{#5}%
}
\def\pgfplots@addplotimpl@file@opt@@#1#2#3#4{%
	\begingroup
	\def\pgfplots@loc@TMPa{#2}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/plot file}{#2}%
	\fi
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\pgfplots@logfileopen{#3}%
	\openin1=#3
	\ifeof1
		\pgfplots@warning{sorry, plot file{#3} could not be opened!?}%
	\else
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\ifpgfplots@curplot@threedim
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim
			\ifnum\pgfplots@perpointmeta@choice=4
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta
			\else
				\ifnum\pgfplots@perpointmeta@choice=5
					\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta
				\fi
			\fi
		\else
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim
			\ifnum\pgfplots@perpointmeta@choice=4
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta
			\else
				\ifnum\pgfplots@perpointmeta@choice=5
					\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta
				\fi
			\fi
		\fi
		\pgfplots@addplotimpl@file@readall
	\fi
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
	\endgroup
}%
\def\pgfplots@addplotimpl@file@readall{%
	\read1 to\pgfplots@file@LINE
	\expandafter\pgfplotstableread@checkspecial@line\pgfplots@file@LINE\pgfplotstable@EOI
	\ifpgfplotstableread@skipline
	\else
		\ifpgfplots@plot@file@skipfirst
			% Silently skip first data row, assuming it is a header.
			\pgfplots@plot@file@skipfirstfalse
		\else
			\pgfplotsscanlinelengthincrease
			\expandafter\pgfplots@addplotimpl@file@parsesingle\pgfplots@file@LINE\pgfplots@EOI
		\fi
	\fi
	\ifeof1
	\else
		\expandafter
		\pgfplots@addplotimpl@file@readall
	\fi
}%

\def\pgfplots@addplotimpl@file@parsesingle@threedim#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim#1 #2 #3\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta#1 #2 #3 #4 #5\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@current@point@meta{#4}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@meta{#3}%
	\pgfplots@coord@stream@coord%
}%


\def\pgfplots@addplotimpl@graphics#1#2raphics{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@graphics@{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@graphics@{#1}{#2}[]%
	}%
}%
% \addplot[#1] plot[#2] graphics[#3] {#4} #5;
\def\pgfplots@addplotimpl@graphics@#1#2[#3]#4#5;{\pgfplots@addplotimpl@graphics@@{#1}{#2}{#3}{#4}{#5}}%
\def\pgfplots@addplotimpl@graphics@@#1#2#3#4#5{%
	\pgfplots@start@plot@with@behavioroptions{#1,#2,%
		/pgfplots/plot graphics,%
		/pgfplots/plot graphics/.cd,%
		#3,%
		/pgfplots/plot graphics/src={#4},%
		/tikz/mark=}%
	\pgfplots@PREPARE@COORD@STREAM{#5}%
	\pgfplots@coord@stream@start
	\pgfkeysgetvalue{/pgfplots/plot graphics/xmin}{\pgfplots@current@point@x}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/ymin}{\pgfplots@current@point@y}%
	\ifx\pgfplots@current@point@x\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{xmin}\fi
	\ifx\pgfplots@current@point@y\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{ymin}\fi
	\ifpgfplots@curplot@threedim
		\pgfkeysgetvalue{/pgfplots/plot graphics/zmin}{\pgfplots@current@point@z}%
	\ifx\pgfplots@current@point@z\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{zmin}\fi
	\fi
	\pgfplots@coord@stream@coord
	%
	\pgfkeysgetvalue{/pgfplots/plot graphics/xmax}{\pgfplots@current@point@x}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/ymax}{\pgfplots@current@point@y}%
	\ifx\pgfplots@current@point@x\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{xmax}\fi
	\ifx\pgfplots@current@point@y\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{ymax}\fi
	\ifpgfplots@curplot@threedim
		\pgfkeysgetvalue{/pgfplots/plot graphics/zmax}{\pgfplots@current@point@z}%
		\ifx\pgfplots@current@point@z\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{zmax}\fi
	\fi
	\pgfplots@coord@stream@coord
	%
	\pgfplots@coord@stream@end
}%
\def\pgfplots@addplotimpl@graphics@@error#1{%
	\begingroup
	\pgfplots@error{Sorry, but 'plot graphics' can't determine where to place the graphics file - (at least) the key '#1' is missing. Please verify that you provided all required limits, for example 'plot graphics[xmin=0,xmax=1,ymin=0,ymax=1] {<graphics>}'.}%
	\endgroup
}%




% \addplot[#1] table[#2] [from] {<\macro>} #4;
% or
% \addplot[#1] table[#2] {<filename>} #4;
%
% The distinction between <\macro> and <filename> is done
% automatically.
%
% Input options can be provided in '#2' using
% - column names, 
%   	for example '/pgfplots/table/x=firstcol' or just 'x=firstcol'
%
% - column indices,
%   	for example '/pgfplots/table/x index=3' or just 'x index=3'
%
% - expressions involving any of the table's data cells in the
%   currently processed cell,
%   	for example '/pgfplots/table/x expr={\x * \y + \thisrow{columnxxx}/2}'
%   During expr, the following (non-exhaustive) list of macros is
%   available:
%   	- \x, \y, \z, \meta, \errorx, \errory, \errorz
%   	Provide access to the cell content which would be used without
%   	'expr'.
%   	The first three access the input coordinate columns, \meta the meta column 
%   	(if any) and the last three the error data (if any). 
%
%		That means it is allowed to provide both, 'x' and 'x expr': 
%		'x expr' can use the (old) value stored in 'x'. the final x
%		coordinate will be that returned of 'x expr'.
%
%   	- \coordindex 
%
%   	- \lineno (physical line numbers including comments etc)
%
%   	- \thisrow{<colname>}
%   		allows access to any columns.
%
%   	- \getthisrow{<colname>}{<\macro>}
%   		this is a fragile command! Don't use it directly inside of
%   		a math expression, prefer \thisrow.
%
%   The FPU will be used to evaluate any expressions.
%
% @REMARKS the implementation for '* expr' differs for the '<\macro>'
% and '<filename>' input types:
% - for '{<filename>}', only the current row is available.
% - for '{<\macro>}', the `create on use' framework of the table
%   package is used - with all its features, including comfortable
%   access to the previous and next row and accumulation features.
\def\pgfplots@addplotimpl@table#1table{%
	\pgfutil@ifnextchar[{%
		\pgfplots@addplotimpl@table@getopts{#1}%
	}{%
		\pgfplots@addplotimpl@table@getopts{#1}[x index=0,y index=1]%
	}%
}%

\def\pgfplots@addplotimpl@table@getopts#1[#2]{%
	\pgfutil@ifnextchar f{%
		\pgfplots@addplotimpl@table@fromstructure{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@table@fromfile{#1}{#2}%
	}%
}

% this macro simply invokes the "correct" table processing routine.
% The distinction between 'table from {<\macro>}' and 'table
% {<filename>}' is deprecated; it is done automatically now.
%
% \addplot[#1] table[#2] [from] {#3} #4;
\def\pgfplots@addplotimpl@table@startprocessing#1#2#3#4{%
	\pgfplotstable@isloadedtable{#3}{%
		\pgfplots@addplotimpl@table@fromstructure@{#1}{#2}{#3}{#4}%
	}{%
		\pgfplots@addplotimpl@table@fromfile@{#1}{#2}{#3}{#4}%
	}%
}%

% \addplot[#1] table[#2] from {#3} #4;
%
% #1: arguments to \addplot[...]
% #2: arguments to table[...]
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
\long\def\pgfplots@addplotimpl@table@fromstructure#1#2from#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
% \addplot[#1] table[#2] from {#3} #4 ;
\long\def\pgfplots@addplotimpl@table@fromstructure@#1#2#3#4{%
	% set options here. They may contain behavior options!
	\pgfplots@addplotimpl@table@installkeypath
	\pgfplotstableset{#2}%
	\begingroup
	\pgfplotstablegetscanlinelength{#3}{\pgfplotsscanlinelength}%
	% FIXME : this thing here has runtime O(N^2) !
	% I fear it is faster to simply reload the data .... !?
	%
	% well, for a lot of columns which are used in different contexts
	% and few rows, this here IS more efficient.
	\pgfplotstablecopy#3\to\pgfplots@table
	\pgfkeysgetvalue{/pgfplots/table/x}{\pgfplots@plot@tbl@x}%
	\pgfkeysgetvalue{/pgfplots/table/x index}{\pgfplots@plot@tbl@xindex}%
	\pgfkeysgetvalue{/pgfplots/table/y}{\pgfplots@plot@tbl@y}%
	\pgfkeysgetvalue{/pgfplots/table/y index}{\pgfplots@plot@tbl@yindex}%
	\pgfkeysgetvalue{/pgfplots/table/z}{\pgfplots@plot@tbl@z}%
	\pgfkeysgetvalue{/pgfplots/table/z index}{\pgfplots@plot@tbl@zindex}%
	\pgfkeysgetvalue{/pgfplots/table/meta}{\pgfplots@plot@tbl@meta}%
	\pgfkeysgetvalue{/pgfplots/table/meta index}{\pgfplots@plot@tbl@metaindex}%
	%
	\ifx\pgfplots@plot@tbl@x\pgfutil@empty
		\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@xindex\of\pgfplots@table\to\pgfplots@plot@tbl@x
	\fi
	\ifx\pgfplots@plot@tbl@y\pgfutil@empty
		\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@yindex\of\pgfplots@table\to\pgfplots@plot@tbl@y
	\fi
	\ifpgfplots@curplot@threedim
		\ifx\pgfplots@plot@tbl@z\pgfutil@empty
			\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@zindex\of\pgfplots@table\to\pgfplots@plot@tbl@z
		\fi
	\fi
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
		\ifx\pgfplots@plot@tbl@metaindex\pgfutil@empty
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@metaindex\of\pgfplots@table\to\pgfplots@plot@tbl@meta
		\fi
	\fi
	%
	%
	% high level user interface functions:
	\def\coordindex{\pgfplotstablerow}%
	\let\lineno=\coordindex% is the same here
	%
	% modify \pgfplots@plot@tbl@{x,y,z,meta} if there are
	% corresponding '#1 expr' statements:
	\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for x\x%
	\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for y\y%
	\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for {meta}\meta%
	\ifpgfplots@curplot@threedim
		\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for z\z%
	\fi
	%
	\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@x\of\pgfplots@table\to\addplot@tbl@x
	\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@y\of\pgfplots@table\to\addplot@tbl@y
	\ifpgfplots@curplot@threedim
		\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@z\of\pgfplots@table\to\addplot@tbl@z
	\fi
	%
	\let\addplot@tbl@meta=\pgfutil@empty
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
	\else
		\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@meta\of\pgfplots@table\to\addplot@tbl@meta
	\fi
	%
	%
	\let\addplot@tbl@error@x=\pgfutil@empty
	\let\addplot@tbl@error@y=\pgfutil@empty
	\let\addplot@tbl@error@z=\pgfutil@empty
	\ifpgfplots@errorbars@enabled
		\pgfkeysgetvalue{/pgfplots/table/x error index}\pgfplots@plot@tbl@error@xindex
		\pgfkeysgetvalue{/pgfplots/table/x error}\pgfplots@plot@tbl@error@x
		\pgfkeysgetvalue{/pgfplots/table/y error index}\pgfplots@plot@tbl@error@yindex
		\pgfkeysgetvalue{/pgfplots/table/y error}\pgfplots@plot@tbl@error@y
		\pgfkeysgetvalue{/pgfplots/table/z error index}\pgfplots@plot@tbl@error@zindex
		\pgfkeysgetvalue{/pgfplots/table/z error}\pgfplots@plot@tbl@error@z
		\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@xindex\pgfutil@empty
			\else
				\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@error@xindex\of\pgfplots@table\to\pgfplots@plot@tbl@error@x
			\fi
		\fi
		%
		\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@yindex\pgfutil@empty
			\else
				\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@error@yindex\of\pgfplots@table\to\pgfplots@plot@tbl@error@y
			\fi
		\fi
		%
		\ifpgfplots@curplot@threedim
			\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
				\ifx\pgfplots@plot@tbl@error@zindex\pgfutil@empty
				\else
					\pgfplotstablegetcolumnnamebyindex\pgfplots@plot@tbl@error@zindex\of\pgfplots@table\to\pgfplots@plot@tbl@error@z
				\fi
			\fi
		\else
			\let\pgfplots@plot@tbl@error@z=\pgfutil@empty
		\fi
		%
		% modify \pgfplots@plot@tbl@{x error,y error,z error} if there are
		% corresponding '#1 expr' statements:
		\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for {x error}\errorx%
		\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for {y error}\errory%
		\ifpgfplots@curplot@threedim
			\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for {z error}\errorz%
		\fi
		%
		% now: load the columns:
		\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@x\of\pgfplots@table\to\addplot@tbl@error@x
		\fi
		\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@y\of\pgfplots@table\to\addplot@tbl@error@y
		\fi
		\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
		\else
			\pgfplotstablegetcolumnbyname\pgfplots@plot@tbl@error@z\of\pgfplots@table\to\addplot@tbl@error@z
		\fi
		%
	\else
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
	\fi
	%
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\pgfplots@coord@stream@start
	\pgfutil@loop
	\pgfplotslistcheckempty\addplot@tbl@x
	\ifpgfplotslistempty
		\pgfplots@loop@CONTINUEfalse
	\else
		% This here is just for sanity checking: if the 'y' column is 
		% - for whatever reasons - invalid; provide good error
		%   recovery.
		\pgfplotslistcheckempty\addplot@tbl@y
		\ifpgfplotslistempty
			\pgfplots@loop@CONTINUEfalse
		\else
			\pgfplots@loop@CONTINUEtrue
		\fi
	\fi
	\ifpgfplots@loop@CONTINUE
		\pgfplotslistpopfront\addplot@tbl@x\to\pgfplots@current@point@x
		\pgfplotslistpopfront\addplot@tbl@y\to\pgfplots@current@point@y
		\ifpgfplots@curplot@threedim
			\pgfplotslistpopfront\addplot@tbl@z\to\pgfplots@current@point@z
		\fi
		\ifx\addplot@tbl@meta\pgfutil@empty
		\else
			\pgfplotslistpopfront\addplot@tbl@meta\to\pgfplots@current@point@meta
		\fi
		\ifpgfplots@errorbars@enabled
			\ifx\addplot@tbl@error@x\pgfutil@empty
				\let\pgfplots@current@point@x@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@x\to\pgfplots@current@point@x@error
			\fi
			\ifx\addplot@tbl@error@y\pgfutil@empty
				\let\pgfplots@current@point@y@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@y\to\pgfplots@current@point@y@error
			\fi
			\ifx\addplot@tbl@error@z\pgfutil@empty
				\let\pgfplots@current@point@z@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@z\to\pgfplots@current@point@z@error
			\fi
		\fi
		\pgfplots@coord@stream@coord
	\pgfutil@repeat
	\pgfplots@coord@stream@end
	\pgfmath@smuggleone\pgfplotsscanlinelength
	\endgroup
}

% A private helper macro which initialises the '#1 expr' keys for plot
% table from structure.
%
% PRECONDITION:
% 	\pgfplots@plot@tbl@#1 contains the column name which would be used
% 	if '#1 expr' is empty.
% 
% POSTCONDITION:
% 	\pgfplots@plot@tbl@#1 will be CHANGED to use the 'expr' column (a
% 	temporary name).
% 	The old value of \pgfplots@plot@tbl@#1 is available as column
% 	alias.
% 	the high level user interface command '#2' will be set correctly.
\def\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for#1#2{%
	% get old column name into a register:
	\t@pgfplots@tokb=\expandafter\expandafter\expandafter{\csname pgfplots@plot@tbl@#1\endcsname}%
	%
	% high level user interface command:
	\edef#2{\noexpand\thisrow{\the\t@pgfplots@tokb}}%
	%
	\pgfkeysgetvalue{/pgfplots/table/#1 expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		% get expression into register: 
		\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
		%
		%
		% assemble pgfkeys statement which expands the names above
		% just one time:
		\edef\pgfplots@loc@TMPa{%
			/pgfplots/table/create on use/#1expr@tempcol/.style={%
				/pgfplots/table/create col/expr={\the\t@pgfplots@toka}%
			},%
			/pgfplots/table/alias/#1/.initial={\the\t@pgfplots@tokb}%
		}%
		\expandafter\pgfkeysalso\expandafter{\pgfplots@loc@TMPa}%
		%
		% tell `plot table' which column should be used for '#1': the
		% temporary column.
		\expandafter\def\csname pgfplots@plot@tbl@#1\endcsname{#1expr@tempcol}%
	\fi
}%


% \addplot[#1] table[#2] {#3} #4;
%
% This here is the (probably) faster input method from tables.
%
% It has linear complexity in the number of rows (as long as the
% number of rows is less than about 110000).
%
% #1: arguments to \addplot[...]
% #2: arguments to table[...]
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
%
\long\def\pgfplots@addplotimpl@table@fromfile#1#2#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
% \addplot[#1] table[#2] {#3} {#4};
\long\def\pgfplots@addplotimpl@table@fromfile@#1#2#3#4{%
	% set options outside of the following group.
	% They may contain behavior options.
	\pgfplots@addplotimpl@table@installkeypath
	\pgfplotstableset{#2}%
	%--------------------------------------------------
	% \begingroup
	% \pgfplotstableset{#2}%
	% \pgfplotstableread{#3}\pgfplots@table
	% \pgfplots@addplotimpl@table@fromstructure{#1}{}from{\pgfplots@table}{#4};%
	% \endgroup
	%-------------------------------------------------- 
	\begingroup
	\ifpgfplots@addplotimpl@readcompletely
		\pgfplotstableread{#3}\pgfplots@table
		\pgfplots@addplotimpl@table@fromstructure@{#1}{}{\pgfplots@table}{#4}%
		\pgfmath@smuggleone\pgfplotsscanlinelength
		\endgroup
		\pgfplotsscanlinedisablechanges
	\else
		\pgfplotsapplistXXglobalnewempty
		%
		% these data pointers will be prepared to allow fast access
		% into the current row while we read rows succesively from
		% disk.
		% Note: their initialisation must be postponed until
		% \pgfplotstableread is running - otherwise, we can't query
		% pointers into the table. See below.
		\let\pgfplots@table@PTR@x=\pgfutil@empty
		\let\pgfplots@table@PTR@y=\pgfutil@empty
		\let\pgfplots@table@PTR@z=\pgfutil@empty
		\let\pgfplots@table@PTR@meta=\pgfutil@empty
		%
		%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\let\pgfplots@current@point@z=\pgfutil@empty
		%
		% high level user interface functions:
		\def\coordindex{\pgfplotstablerow}%
		\def\lineno{\pgfplotstablelineno}%
		\def\x{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@x}}%
		\def\y{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@y}}%
		\def\z{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@z}}%
		\def\meta{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@meta}}%
		%
		\ifpgfplots@errorbars@enabled
			% more fast-access pointers for error data:
			\let\pgfplots@table@ERRPTR@x=\pgfutil@empty
			\let\pgfplots@table@ERRPTR@y=\pgfutil@empty
			\let\pgfplots@table@ERRPTR@z=\pgfutil@empty
			%
			% prepare:
			\let\pgfplots@current@point@x@error=\pgfutil@empty
			\let\pgfplots@current@point@y@error=\pgfutil@empty
			\let\pgfplots@current@point@z@error=\pgfutil@empty
			%
			% high level user interface functions:
			\def\errorx{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@x}}%
			\def\errory{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@y}}%
			\def\errorz{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@z}}%
			%
			\pgfplotstableread{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL
		\else
			\pgfplotstableread{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener@COLLECTNORMALIZED
		\fi
		% FIXME : i'd be glad if I could save this group: check why not
		% perhaps because \pgfplotstableread uses several pgf
		% variables?
		\pgfmath@smuggleone\pgfplotsscanlinelength
		\endgroup
		\pgfplotsscanlinedisablechanges
		%
		\pgfplots@PREPARE@COORD@STREAM{#4}%
		\pgfplotsapplistXXgloballet\pgfplots@coordlist
		\pgfplotsapplistXXglobalclear
		\ifpgfplots@errorbars@enabled
			\ifpgfplots@curplot@threedim
				\expandafter\pgfplots@coord@stream@foreach@threedim\expandafter{\pgfplots@coordlist}%%
			\else
				\expandafter\pgfplots@coord@stream@foreach\expandafter{\pgfplots@coordlist}%%
			\fi
		\else
			% this here is the usual case; it is faster than the error bar
			% stuff.
			\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@coordlist}%
		\fi
	\fi
}
\def\pgfplots@addplotimpl@table@fromfile@listener@COLLECTNORMALIZED{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	\edef\pgfplots@current@point{%
		\pgfplots@current@point@x,%
		\pgfplots@current@point@y,%
		\pgfplots@current@point@z,%
		\pgfplots@current@point@meta%
		;%
	}%
	\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@current@point}%
}
\def\pgfplots@addplotimpl@table@fromfile@listener@PREPARE{%
	% this here is only evaluated ONCE.
	\pgfkeysgetvalue{/pgfplots/table/x}{\pgfplots@plot@tbl@x}%
	\pgfkeysgetvalue{/pgfplots/table/x index}{\pgfplots@plot@tbl@xindex}%
	\pgfkeysgetvalue{/pgfplots/table/y}{\pgfplots@plot@tbl@y}%
	\pgfkeysgetvalue{/pgfplots/table/y index}{\pgfplots@plot@tbl@yindex}%
	\pgfkeysgetvalue{/pgfplots/table/z}{\pgfplots@plot@tbl@z}%
	\pgfkeysgetvalue{/pgfplots/table/z index}{\pgfplots@plot@tbl@zindex}%
	\pgfkeysgetvalue{/pgfplots/table/meta}{\pgfplots@plot@tbl@meta}%
	\pgfkeysgetvalue{/pgfplots/table/meta index}{\pgfplots@plot@tbl@metaindex}%
	%
	\pgfkeysgetvalue{/pgfplots/table/x expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\def\pgfplots@dereferencepointer@and@ASSIGN@x{%
			\pgfplotstablereadevalptr\pgfplots@table@PTR@x\pgfplots@current@point@x
		}%
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@x{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/x expr}}%
			\let\pgfplots@current@point@x=\pgfmathresult
		}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/y expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\def\pgfplots@dereferencepointer@and@ASSIGN@y{%
			\pgfplotstablereadevalptr\pgfplots@table@PTR@y\pgfplots@current@point@y
		}%
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@y{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/y expr}}%
			\let\pgfplots@current@point@y=\pgfmathresult
		}%
	\fi
	%
	\ifx\pgfplots@plot@tbl@x\pgfutil@empty
		\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@xindex}{\pgfplots@table@PTR@x}%
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@x}{\pgfplots@table@PTR@x}%
	\fi
	\ifx\pgfplots@plot@tbl@y\pgfutil@empty
		\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@yindex}{\pgfplots@table@PTR@y}%
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@y}{\pgfplots@table@PTR@y}%
	\fi
	\ifpgfplots@curplot@threedim
		%
		\pgfkeysgetvalue{/pgfplots/table/z expr}{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\def\pgfplots@dereferencepointer@and@ASSIGN@z{%
				\pgfplotstablereadevalptr\pgfplots@table@PTR@z\pgfplots@current@point@z
			}%
		\else
			\def\pgfplots@dereferencepointer@and@ASSIGN@z{%
				\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/z expr}}%
				\let\pgfplots@current@point@z=\pgfmathresult
			}%
		\fi
		\ifx\pgfplots@plot@tbl@z\pgfutil@empty
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@zindex}{\pgfplots@table@PTR@z}%
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@z}{\pgfplots@table@PTR@z}%
		\fi
	\else
		\let\pgfplots@dereferencepointer@and@ASSIGN@z=\relax
	\fi
	%
	%
	\def\pgfplots@dereferencepointer@and@ASSIGN@meta{%
		\pgfplotstablereadevalptr\pgfplots@table@PTR@meta\pgfplots@current@point@meta
	}%
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
		\ifx\pgfplots@plot@tbl@metaindex\pgfutil@empty
			\let\pgfplots@dereferencepointer@and@ASSIGN@meta=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@metaindex}{\pgfplots@table@PTR@meta}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@meta}{\pgfplots@table@PTR@meta}%
	\fi
	\pgfkeysgetvalue{/pgfplots/table/meta expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@meta{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/meta expr}}%
			\let\pgfplots@current@point@meta=\pgfmathresult
		}%
	\fi
	\let\pgfplots@addplotimpl@table@fromfile@listener@PREPARE=\relax
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@{%
	\pgfplots@addplotimpl@table@fromfile@listener@PREPARE
	\pgfplots@dereferencepointer@and@ASSIGN@x
	\pgfplots@dereferencepointer@and@ASSIGN@y
	\pgfplots@dereferencepointer@and@ASSIGN@z
	\pgfplots@dereferencepointer@and@ASSIGN@meta
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare{%
	% this here is only evaluated ONCE.
	\pgfkeysgetvalue{/pgfplots/table/x error index}\pgfplots@plot@tbl@error@xindex
	\pgfkeysgetvalue{/pgfplots/table/x error}\pgfplots@plot@tbl@error@x
	\pgfkeysgetvalue{/pgfplots/table/y error index}\pgfplots@plot@tbl@error@yindex
	\pgfkeysgetvalue{/pgfplots/table/y error}\pgfplots@plot@tbl@error@y
	\pgfkeysgetvalue{/pgfplots/table/z error index}\pgfplots@plot@tbl@error@zindex
	\pgfkeysgetvalue{/pgfplots/table/z error}\pgfplots@plot@tbl@error@z
	%
	\def\pgfplots@table@ERRPTR@x{x error}%
	\def\pgfplots@table@ERRPTR@y{y error}%
	\def\pgfplots@table@ERRPTR@z{z error}%
	%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@x{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@x\pgfplots@current@point@x@error
	}%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@y{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@y\pgfplots@current@point@y@error
	}%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@z{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@z\pgfplots@current@point@z@error
	}%
	%
	\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
		\ifx\pgfplots@plot@tbl@error@xindex\pgfutil@empty
			\let\pgfplots@table@ERRPTR@x=\relax%
			\let\pgfplots@dereferencepointer@and@ASSIGN@error@x=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@xindex}{\pgfplots@table@ERRPTR@x}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@x}{\pgfplots@table@ERRPTR@x}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/x error expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@error@x{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/x error expr}}%
			\let\pgfplots@current@point@x@error=\pgfmathresult
		}%
	\fi
	%
	%
	\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
		\ifx\pgfplots@plot@tbl@error@yindex\pgfutil@empty
			\let\pgfplots@table@ERRPTR@y=\relax%
			\let\pgfplots@dereferencepointer@and@ASSIGN@error@y=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@yindex}{\pgfplots@table@ERRPTR@y}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@y}{\pgfplots@table@ERRPTR@y}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/y error expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@error@y{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/y error expr}}%
			\let\pgfplots@current@point@y@error=\pgfmathresult
		}%
	\fi
	%
	%
	\ifpgfplots@curplot@threedim
		\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@zindex\pgfutil@empty
				\let\pgfplots@table@ERRPTR@z=\relax%
				\let\pgfplots@dereferencepointer@and@ASSIGN@error@z=\relax
			\else
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@zindex}{\pgfplots@table@ERRPTR@z}%
			\fi
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@z}{\pgfplots@table@ERRPTR@z}%
		\fi
		%
		\pgfkeysgetvalue{/pgfplots/table/z error expr}{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\def\pgfplots@dereferencepointer@and@ASSIGN@error@z{%
				\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/z error expr}}%
				\let\pgfplots@current@point@z@error=\pgfmathresult
			}%
		\fi
		%
		%
	\else
		\let\pgfplots@dereferencepointer@and@ASSIGN@error@z=\relax
	\fi
	\let\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare=\relax
}
\def\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare
	%
	\pgfplots@dereferencepointer@and@ASSIGN@error@x
	\pgfplots@dereferencepointer@and@ASSIGN@error@y
	\ifpgfplots@curplot@threedim
		\pgfplots@dereferencepointer@and@ASSIGN@error@z
		\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error,\pgfplots@current@point@z@error) [\pgfplots@current@point@meta]}%
	\else
		\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error) [\pgfplots@current@point@meta]}%
	\fi
	\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@current@point}%
}%
\def\pgfplots@addplotimpl@table@installkeypath{%
	\pgfkeysdef{/pgfplots/table/.unknown}{%
		\let\pgfplots@table@curkeyname=\pgfkeyscurrentname
		\pgfqkeys{/pgfplots}{\pgfplots@table@curkeyname=##1}%
	}%
}%

% A common routine which resets internal data structures for the
% survey phase, i.e. it is the shared implementation for all \addplot
% variations.
% 
% It takes all options which are provided to \addplot, sets them (at
% least partially) and remembers them for the command serialization.
%
% #1:  arguments to \addplot plot[#1]
%   -> these are called 'behavior' options in the manual; they are set
%   immediately.
%
% PRECONDITION:
%	\pgfplots@addplotimpl@plot@withoptions has already been invoked
%
% POSTCONDITION:
% 	- internal datastructures are initialised (coordinate indexing, fpu)
% 	- all keys which are required for the current plot are determined
% 	(and set if necessary).
% 	They are stored into 
% 	\pgfplots@addplot@survey@@optionlist.
%    
\def\pgfplots@start@plot@with@behavioroptions#1{%
	%\begingroup%<-- has been moved to \pgfplots@addplotimpl@plot@withoptions
	\c@pgfplots@coordindex=0
	\def\pgfplots@current@point@coordindex{\the\c@pgfplots@coordindex}% can be used inside of coordinate filters.
	\def\coordindex{\pgfplots@current@point@coordindex}% valid inside of \addplot
	\ifpgfplots@usefpu
		\pgfkeys{/pgf/fpu=true}%
	\fi
	\ifx\pgfplots@execute@at@begin@plot\pgfutil@empty
	\else
		\pgfplots@execute@at@begin@plot
	\fi
	% these styles may contain behavior options (error bars,
	% samples,... ) activate them!
	%
	% As of february 20, 2009,  #1 will contain BOTH, /pgfplots
	% and /tikz options. The /tikz ones are primarily for drawing
	% and are UNIMPORTANT at this stage of processing.
	% In  fact, transparency etc. will only confuse everything.
	%
	% So: ignore them and set only /pgfplots keys here:
	% This may actually redefine styles, for example
	% \addplot[every mark/.append style={}] will use
	% /pgfplots/every mark/.append style.
	% But that doesn't hurt here.
	%
	% FIXME : there are some exceptions like /tikz/id etc. These
	% exceptions need special styles in the /pgfplots root - or I
	% need to change the .unknown handler. See the available
	% compatibility styles!
	\pgfkeysdef{/pgfplots/.unknown}{%
%\message{In \string\addplot[#1]: I am silently ignoring key `\pgfkeyscurrentkeyRAW' during the preparation phase.}%
	}%
	%
	% it is possible that '#1' contains 'forget plot'. So, we need to
	% set the options before checking
	% \ifpgfplots@curplot@isirrelevant:
	\pgfplotsset{/pgfplots/every axis plot,#1}%
	%
	\ifpgfplots@curplot@isirrelevant
		\def\pgfplots@addplot@survey@@optionlist{/pgfplots/every axis plot,/pgfplots/every forget plot/.try}%
		\pgfplotsset{/pgfplots/every forget plot/.try,/pgfplots/every axis plot post}%
	\else
		\edef\pgfplots@addplot@survey@@optionlist{/pgfplots/every axis plot,/pgfplots/every axis plot no \the\pgfplots@numplots/.try}%
		\pgfplotsset{/pgfplots/every axis plot no \the\pgfplots@numplots/.try,/pgfplots/every axis plot post}%
	\fi
	\expandafter\def\expandafter\pgfplots@addplot@survey@@optionlist\expandafter{\pgfplots@addplot@survey@@optionlist,%
		#1,/pgfplots/every axis plot post}%
	\pgfplots@validate@plot@domain@arguments
}

\def\pgfplots@end@plot{%
	\ifpgfplots@curplot@isirrelevant
	\else
		\global\advance\pgfplots@numplots by1\relax%
	\fi
	\pgfplots@execute@at@end@plot
	\endgroup%<-- close the \begingroup of \pgfplots@addplotimpl@plot@withoptions
}

% \addplot[#1] [#2] {#3} #4;
\long\def\pgfplots@addplotimpl@coordinates#1#2plot coordinates#3#4;{\pgfplots@addplotimpl@coordinates@{#1}{#2}{#3}{#4}}%
% \addplot[#1] [#2] coordinates {#3} #4;
\long\def\pgfplots@addplotimpl@coordinates@#1#2#3#4{%
	\pgfplots@start@plot@with@behavioroptions{#1,#2}%
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\ifpgfplots@curplot@threedim
		\pgfplots@coord@stream@foreach@threedim{#3}%
	\else
		\pgfplots@coord@stream@foreach{#3}%
	\fi
}%

{
	% A block which handles active semicolons.
	%
	% ATTENTION: this block does only work if
	% \pgfplots@addplotimpl.... changes are reflected here!
	%
	\catcode`\;=\active
	\globaldefs=1
	% 'AS' == 'active semicolon'
	% 'IS' == 'inactive semicolon'
	\let\pgfplots@gobble@until@semicolon@IS=\pgfplots@gobble@until@semicolon
	\let\pgfplots@addplotimpl@expression@IS=\pgfplots@addplotimpl@expression
	\let\pgfplots@addplotimpl@expression@curly@IS=\pgfplots@addplotimpl@expression@curly
	\let\pgfplots@addplotimpl@function@opt@IS=\pgfplots@addplotimpl@function@opt
	\let\pgfplots@addplotimpl@file@opt@IS=\pgfplots@addplotimpl@file@opt
	\let\pgfplots@addplotimpl@table@fromstructure@IS=\pgfplots@addplotimpl@table@fromstructure
	\let\pgfplots@addplotimpl@table@fromfile@IS=\pgfplots@addplotimpl@table@fromfile
	\let\pgfplots@addplotimpl@graphics@IS=\pgfplots@addplotimpl@graphics@
	\let\pgfplots@addplotimpl@coordinates@IS=\pgfplots@addplotimpl@coordinates
	%
	\def\pgfplots@gobble@until@semicolon@AS#1;{}
	\long\def\pgfplots@addplotimpl@expression@AS#1#2(#3,#4)#5;{\pgfplots@addplotimpl@expression@{#1}{#2}{#3}{#4}{#5}}%
	\long\def\pgfplots@addplotimpl@expression@curly@AS#1#2#3#4;{\pgfplots@addplotimpl@expression@curly@{#1}{#2}{#3}{#4}}%
	\def\pgfplots@addplotimpl@function@opt@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@function@opt@{#1}{#2}{#3}{#4}{#5}}%
	\def\pgfplots@addplotimpl@file@opt@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@file@opt@{#1}{#2}{#3}{#4}{#5}}%
	\long\def\pgfplots@addplotimpl@table@fromstructure@AS#1#2from#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
	\long\def\pgfplots@addplotimpl@table@fromfile@AS#1#2#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
	\long\def\pgfplots@addplotimpl@coordinates@AS#1#2plot coordinates#3#4;{\pgfplots@addplotimpl@coordinates@{#1}{#2}{#3}{#4}}%
	\def\pgfplots@addplotimpl@graphics@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@graphics@@{#1}{#2}{#3}{#4}{#5}}%
	%
	% Checks whether ';' is an active character and, if that is the
	% case, modifies all public macros for it.
	\pgfplots@appendto@activesemicolon@switcher{%
		\let\pgfplots@gobble@until@semicolon=\pgfplots@gobble@until@semicolon@AS
		\let\pgfplots@addplotimpl@expression=\pgfplots@addplotimpl@expression@AS
		\let\pgfplots@addplotimpl@expression@curly=\pgfplots@addplotimpl@expression@curly@AS
		\let\pgfplots@addplotimpl@function@opt=\pgfplots@addplotimpl@function@opt@AS
		\let\pgfplots@addplotimpl@file@opt=\pgfplots@addplotimpl@file@opt@AS
		\let\pgfplots@addplotimpl@table@fromstructure=\pgfplots@addplotimpl@table@fromstructure@AS
		\let\pgfplots@addplotimpl@table@fromfile=\pgfplots@addplotimpl@table@fromfile@AS
		\let\pgfplots@addplotimpl@coordinates=\pgfplots@addplotimpl@coordinates@AS
		\let\pgfplots@addplotimpl@graphics@=\pgfplots@addplotimpl@graphics@AS
	}%
}

\newif\ifpgfplots@update@limits@for@one@point@ISCLIPPED
\def\pgfplots@math@ONE{1.0}%

\def\pgfplots@streamerrorbarstart{%
}%
\def\pgfplots@streamerrorbarend{%
}%
\def\pgfplots@streamerrorbarcoords#1#2{%
}%

\def\pgfplots@streamerrorbar@recordto#1{%
	\def\pgfplots@streamerrorbarstart{%
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@
	}%
	\def\pgfplots@streamerrorbarend{%
		\pgfplotsapplistXlet#1=\pgfplots@streamerrorbar@recordto@@
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@% clear
	}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplotsapplistXpushback{\pgfplots@errorbar@draw{##1}{##2}}\to\pgfplots@streamerrorbar@recordto@@
	}%
}
\def\pgfplots@streamerrorbar@directdraw{%
	\def\pgfplots@streamerrorbarstart{}%
	\def\pgfplots@streamerrorbarend{}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplots@errorbar@draw{##1}{##2}%
	}%
}
	
\def\pgfplots@invoke@filter#1#2{%
	\pgfkeysvalueof{/pgfplots/#2 filter/.@cmd}#1\pgfeov%
}%

% this is a convenience macro to save storage in the long coordinate
% lists.
\def\pgfplots@stream#1#2{\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
\def\pgfplots@stream@#1#2#3{\def\pgfplots@current@point@coordindex{#1}\pgfplots@stream{#2}{#3}}
\def\pgfplots@stream@withmeta#1#2#3{\def\pgfplots@current@point@meta{#3}\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
\def\pgfplots@stream@withmeta@#1#2#3#4{\def\pgfplots@current@point@coordindex{#1}\pgfplots@stream@withmeta{#2}{#3}{#4}}

\newif\ifpgfplots@record@marker@stream
% Takes a sequence of PREPARED coordinates which are given in floating
% point representation and applies the data scaling trafo (if
% necessary).
%
% Any coordinate will be plotted with the selected PGF plot handler.
%
% This stream is designed to be done at the end of an axis.
% See \pgfplots@coord@stream@finalize@storedcoords@START
%
% #1 : a macro which will be filled with a pgf plot stream for the
% marker points.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords#1{%
	%
	% Init the plot handlers:
	\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	\ifpgfplots@scatterplotenabled
		\ifx\tikz@plot@mark\pgfutil@empty
			\pgfplots@warning{I am confused: A scatter plot with 'mark=none'? This may need attention...?}%
		\fi
	\fi
	%
	\ifx\tikz@plot@mark\pgfutil@empty
		% mark=none : no need to waste time collecting marker
		% positions.
		\pgfplots@record@marker@streamfalse
	\else
		\ifx\pgfplots@basiclevel@plothandler\pgfplothandlerdiscard
			\ifpgfplots@clip@marker@paths
				% only marks: draw markers directly; no need for the
				% two-pass-approach.
				\let\pgfplots@basiclevel@plothandler=\relax
				\pgfplots@install@plotmark@handler
				\pgfplots@record@marker@streamfalse
			\else
				% collect mark positions... they will be drawn after
				% the clipped axis range. Clipping will only be
				% applied to their *positions*, not their paths.
				\pgfplots@record@marker@streamtrue
			\fi
		\else
			% ok, mark!=none and we also have a plot handler.
			% So, collect mark positions!
			\pgfplots@record@marker@streamtrue
		\fi
	\fi
	\gdef#1{}%
	%
	% Now, set up coordinate streams.
	\def\pgfplots@coord@stream@start@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@beginplot
			\fi
		\fi
		\pgfplots@basiclevel@plothandler
		\pgfplotstreamstart
		\let\pgfplots@data@scaletrafo@result=\pgfutil@empty
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXnewempty
			\pgfplotsapplistXXpushback{\pgfplotstreamstart}%
			%\gdef#1{\pgfplotstreamstart}%
		\fi
		\c@pgfplots@coordindex=0
	}%
	\def\pgfplots@coord@stream@end@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@endplot
			\fi
			\pgfplots@addplot@get@named@startendpoints@command\pgfplots@loc@TMPa
			\pgfplots@loc@TMPa
		\fi
		\pgfplotstreamend
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXpushback{\pgfplotstreamend}%
			\pgfplotsapplistXXflushbuffers%
			\global\let#1=\pgfplotsapplistXX
			\pgfplotsapplistXXclear
			%\expandafter\gdef\expandafter#1\expandafter{#1\pgfplotstreamend}%
		\fi
	}%
	\begingroup
	\let\E=\noexpand
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro
	%
	% Will be inserted in one of two possible places below:
	\def\pgfplots@loc@TMPa{%
		\ifnum\pgfplots@perpointmeta@choice=0
			% we don't have per-point meta data. Nothing special to
			% do:
			\E\edef\E\pgfmathresult{\E\noexpand\E\pgfplots@stream@{\E\the\E\c@pgfplots@coordindex}{\E\the\E\pgf@x}{\E\the\E\pgf@y}}%
			\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfmathresult}%
		\else
			% Ok, then we need to process the meta data as well:
			\E\edef\E\pgfmathresult{\E\noexpand\E\pgfplots@stream@withmeta@{\E\the\E\c@pgfplots@coordindex}{\E\the\E\pgf@x}{\E\the\E\pgf@y}{\E\pgfplots@current@point@meta}}%
			\E\expandafter\E\pgfplotsapplistXXpushback\E\expandafter{\E\pgfmathresult}%
		\fi
	}%
	% This finalize command maps the logical coordinate into PGF's
	% point space. Furthermore, it collects marker coordinates
	% (properly clipped by position) if markers are required (see
	% above).
	%
	% It is prepared here to eliminate if's.
	\xdef\pgfplots@coord@stream@finalize@currentpt{%
		\ifpgfplots@curplot@threedim
			\E\pgfplotsqpointxyz{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}{\E\pgfplots@current@point@z}%
		\else
			\ifpgfplots@threedim
				\E\pgfplotsqpointxyz{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}{0.0}%
			\else
				\E\pgfplotsqpointxy{\E\pgfplots@current@point@x}{\E\pgfplots@current@point@y}%
			\fi
		\fi
		\ifpgfplots@record@marker@stream
			\E\pgf@xa=\E\pgfplots@current@point@x pt % FIXME : SCOPE REGISTERS!?
			\E\pgf@ya=\E\pgfplots@current@point@y pt %
			\ifpgfplots@curplot@threedim
				\E\pgf@yb=\E\pgfplots@current@point@z pt %
			\fi
			\E\ifdim\E\pgf@xa<\E\pgfplots@xmin@reg
			\E\else
				\E\ifdim\E\pgf@xa>\E\pgfplots@xmax@reg
				\E\else
					\E\ifdim\E\pgf@ya<\E\pgfplots@ymin@reg
					\E\else
						\E\ifdim\E\pgf@ya>\E\pgfplots@ymax@reg
						\E\else
							\ifpgfplots@curplot@threedim
								\E\ifdim\E\pgf@yb<\E\pgfplots@zmin@reg
								\E\else
									\E\ifdim\E\pgf@yb>\E\pgfplots@zmax@reg
									\E\else
										\pgfplots@loc@TMPa
									\E\fi
								\E\fi
							\else
								\pgfplots@loc@TMPa
							\fi
						\E\fi
					\E\fi
				\E\fi
			\E\fi
		\fi
		\E\pgfplotstreampoint{}% it will simply take \pgf@x and \pgf@y!
		\advance\c@pgfplots@coordindex by1
	}%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
%
%\message{Prepared macro	\string \pgfplots@apply@data@scaletrafo@to@one@point {\meaning\pgfplots@apply@data@scaletrafo@to@one@point}}%
%\message{Prepared macro	\string \pgfplots@coord@stream@finalize@currentpt {\meaning\pgfplots@coord@stream@finalize@currentpt}}%
	\ifpgfplots@apply@datatrafo
		\def\pgfplots@coord@stream@coord@{%
			\pgfplots@apply@data@scaletrafo@to@one@point%
			\pgfplots@coord@stream@finalize@currentpt
		}%
	\else
		\def\pgfplots@coord@stream@coord@{%
			\pgfplots@coord@stream@finalize@currentpt
		}%
	\fi
	%
}

% Defines an optimized and matching \pgfplots@apply@data@scaletrafo@to@one@point 
% during the coordinate finalization step in \end{axis}.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro{%
	\begingroup
	\let\E=\noexpand
	% The command which is called for every non-yet-finished point.
	%
	% It is prepared here to eliminate if's.
	%
	% Arguments:
	% \pgfplots@current@point@[xyz]
	% \pgfplots@current@point@[xyz]@error (if in argument list)
	\xdef\pgfplots@apply@data@scaletrafo@to@one@point{%
		\ifpgfplots@apply@datatrafo@x
			\E\pgfplots@datascaletrafo@x{\E\pgfplots@current@point@x}%
			\E\let\E\pgfplots@current@point@x=\E\pgfmathresult
		\fi
		\ifpgfplots@apply@datatrafo@y
			\E\pgfplots@datascaletrafo@y{\E\pgfplots@current@point@y}%
			\E\let\E\pgfplots@current@point@y=\E\pgfmathresult
		\fi
		\ifpgfplots@curplot@threedim
			\ifpgfplots@apply@datatrafo@z
				\E\pgfplots@datascaletrafo@z{\E\pgfplots@current@point@z}%
				\E\let\E\pgfplots@current@point@z=\E\pgfmathresult
			\fi
		\fi
		\ifpgfplots@stackedmode
			% all these calls work with pgfmath; no more floating point
			% arithmetics are applied.
			\E\pgfplots@stacked@getnextzerolevelpoint
			\E\pgfplots@stacked@finishpoint%
			\E\pgfplots@stacked@rememberzerolevelpoint@for@next@plot{(\E\pgfplots@current@point@x,\E\pgfplots@current@point@y\ifpgfplots@threedim,\E\pgfplots@current@point@z\fi)}%
		\fi
	%	\t@pgfplots@tokc=\expandafter{\pgfplots@data@scaletrafo@result}%
	%	\edef\pgfplots@data@scaletrafo@result{\the\t@pgfplots@tokc(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
	}%
	%
	\endgroup
}

\def\pgfplots@addplot@get@named@startendpoints@command#1{%
	\ifpgfplots@coord@stream@isfirst
		% empty plot.
		\def#1{%
			\pgfcoordinate{current plot begin}{\pgfplotspointaxisorigin}%
			\pgfcoordinate{current plot end}{\pgfplotspointaxisorigin}%
		}%
	\else
		\ifpgfplots@curplot@threedim
			\edef#1{%
				\noexpand\pgfcoordinate{current plot begin}{\noexpand\pgfplotsqpointxyz{\pgfplots@currentplot@firstcoord@x}{\pgfplots@currentplot@firstcoord@y}{\pgfplots@currentplot@firstcoord@z}}%
				\noexpand\pgfcoordinate{current plot end}{\noexpand\pgfplotsqpointxyz{\pgfplots@currentplot@lastcoord@x}{\pgfplots@currentplot@lastcoord@y}{\pgfplots@currentplot@lastcoord@z}}%
			}%
		\else
			\edef#1{%
				\noexpand\pgfcoordinate{current plot begin}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@firstcoord@x}{\pgfplots@currentplot@firstcoord@y}}%
				\noexpand\pgfcoordinate{current plot end}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@lastcoord@x}{\pgfplots@currentplot@lastcoord@y}}%
			}%
		\fi
	\fi
}%

% INPUT: 
% 	either floating point or fixed point coordinates (depending on the
% 	state of the \ifpgfplots@apply@datatrafo boolean)
%
\long\def\pgfplots@coord@stream@finalize@storedcoords@START normalized coordinates #1#2;\pgfplots@EOI{%
	\ifpgfplots@threedim
		\pgfplots@apply@zbuffer{#1}%
		\let\pgfplots@coord@stream@finalize@storedcoords@START@coords=\pgfplotsretval
	\else
		\def\pgfplots@coord@stream@finalize@storedcoords@START@coords{#1}%
	\fi
	\pgfplots@assert@tikzinternal@exists{tikz@make@last@position}%
	\pgfplots@stored@current@cmd%[current plot style] <--- options are already set
	\pgfextra
	\tikzset{every plot/.try}%
	\pgfplots@coord@stream@INIT@finalize@storedcoords\pgfplots@recorded@marker@stream%
	\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@coord@stream@finalize@storedcoords@START@coords}%
	\pgfutil@ifundefined{pgfplotlastpoint}{}{%
		\tikz@make@last@position{\pgfplotlastpoint}%  
	}%
	\endpgfextra
	#2;
	\ifx\pgfplots@recorded@marker@stream\pgfutil@empty
	\else
		\ifpgfplots@clip@marker@paths
			% Draw markers on top of the plot lines:
			%
			\pgfplots@stored@current@cmd%[current plot style] <--- options are already set
			\pgfextra 
				\pgfplots@install@plotmark@handler
				\pgfplots@recorded@marker@stream 
			\endpgfextra
			;
		\else
			% sigh... ok, store the marker list (once more again).
			% They need to be drawn after the clipped area.
			\pgfplots@stored@REMEMBER@MARK@COMMAND
		\fi
	\fi
	\gdef\pgfplots@recorded@marker@stream{}% clear
}%

% This method MUST be called while \pgfplots@stored@plotlist is
% evaluated, that means
% - \pgfplots@stored@* commands need to be valid,
% - the precommand has already been invoked.
% - pgfplots@recorded@marker@stream exists
% - current plot style is valid
\def\pgfplots@stored@REMEMBER@MARK@COMMAND{%
	\pgfkeysgetvalue{/tikz/current plot style/.@cmd}{\pgfplots@loc@TMPa}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa\pgfeov}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@cmd[current plot style]}%
	\t@pgfplots@tokc=\expandafter{\pgfplots@recorded@marker@stream}%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfkeysdef{/tikz/current plot style}{\the\t@pgfplots@toka}%
		% de-activate the FPU here if it was active! I fear its number
		% format may cause errors when used in low-level
		% routines.
		\noexpand\pgfkeys{/pgf/fpu=false}%
		%
		\noexpand\xdef\noexpand\pgfplots@metamin{\pgfplots@metamin}%
		\noexpand\xdef\noexpand\pgfplots@metamax{\pgfplots@metamax}%
		\noexpand\def\noexpand\pgfplots@perpointmeta@choice{\pgfplots@perpointmeta@choice}%
		%
		\the\t@pgfplots@tokb
		\noexpand\pgfextra
		\noexpand\pgfplots@install@plotmark@handler
		\the\t@pgfplots@tokc
		\noexpand\endpgfextra
		;}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@precmd}%
	\edef\pgfplots@loc@TMPa{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
	\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplots@loc@TMPa}\to\pgfplots@stored@markerlist
}%

\def\pgfplots@install@plotmark@handler{%
	% note: I can't check on tikz@transform because it can be '\relax'.
	\pgfplots@gettikzinternal@keyval{mark indices}{tikz@mark@list}{}%
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	% do not reset \tikz@options: draw color may be acquired
	% from 'current plot style'
	%\let\tikz@options=\pgfutil@empty%
	\let\tikz@transform=\pgfutil@empty%
	\tikzset{every plot/.try,every mark}%
	%
	% This sets colors:
	\tikz@options
	%
	% This sets the \iftikz@mode@draw etc:
	%\tikz@mode
	% FIXME: using 'color=blue' will NOT activate filltrue!
	% So: if 'tikz@mode' *contains* 'fillfalse', I know what to do... 
	% but all other cases are not clear
	%--------------------------------------------------
	% \iftikz@mode@draw
	% \else
	% 	% Override the marker codes: force 'draw=none'
	% 	% even if the markers likes to be stroked:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqfill
	% \fi
	% \iftikz@mode@fill
	% \else
	% 	% Override the marker codes: force 'fill=none'
	% 	% even if the markers likes to be filled:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqstroke
	% \fi
	%-------------------------------------------------- 
	\pgfplots@perpointmeta@preparetrafo
	% this here is the MAIN marker code.
	% It may be modified if scatter plot is enabled, see below.
	\def\pgfplots@loc@TMPa{\tikz@transform\pgfuseplotmark{\tikz@plot@mark}}
	\ifpgfplots@scatterplotenabled
		% Scatter plots work like this:
		%
		% <compute per-point meta info>
		% /pgfplots/scatter/@pre marker code
		% <marker code, lowlevel>
		% /pgfplots/scatter/@post marker code
		%
		% -> that's all. The Rest is configurable with style which
		%  (re)define '@pre marker code' and '@post marker code' (see
		%  the docs for details).
		%
		% Prepare arguments for '@pre/@post' macros:
		\t@pgfplots@toka={%
			\begingroup
			\pgfplots@perpointmeta@trafo@APPLY
			\pgfkeysvalueof{/pgfplots/scatter/@pre marker code/.@cmd}\pgfeov
		}%
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
		\t@pgfplots@tokc={%
			\pgfkeysvalueof{/pgfplots/scatter/@post marker code/.@cmd}\pgfeov
			\endgroup
		}%
		\edef\pgfplots@loc@TMPa{%
			\the\t@pgfplots@toka
			\the\t@pgfplots@tokb
			\the\t@pgfplots@tokc
		}%
	\fi
	\ifx\tikz@mark@list\pgfutil@empty%
		\expandafter\pgfplothandlermark\expandafter{\pgfplots@loc@TMPa}%
	\else
		\expandafter\pgfplothandlermarklisted\expandafter{\pgfplots@loc@TMPa}{\tikz@mark@list}%
	\fi
}%

	
% This thing here shall draw all error bar commands listed in '#2'.
%
% It will be invoked when any plotting commands take effect (that
% means all limits are computed; the axis has been drawn,
% transformations are set up...)
\def\pgfplots@errorbars@finishwithstyleoptions[#1]#2{%
	\scope[/pgfplots/.cd,#1,/pgfplots/every error bar]% it uses the /pgfplots/.unknown handler
	#2%
	\endscope
}

\def\pgfplots@errorbar@draw@float(#1,#2)(#3,#4){%
	\ifpgfplots@apply@datatrafo@x
		\pgfplots@datascaletrafo@x{#1}%
		\let\pgfplots@xarg=\pgfmathresult%
		\pgfplots@datascaletrafo@x{#3}%
		\let\pgfplots@error@xarg=\pgfmathresult%
	\else
		\def\pgfplots@xarg{#1}%
		\def\pgfplots@error@xarg{#3}%
	\fi
	\ifpgfplots@apply@datatrafo@y
		\pgfplots@datascaletrafo@y{#2}%
		\let\pgfplots@yarg=\pgfmathresult%
		\pgfplots@datascaletrafo@y{#4}%
		\let\pgfplots@error@yarg=\pgfmathresult%
	\else
		\def\pgfplots@yarg{#2}%
		\def\pgfplots@error@yarg{#4}%
	\fi
	\edef\pgfplots@loc@TMPa{{(\pgfplots@xarg,\pgfplots@yarg)}{(\pgfplots@error@xarg,\pgfplots@error@yarg)}}%
	\def\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfeov
}
\def\pgfplots@errorbar@draw@float@threedim(#1,#2,#3)(#4,#5,#6){%
	\ifpgfplots@apply@datatrafo@x
		\pgfplots@datascaletrafo@x{#1}%
		\let\pgfplots@xarg=\pgfmathresult%
		\pgfplots@datascaletrafo@x{#4}%
		\let\pgfplots@error@xarg=\pgfmathresult%
	\else
		\def\pgfplots@xarg{#1}%
		\def\pgfplots@error@xarg{#4}%
	\fi
	\ifpgfplots@apply@datatrafo@y
		\pgfplots@datascaletrafo@y{#2}%
		\let\pgfplots@yarg=\pgfmathresult%
		\pgfplots@datascaletrafo@y{#5}%
		\let\pgfplots@error@yarg=\pgfmathresult%
	\else
		\def\pgfplots@yarg{#2}%
		\def\pgfplots@error@yarg{#5}%
	\fi
	\ifpgfplots@apply@datatrafo@z
		\pgfplots@datascaletrafo@z{#3}%
		\let\pgfplots@zarg=\pgfmathresult%
		\pgfplots@datascaletrafo@z{#6}%
		\let\pgfplots@error@zarg=\pgfmathresult%
	\else
		\def\pgfplots@zarg{#3}%
		\def\pgfplots@error@zarg{#6}%
	\fi
	\edef\pgfplots@loc@TMPa{{(\pgfplots@xarg,\pgfplots@yarg,\pgfplots@zarg)}{(\pgfplots@error@xarg,\pgfplots@error@yarg,\pgfplots@error@zarg)}}%
	\def\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfeov
}

\def\pgfplots@errorbar@draw#1#2{%
	\begingroup
	\ifpgfplots@apply@datatrafo
		\ifpgfplots@curplot@threedim
			\pgfplots@errorbar@draw@float@threedim#1#2%
		\else
			\pgfplots@errorbar@draw@float#1#2%
		\fi
	\else
		\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}{#1}{#2}\pgfeov%
	\fi
	\endgroup
}%

% This routine is called at the begin of every plot.
% It initialises a zero level stream.
%
% The default is to use '0' as zero level streams.
%
% This method is called as "precommand"; before any Tikz drawing
% commands have been started.
\def\pgfplots@initzerolevelhandler{%
	\ifpgfplots@stackedmode
		% ATTENTION: this thing here says:
		%    "draw zero level coordinates from list XYZ."
		% But at the time of this initialisation, the list will be EMPTY!
		%
		% It will be filled later. That's ok, because 
		% \pgfplots@initzerolevelhandler will be
		% used as 'precommand', that means before Tikz sees any
		% coordinates.
		\pgfplots@stacked@initzerolevelhandler
	\else
		\pgfplotspointaxisorigin
		\expandafter\pgfplotxzerolevelstreamconstant\expandafter{\the\pgf@x}%
		\expandafter\pgfplotyzerolevelstreamconstant\expandafter{\the\pgf@y}%
	\fi
}

% This code is mainly interesting for bar plots.
%
% It precomputes x = 0 and y = 0 - which is not necessarily
% trivial in case of data scaling. Furthermore, it applies
% coordinate clipping to the resulting values and multiplies them
% with x- and y scale vectors.
\def\pgfplots@prepare@ZERO@coordinates{%
	\ifpgfplots@xislinear
		\ifpgfplots@apply@datatrafo@x
			\pgfplots@datascaletrafo@fromfixed@x{0}%
			\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@x{0}%
		\fi
		\pgfplotsmathmax{\pgfplots@logical@ZERO@x}{\pgfplots@xmin}%
		\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
	\else
		\global\let\pgfplots@logical@ZERO@x=\pgfplots@xmin%
	\fi
	%
	\ifpgfplots@yislinear
		\ifpgfplots@apply@datatrafo@y
			\pgfplots@datascaletrafo@fromfixed@y{0}%
			\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@y{0}%
		\fi
		\pgfplotsmathmax{\pgfplots@logical@ZERO@y}{\pgfplots@ymin}%
		\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
	\else
		\global\let\pgfplots@logical@ZERO@y=\pgfplots@ymin%
	\fi
	%
	\ifpgfplots@threedim
		\ifpgfplots@zislinear
			\ifpgfplots@apply@datatrafo@z
				\pgfplots@datascaletrafo@fromfixed@z{0}%
				\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
			\else
				\gdef\pgfplots@logical@ZERO@z{0}%
			\fi
			\pgfplotsmathmax{\pgfplots@logical@ZERO@z}{\pgfplots@zmin}%
			\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
		\else
			\global\let\pgfplots@logical@ZERO@z=\pgfplots@zmin%
		\fi
	\fi
	%
	%
	\ifpgfplots@threedim
		\pgfplotsqpointxyz{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}{\pgfplots@logical@ZERO@z}%
	\else
		\pgfplotsqpointxy{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}%
	\fi
	\xdef\pgfplots@ZERO@x{\the\pgf@x}%
	\xdef\pgfplots@ZERO@y{\the\pgf@y}%
	\xdef\pgfplotspointaxisorigin{\noexpand\pgf@x=\pgfplots@ZERO@x\space\noexpand\pgf@y=\pgfplots@ZERO@y\space}%
}%



% the low-level Tikz command which realizes 'plot graphics'.
%
% It's current state is described by some pgfkeys options and two
% coordinates.
\def\pgfplotsplothandlergraphics{%
	\def\pgf@plotstreamstart{%
		\global\let\pgfplots@plot@handler@graphics@bb@first=\pgfutil@empty
		\global\let\pgfplots@plot@handler@graphics@bb@second=\pgfutil@empty
		\global\let\pgf@plotstreampoint=\pgfplots@plot@handler@graphics@collectbb%
		\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
		\global\let\pgf@plotstreamend=\pgfplots@plot@handler@graphics@finish%
	}%
}%
\def\pgfplots@plot@handler@graphics@collectbb#1{%
	\pgf@process{#1}%
	\ifx\pgfplots@plot@handler@graphics@bb@first\pgfutil@empty
		% ok, this is the lower left corner.
		\xdef\pgfplots@plot@handler@graphics@bb@first{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
	\else
		\ifx\pgfplots@plot@handler@graphics@bb@second\pgfutil@empty
			% ok, this is the upper right corner.
			\xdef\pgfplots@plot@handler@graphics@bb@second{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
		\else
			\pgfplots@error{Error using 'plot graphics': I encountered more than two coordinates!? I expected only the lower left and upper right corners!}%
		\fi
	\fi
}%
\def\pgfplots@plot@handler@graphics@finish{%
	\ifx\pgfplots@plot@handler@graphics@bb@first\pgfutil@empty
		\pgfplots@error{Error using 'plot graphics': I got too few coordinates! I expected the lower left and upper right corners!}%
		\xdef\pgfplots@plot@handler@graphics@bb@first{\noexpand\pgfqpoint{0pt}{0pt}}%
		
	\fi	
	\ifx\pgfplots@plot@handler@graphics@bb@second\pgfutil@empty
		\pgfplots@error{Error using 'plot graphics': I got too few coordinates! I expected the lower left and upper right corners!}%
		\xdef\pgfplots@plot@handler@graphics@bb@second{\noexpand\pgfqpoint{0pt}{0pt}}%
	\fi
	\begingroup
	\pgfpointdiff{\pgfplots@plot@handler@graphics@bb@first}{\pgfplots@plot@handler@graphics@bb@second}%
	\edef\pgfplots@plot@handler@graphics@DRAW@{%
		\noexpand\pgfplots@invoke@pgfkeyscode{/pgfplots/plot graphics/lowlevel draw/.@cmd}{%
			{\the\pgf@x}% width
			{\the\pgf@y}% height
		}%
	}%
	\pgftransformshift{\pgfplots@plot@handler@graphics@bb@first}%
	\node[/pgfplots/plot graphics/node] {%
		\pgfplots@plot@handler@graphics@DRAW@
	};%
	\endgroup
}%
% initial value for /pgfplots/plots graphics/lowlevel draw:
\def\pgfplots@plot@handler@graphics@DRAW#1#2{%
	\pgfkeysgetvalue{/pgfplots/plot graphics/includegraphics}{\pgfplots@loc@TMPc}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/src}{\pgfplots@loc@TMPd}%
	\ifx\pgfplots@loc@TMPd\pgfutil@empty
		\pgfplots@error{Error using 'plot graphics': I don't have a graphics file name! Please set the '/pgfplots/plot graphics/src' key to the image file name. Skipping this plot.}%
	\else
		\expandafter\includegraphics\expandafter[\pgfplots@loc@TMPc,width=#1,height=#2]{\pgfplots@loc@TMPd}%
	\fi
}%



% The low-level tikz plot handler for 3D mesh and surface plots.
%
% It expects 
% a) a coordinate stream which is a linearized matrix, iterated either
% rowwise or column wise,
% b) the current set of options in /pgfplots/mesh/.
%
%
% ATTENTION:
% 	this handler is NOT as general as the others. In particular, it
% 	can't be interrupted by TeX groups: every single statement,
% 	starting with streamstart and ending with stream end, must be in
% 	the same scope!
%
% 	As a consequence, you can't use this handler inside of (all) TikZ
% 	input streams. Try it out. It will work in pgfplots, however.
%
% Furthermore, it relies on a couple of pgfplots macros. This may
% change in future versions.
% It relies on:
% 	- \ifpgfplots@curplot@threedim
% 	- \pgfplots@current@point@meta
% 		-> it also invokes \pgfplots@perpointmeta@preparetrafo and its
% 		@APPLY counterpart which checks for
% 	- \pgfplots@metamax
% 		If you use it outside of pgfplots, use
% 		\global\let\pgfplots@metamax=\pgfutil@empty
% 		This is can be used without an initialised
% 		pgfplots axes - as long as \pgfplots@current@point@meta is in
% 		the range [0,1000].
% 	- for the case 'shader=interp', a bounding box must be established
% 	before the plot is finished. This must be done using 
%	\def\pgfplotspointbbupperright{\pgfqpointxyz{2}{2}{0.9}}
%	\def\pgfplotspointbblowerleft {\pgfqpointxyz{0}{0}{0.1}}
%	or something like that.
%
% Besides these internals, it also relies on all public /pgfplots
% configuration keys related to mesh/surface plots.
%
% Please note that the 'z buffer' feature will not work without
% pgfplots (especially the z buffer=sort feature).
%
% Here is an example which compiles without a pgfplots axes:
% ----------------------------------------------------------
% \begin{tikzpicture}
% 	\scope[
% 		/pgfplots/.cd,
% 		surf,
% 		shader=faceted,
% 		mesh/rows=4,
% 		mesh/cols=4,
% 		mesh/num points=,
% 		/tikz/x={(0.44237cm,-0.07439cm)}, 
% 		/tikz/y={(0.30942cm,0.23932cm)},
% 		/tikz/z={(0.0cm,1.5cm)},
% 	]
% \makeatletter
% 
% 	\global\let\pgfplots@metamax=\pgfutil@empty
% 	\pgfplots@curplot@threedimtrue
% 
% 	\pgfplotsplothandlermesh
% 	\pgfplotstreamstart
% 
% 	\def\rangea{0.21}%
% 	\def\rangeb{0.9}%
% 
% 	\pgfmathparse{1000/(\rangeb-\rangea)}
% 	\let\factor=\pgfmathresult
% 
% 	\def\simplecoordinate(#1,#2,#3){%
% 		\pgfmathparse{\factor*(#3 - \rangea)}%
% 		\let\pgfplots@current@point@meta=\pgfmathresult
% 		\pgfplotstreampoint{\pgfqpointxyz{#1}{#2}{#3}}%
% 	}%
% 	% for the case 'shaer=interp':
%	\def\pgfplotspointbbupperright{\pgfqpointxyz{2}{2}{0.9}}
%	\def\pgfplotspointbblowerleft {\pgfqpointxyz{0}{0}{0.1}}
% 
% \simplecoordinate(0,3,0.7)
% \simplecoordinate(1,3,0.5)
% \simplecoordinate(2,3,0.58)
% \simplecoordinate(3,3,0.9)
% 
% \simplecoordinate(0,2,0.68)
% \simplecoordinate(1,2,0.22)
% \simplecoordinate(2,2,0.25)
% \simplecoordinate(3,2,0.4)
% 
% \simplecoordinate(0,1,0.6)
% \simplecoordinate(1,1,0.3)
% \simplecoordinate(2,1,0.21)
% \simplecoordinate(3,1,0.3)
% 
% \simplecoordinate(0,0,0.8)
% \simplecoordinate(1,0,0.56)
% \simplecoordinate(2,0,0.5)
% \simplecoordinate(3,0,0.75)
% 
% 
% 	\pgfplotstreamend
% 	\pgfusepath{stroke}
% 
% 	\endscope
% \end{tikzpicture}
% ----------------------------------------------------------
%  END OF EXAMPLE
%  -> see also the legend image for mesh plots.
%
\def\pgfplotsplothandlermesh{%
	\def\pgf@plotstreamstart{%
%		\scope
		\pgfplotsautocompletemeshkeys%
		\pgfkeysgetvalue{/pgfplots/mesh/rows}\pgfplotsplothandlermesh@rows
		\pgfkeysgetvalue{/pgfplots/mesh/cols}\pgfplotsplothandlermesh@cols
		\pgfkeysgetvalue{/pgfplots/mesh/num points}\pgfplotsplothandlermesh@numpoints
		%
		\pgfutil@ifundefined{pgfplots@drawmodes}{%
			\let\pgfplots@drawmodes=\tikz@mode
			\let\pgfplots@drawoptions=\tikz@options
		}{}%
		%
		\def\pgfplotsplothandlermesh@ONEDIMMODE{0}%
		\ifnum\pgfplotsplothandlermesh@cols=1
			\def\pgfplotsplothandlermesh@ONEDIMMODE{1}%
		\fi
		\ifnum\pgfplotsplothandlermesh@rows=1
			\def\pgfplotsplothandlermesh@ONEDIMMODE{1}%
		\fi
		%
		%
		% Prepare color data source:
		\if\pgfplots@perpointmeta@choice0%
			% oh. There is no color data!? Well... then use a constant
			% color.
			% 
			% This activates tikz colors:
			%\tikz@options
			\def\pgfplotsplothandlermesh@preparedrawforcurrent{%
				\pgfplots@drawoptions
			}%
		\else
			% Ok, we have color data.
			%
			% Prepare:
			\pgfplots@perpointmeta@preparetrafo
			\def\pgfplotsplothandlermesh@preparedrawforcurrent{%
				\expandafter\pgfplotscolormapaccess\expandafter[\pgfplotspointmetatransformedrange]
					[1.0]
					{\pgfplotsplothandlermesh@shader@cellcolor}%
					{\pgfkeysvalueof{/pgfplots/colormap name}}
%\message{Color for current point is RGB '\pgfmathresult' (determined using meta 'phi(\pgfplotspointmeta) = \pgfplotspointmetatransformed'). metarange = [\pgfplots@metamin:\pgfplots@metamax] }%
				\def\pgfplots@loc@TMPb{\definecolor{mapped color}{rgb}}%
				\expandafter\pgfplots@loc@TMPb\expandafter{\pgfmathresult}%
%				\pgfplotsplothandlermesh@setcolor{mapped color}%
				% This activates tikz colors:
%\message{executing \meaning\pgfplots@drawoptions'}%
				%\tikz@options
				\pgfplots@drawoptions
			}%
			%
			% Acquire the values for \tikz@mode@* [used for faceted]
			\pgfplots@drawmodes
			% 
			% Now, process the 'shader'  key here:
			\if\pgfplotsplothandlermesh@ONEDIMMODE1
				\def\pgfplots@meshmode{m}% 'mesh'
			\fi
			\if\pgfplots@meshmode m% mesh
				% this is processed by the 'shader=flat' code below.
				\def\pgfplotsplothandlermesh@shader{0}% 'flat'
			\fi
			\if\pgfplotsplothandlermesh@shader2% 'shader=interp'
				\pgflibrarysurfshadingifactive
					{}%
					{%
						\pgfutil@ifundefined{pgfplotsplothandlermesh@shader@warning}{%
							\pgfplots@error{Sorry, surface shading (shader=interp) is NOT available for the selected driver `\pgfsysdriver'. I will use 'shader=flat' if you continue now}%
							\gdef\pgfplotsplothandlermesh@shader@warning{x}%
						}{}%
						\def\pgfplotsplothandlermesh@shader{0}%
					}%
			\fi
			\if\pgfplotsplothandlermesh@zbuffer@choice4% 'z buffer=sort':
				\if\pgfplotsplothandlermesh@shader2% 'shader=interp'
					\pgfplots@error{Sorry, 'shader=interp' does not support 'z buffer=sort'. If you continue now, 'shader=flat' will be used.}%
					\def\pgfplotsplothandlermesh@shader{0}% 'flat'
				\fi
			\fi
			\ifnum\pgfplotsplothandlermesh@shader<2
				% 0 == 'flat'
				% 1 == 'faceted'
				\if\pgfplotsplothandlermesh@flatmode c% 'flat corner':
					%
					% use colordata of ONE corner point. That's easy, not
					% much to do.
					\let\pgfplotsplothandlermesh@unpack=\pgfplotsplothandlermesh@unpack@corner
					\t@pgfplots@toka=\expandafter{\pgfplotsplothandlermesh@preparedrawforcurrent}%
					\t@pgfplots@tokb={%
						\pgfplots@perpointmeta@trafo@APPLY
						\let\pgfplotsplothandlermesh@shader@cellcolor=\pgfplotspointmetatransformed}%
					\edef\pgfplotsplothandlermesh@preparedrawforcurrent{%
						\the\t@pgfplots@tokb
						\the\t@pgfplots@toka
					}%
				\else
					% 'flat mean':
					%
					% use colordata as mean of all corners for shading.
					\let\pgfplotsplothandlermesh@unpack=\pgfplotsplothandlermesh@unpack@mean@accum
					\global\pgfplots@tmpa=0pt
					\t@pgfplots@toka=\expandafter{\pgfplotsplothandlermesh@preparedrawforcurrent}%
					\if\pgfplotsplothandlermesh@ONEDIMMODE0
						\t@pgfplots@tokb={\global\divide\pgfplots@tmpa by4 }%
					\else
						\t@pgfplots@tokb={\global\divide\pgfplots@tmpa by2 }%
					\fi
					\t@pgfplots@tokc={%
						\edef\pgfplotsplothandlermesh@shader@cellcolor{\pgf@sys@tonumber\pgfplots@tmpa}%
						\global\pgfplots@tmpa=0pt }%
					\edef\pgfplotsplothandlermesh@preparedrawforcurrent{%
						\the\t@pgfplots@tokb
						\the\t@pgfplots@tokc
						\the\t@pgfplots@toka
					}%
				\fi
				\if\pgfplots@meshmode m%
					% 'mesh' plot: stroke only and use the 'flat' code
					% here just to define the color for each mesh
					% segment.
					\let\pgfplotsplothandlermesh@usepath=\pgfusepathqstroke
				\else
					% 'surf' plot: 
					\let\pgfplotsplothandlermesh@usepath=\pgfusepathqfillstroke
					% the distinction between 'faceted' and 'flat' is
					% technical: it is just the default draw color.
					%
					% 'flat,draw=black' is the same as 'faceted'.
					\if\pgfplotsplothandlermesh@shader1% faceted
						% make sure there is a the correct color.
						\expandafter\def\expandafter\pgfplots@drawoptions\expandafter{%
							\pgfplots@drawoptions
							\pgfsetstrokecolor{\pgfkeysvalueof{/pgfplots/faceted color}}%
						}%
					\fi
				\fi
			\else
				% 'shader=2': 'interp':
				% very simple: defer work to surf library. Only
				% provide the mapped colordata.
				%
				% This won't be used for mesh plots, neither in one
				% nor in two dimensions.
				\pgfkeyssetvalue{/pgfplots/surf shading/north east corner}{\pgfplotspointbbupperright}%
				\pgfkeyssetvalue{/pgfplots/surf shading/south west corner}{\pgfplotspointbblowerleft}%
				\pgfkeyssetvalue{/pgfplots/surf shading/anchor}{\pgfpointorigin}%
				\pgfkeyslet{/pgfplots/surf shading/cols}\pgfplotsplothandlermesh@cols
				\pgfkeysgetvalue{/pgfplots/colormap name}\pgfplots@loc@TMPa
				\expandafter\pgfplotscolormaptopdffunction\expandafter{\pgfplots@loc@TMPa}%
				\pgfkeyslet{/pgfplots/surf shading/colormap}\pgfplotsretval
				\let\pgfplotsplothandlermesh@unpack=\relax % unused.
				\let\pgfplotsplothandlermesh@preparedrawforcurrent=\relax
				\global\let\pgf@plotstreampoint=\pgfplotsplothandlermesh@draw@lowlevelsurf%
				\pgfplotslibrarysurfstreamstart
				\let\pgfplotsplothandlermesh@usepath=\pgfusepathqfill
			\fi
		\fi
		% PREPARE THE STREAM PROCESSING:
		\if\pgfplotsplothandlermesh@ONEDIMMODE1%
			% Special case: 1D mesh processing
			\global\let\pgf@plotstreampoint=\pgfplotsplothandlermesh@ONEDIM@draw%
			\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
			\global\let\pgf@plotstreamend=\pgfplotsplothandlermesh@finish%
			\global\let\pgfplotsplothandlermesh@draw@element=\pgfplotsplothandlermesh@draw@element@line
			\if\pgfplotsplothandlermesh@zbuffer@choice4%
				% z buffer=sort:
				% create a z buffer:
				% the z buffer contains elements {<view depth>}{{<pt1>}{<pt2>}{<pt3>}{<pt4>}}
				\pgfplotsarraynewempty\pgfplots@zbuffer@local
			\fi
		\else
			% ok, normal 2D mesh processing:
			%
			% And now finally: initialise the conversion from 
			%  LINEARIZED COORD STREAM -> DATA MATRIX:
			\if\pgfplots@plot@mesh@ordering0%
				% rowwise:
				\let\pgfplotsplothandlermesh@scanlinelength=\pgfplotsplothandlermesh@cols
			\else
				% colwise:
				\let\pgfplotsplothandlermesh@scanlinelength=\pgfplotsplothandlermesh@rows
			\fi
			% Init memory:
			\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@scanlinelength\relax
			\advance\c@pgfplots@scanlineindex by1
			\pgfplotsdequenewempty{lastscanline}\capacity{\the\c@pgfplots@scanlineindex}%
			%
			\if2\pgfplotsplothandlermesh@shader
				% shader=interp  does not support z buffering.
				% It also has its own \pgf@plotstreampoint method, see
				% above.
			\else
				\global\let\pgf@plotstreampoint=\pgfplotsplothandlermesh@fillscanline%
				\if\pgfplotsplothandlermesh@zbuffer@choice4%
					% z buffer=sort:
					% create a z buffer:
					% the z buffer contains elements {<view depth>}{{<pt1>}{<pt2>}{<pt3>}{<pt4>}}
					\pgfplotsarraynewempty\pgfplots@zbuffer@local
				\fi
			\fi
			%
			\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
			\global\let\pgf@plotstreamend=\pgfplotsplothandlermesh@finish%
			\global\let\pgfplotsplothandlermesh@draw@element=\pgfplotsplothandlermesh@draw@element@rectangle
		\fi
		\c@pgfplots@scanlineindex=0
	}%
}%

\long\def\pgfplotsplothandlermesh@defaultlegend@img#1{%
	\scope[%
		#1,
		/pgfplots/mesh/rows=3,
		/pgfplots/mesh/cols=3,
		/pgfplots/mesh/num points=,
		/tikz/x={(0.44237cm,-0.07439cm)}, 
		/tikz/y={(0.30942cm,0.23932cm)},
		/tikz/z={(0.0cm,1.5cm)},
		scale=0.6,
		yshift=-0.5cm,
	]
	\let\pgfplots@metamax=\pgfutil@empty
	\pgfplots@curplot@threedimtrue

	\pgfplotsplothandlermesh
	\pgfplotstreamstart

	\def\rangea{0.21}%
	\def\rangeb{0.7}%

	\pgfmathparse{1000/(\rangeb-\rangea)}
	\let\factor=\pgfmathresult

	\pgfutil@ifundefined{pgfqpointxyz@orig}{%
		\let\pgfqpointxyz@orig=\pgfqpointxyz
	}{}%
	%
	\def\simplecoordinate(##1,##2,##3){%
		\pgfmathparse{\factor*(##3 - \rangea)}%
		\let\pgfplots@current@point@meta=\pgfmathresult
		% pgfplots changes \pgfqpointxyz to
		% \pgfplotspointdescriptionxy inside of legends, so use the
		% '@orig' point command:
		\pgfplotstreampoint{\pgfqpointxyz@orig{##1}{##2}{##3}}%
	}%
	% for the case 'shader=interp':
	\def\pgfplotspointbbupperright{\pgfqpointxyz@orig{2}{2}{0.9}}
	\def\pgfplotspointbblowerleft {\pgfqpointxyz@orig{0}{0}{0.1}}

	\simplecoordinate(0,2,0.7)
	\simplecoordinate(1,2,0.5)
	\simplecoordinate(2,2,0.43)

	\simplecoordinate(0,1,0.68)
	\simplecoordinate(1,1,0.4)
	\simplecoordinate(2,1,0.25)

	\simplecoordinate(0,0,0.6)
	\simplecoordinate(1,0,0.35)
	\simplecoordinate(2,0,0.21)

	\pgfplotstreamend
	\pgfusepath{stroke}
	\endscope
}%

\def\pgfplotsplothandlermesh@finish{%
	\ifnum\pgfplotsplothandlermesh@shader=2
		\pgfplotslibrarysurfstreamend
		\pgfplotslibrarysurfdrawinpicture
	\else
		\if\pgfplotsplothandlermesh@zbuffer@choice4%
			% z buffer=sort:
			% process the z buffer:
			\pgfkeyslet{/pgfplots/array/iflessthan/.@cmd}\pgfplotsplothandlermesh@zbuffer@sort@iflessthen
			\pgfkeysdef{/pgfplots/array/unscope pre}{%
				\pgfplotsarrayforeachungrouped\pgfplots@zbuffer@local\as\curelem{%
					\expandafter\pgfplotsplothandlermesh@draw@zbufferelement\curelem%
				}%
			}%
			\pgfkeysdef{/pgfplots/array/unscope post}{}%
			\pgfplotsarraysort\pgfplots@zbuffer@local
		\fi
	\fi
%	\endscope
}%

% the pgf@plotstreampoint routine for the first scan line:
\def\pgfplotsplothandlermesh@fillscanline#1{%
	\pgf@process{#1}%
	\edef\pgfplotsplothandlermesh@i@j{{\the\pgf@x}{\the\pgf@y}{\pgfplots@current@point@meta}}%
	\expandafter\pgfplotsdequepushback\pgfplotsplothandlermesh@i@j\to{lastscanline}%
	\advance\c@pgfplots@scanlineindex by1
	\ifnum\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@scanlinelength\relax
		% second line!
		\global\let\pgf@plotstreampoint=\pgfplotsplothandlermesh@draw%%
		\c@pgfplots@scanlineindex=0
	\fi
}%

% This is the pgf@plotstreampoint for all scan lines starting with the
% second.
%
% We perform
% for i = 1  to rows (note the 1! 0 would be the first row)
% 	for j = 0 to cols
% 		get (i-1, j) from front of deque // remember: i: rows, j : cols. We iterate rowwise.
% 		push (i,j) to back of deque
% 		if j > 0
% 			draw 
% 				(i-1,j-1) [from last iteration]  -- (i-1,j) [from deque]
% 			--  (  i,j-1) [from last iteration] --  (  i,j) [from #1]
% 		endif
% 		let (i-1,j-1) := (i-1,j) // for next iteration
% 		let (  i,j-1) := (  i,j) // for next iteration
% 	end
% end
%
% This is a SWEEP through the data matrix.
\def\pgfplotsplothandlermesh@draw#1{%
	% NOTATION: 
	% 	'im == (i-1)'
	% 	'jm == (j-1)'
	\pgf@process{#1}%
	\edef\pgfplotsplothandlermesh@i@j{{\the\pgf@x}{\the\pgf@y}{\pgfplots@current@point@meta}}% FIXME relies on pgfplots macros
%\message{##\the\c@pgfplots@scanlineindex: prepare rectangle with corner \pgfplotsplothandlermesh@i@j.}%
	\pgfplotsdequepopfront{lastscanline}\to\pgfplotsplothandlermesh@im@j
	\expandafter\pgfplotsdequepushback\pgfplotsplothandlermesh@i@j\to{lastscanline}%
	\ifnum\c@pgfplots@scanlineindex>0
		\if\pgfplotsplothandlermesh@zbuffer@choice4%
			% z buffer=sort:
			\pgfplotsmathviewdepthxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@current@point@z}% FIXME relies on pgfplots macros
			% assemble array element:
			\edef\pgfplots@loc@TMPa{%
				{\pgfmathresult}%
				{%
					{\pgfplotsplothandlermesh@im@jm}%
					{\pgfplotsplothandlermesh@im@j}%
					{\pgfplotsplothandlermesh@i@j}%
					{\pgfplotsplothandlermesh@i@jm}%
				}%
			}%
			\expandafter\pgfplotsarraypushback\pgfplots@loc@TMPa\to\pgfplots@zbuffer@local
		\else
			\pgfplotsplothandlermesh@draw@element
				\pgfplotsplothandlermesh@im@jm
				\pgfplotsplothandlermesh@im@j
				\pgfplotsplothandlermesh@i@j
				\pgfplotsplothandlermesh@i@jm
		\fi
	\fi
	\let\pgfplotsplothandlermesh@im@jm=\pgfplotsplothandlermesh@im@j
	\let\pgfplotsplothandlermesh@i@jm=\pgfplotsplothandlermesh@i@j
	\advance\c@pgfplots@scanlineindex by1
	\ifnum\c@pgfplots@scanlineindex=\pgfplotsplothandlermesh@scanlinelength\relax
		\c@pgfplots@scanlineindex=0
	\fi
}%
\def\pgfplotsplothandlermesh@draw@lowlevelsurf#1{%
	\pgfplots@perpointmeta@trafo@APPLY
	\pgfplotslibrarysurfstreamcoord{#1}{\pgfplotspointmetatransformed}%
}%

\def\pgfplotsplothandlermesh@draw@zbufferelement#1#2{%
	\pgfplotsplothandlermesh@draw@element#2\relax
}%
% a possible value for \pgfplotsplothandlermesh@draw@element
\def\pgfplotsplothandlermesh@draw@element@line#1#2{%
	\pgfpathmoveto{\expandafter\pgfplotsplothandlermesh@unpack#1}%
	\pgfpathlineto{\expandafter\pgfplotsplothandlermesh@unpack#2}%
	\pgfplotsplothandlermesh@preparedrawforcurrent
	\pgfplotsplothandlermesh@usepath
}%
% a possible value for \pgfplotsplothandlermesh@draw@element
\def\pgfplotsplothandlermesh@draw@element@rectangle#1#2#3#4{%
	\pgfpathmoveto{\expandafter\pgfplotsplothandlermesh@unpack#1}%
	\pgfpathlineto{\expandafter\pgfplotsplothandlermesh@unpack#2}%
	\pgfpathlineto{\expandafter\pgfplotsplothandlermesh@unpack#3}%
	\pgfpathlineto{\expandafter\pgfplotsplothandlermesh@unpack#4}%
	\pgfplotsplothandlermesh@preparedrawforcurrent
	\pgfpathclose
	\pgfplotsplothandlermesh@usepath
}%

\def\pgfplotsplothandlermesh@zbuffer@sort@iflessthen#1#2#3#4\pgfeov{%
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@\pgfplots@loc@TMPa\relax
	\let\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@a=\pgfmathresult
	\edef\pgfplots@loc@TMPb{#2}%
	\expandafter\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@\pgfplots@loc@TMPb\relax
	\let\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@b=\pgfmathresult
	\ifdim\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@b pt<\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@a pt%
		#3\relax
	\else
		#4\relax
	\fi
}%
\def\pgfplotsplothandlermesh@zbuffer@sort@iflessthen@#1#2{%
	\def\pgfmathresult{#1}%
}%

% #1: projected x coord
% #2: projected y coord
% #3: per point meta (if any)
\def\pgfplotsplothandlermesh@unpack@corner#1#2#3{%
	\pgf@x=#1\relax
	\pgf@y=#2\relax
}%
\def\pgfplotsplothandlermesh@unpack@mean@accum#1#2#3{%
	\pgf@x=#1\relax
	\pgf@y=#2\relax
	\def\pgfplots@current@point@meta{#3}%
	\pgfplots@perpointmeta@trafo@APPLY
	\global\advance\pgfplots@tmpa by\pgfplotspointmetatransformed pt
}%
% same as above, just for one dim plots (rows == 1 || cols==1)
\def\pgfplotsplothandlermesh@ONEDIM@draw#1{%
	\pgf@process{#1}%
	\edef\pgfplotsplothandlermesh@i{{\the\pgf@x}{\the\pgf@y}{\pgfplots@current@point@meta}}%
	\ifnum\c@pgfplots@scanlineindex>0
		\if\pgfplotsplothandlermesh@zbuffer@choice4%
			% z buffer=sort:
			\pgfplotsmathviewdepthxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@current@point@z}% FIXME relies on pgfplots macros
			% assemble array element:
			\edef\pgfplots@loc@TMPa{%
				{\pgfmathresult}%
				{%
					{\pgfplotsplothandlermesh@i}%
					{\pgfplotsplothandlermesh@im}%
				}%
			}%
			\expandafter\pgfplotsarraypushback\pgfplots@loc@TMPa\to\pgfplots@zbuffer@local
		\else
			\pgfplotsplothandlermesh@draw@element
				\pgfplotsplothandlermesh@i
				\pgfplotsplothandlermesh@im
		\fi
	\fi
	\let\pgfplotsplothandlermesh@im=\pgfplotsplothandlermesh@i
	\advance\c@pgfplots@scanlineindex by1
}%

% #1: a normalized coordinate stream.
%
% Output: a normalized coordinate stream in \pgfplotsretval.
\def\pgfplots@apply@zbuffer#1{%
	\let\pgfplots@apply@zbuffer@start@BACKUP=\pgfplots@coord@stream@start
	\let\pgfplots@apply@zbuffer@end@BACKUP=\pgfplots@coord@stream@end
	\let\pgfplots@apply@zbuffer@coord@BACKUP=\pgfplots@coord@stream@coord
	\let\pgfplots@current@point@x=\pgfutil@empty
	\let\pgfplots@current@point@y=\pgfutil@empty
	\let\pgfplots@current@point@z=\pgfutil@empty
	\let\pgfplots@current@point@meta=\pgfutil@empty
	%
	\ifcase\pgfplotsplothandlermesh@zbuffer@choice\relax
		% none.
		\gdef\pgfplotsretval{#1}%
	\or
		% reverse x seq: only for 'mesh'
		% FIXME IMPLEMENT!
		\if\pgfplots@meshmode n%
			\pgfplots@error{Sorry, `/pgfplots/z buffer=reverse x seq' can only be used for mesh/surf plots.}%
		\fi
		\gdef\pgfplotsretval{#1}%
	\or
		% reverse y seq: only for 'mesh'
		\if\pgfplots@meshmode n%
			\pgfplots@error{Sorry, `/pgfplots/z buffer=reverse y seq' can only be used for mesh/surf plots.}%
		\fi
		\gdef\pgfplotsretval{#1}%
	\or
		% reverse xy seq:
		\def\pgfplots@coord@stream@start{%
			\pgfplotsprependlistXnewempty{reversed}%
		}%
		\def\pgfplots@coord@stream@coord{%
			\edef\pgfplots@loc@TMPa{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z,\pgfplots@current@point@meta;}%
			\expandafter\pgfplotsprependlistXpushfront\expandafter{\pgfplots@loc@TMPa}\to{reversed}%
		}%
		\def\pgfplots@coord@stream@end{%
			\pgfplotsprependlistXlet\pgfplots@loc@TMPa={reversed}%
			\pgfplotsprependlistXnewempty{reversed}% clear it
			\global\let\pgfplotsretval=\pgfplots@loc@TMPa
		}%
		\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
	\or
		% sort.
		\if\pgfplots@meshmode n%
			\begingroup
			\def\pgfplots@coord@stream@start{%
				\pgfplotsarraynewempty\pgfplots@zbuffer@local
				\pgfplotsarrayresize\pgfplots@zbuffer@local{\numcoords}%
				\c@pgfplots@scanlineindex=0
				\def\pgfplots@zbuffer@local@SETCUR####1{%
					\expandafter\pgfplotsarrayset\c@pgfplots@scanlineindex\of\pgfplots@zbuffer@local\to{####1}%
				}%
			}%
			\def\pgfplots@coord@stream@coord{%
				\edef\pgfplots@loc@TMPa{\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z,\pgfplots@current@point@meta;}%
				\expandafter\pgfplots@zbuffer@local@SETCUR\expandafter{\pgfplots@loc@TMPa}%
				\advance\c@pgfplots@scanlineindex by1
			}%
			\def\pgfplots@coord@stream@end{%
				\ifnum\c@pgfplots@scanlineindex=\numcoords
				\else
					\pgfplots@error{INTERNAL LOGIC ERROR: either \string\numcoords=\numcoords\space is wrong or the z buffer algorithm failed.}%
				\fi
				\pgfkeyslet{/pgfplots/array/iflessthan/.@cmd}\pgfplots@apply@zbuffer@SORT@iflessthan
				\pgfkeysdef{/pgfplots/array/unscope pre}{%
					\pgfplotsapplistXnewempty{\pgfp@sortedlist}%
					\pgfplotsarrayforeachungrouped\pgfplots@zbuffer@local\as\curelem{%
						\expandafter\pgfplotsapplistXpushback\curelem\to{\pgfp@sortedlist}%
					}%
					\pgfplotsapplistXlet\pgfplots@loc@TMPa={\pgfp@sortedlist}%
					\global\let\pgfplotsretval=\pgfplots@loc@TMPa
				}%
				\pgfkeysdef{/pgfplots/array/unscope post}{}%
				\pgfplotsarraysort\pgfplots@zbuffer@local
			}%
			\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
			\endgroup
		\else
			% meshmode handles sort separately!
			\gdef\pgfplotsretval{#1}%
		\fi
	\fi
	\let\pgfplots@coord@stream@start=\pgfplots@apply@zbuffer@start@BACKUP
	\let\pgfplots@coord@stream@end=\pgfplots@apply@zbuffer@end@BACKUP
	\let\pgfplots@coord@stream@coord=\pgfplots@apply@zbuffer@coord@BACKUP
}%

% A special '<' operation which returns true if the point coordinate
% '#1' is BEHIND #2 with respect to the current 3D view.
\def\pgfplots@apply@zbuffer@SORT@iflessthan#1#2#3#4\pgfeov{%
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplots@apply@zbuffer@SORT@iflessthan@\pgfplots@loc@TMPa\relax
	\let\pgfplots@apply@zbuffer@SORT@iflessthan@a=\pgfmathresult
	\edef\pgfplots@loc@TMPb{#2}%
	\expandafter\pgfplots@apply@zbuffer@SORT@iflessthan@\pgfplots@loc@TMPb\relax
	\let\pgfplots@apply@zbuffer@SORT@iflessthan@b=\pgfmathresult
	\pgfmathfloatlessthan@{\pgfplots@apply@zbuffer@SORT@iflessthan@b}{\pgfplots@apply@zbuffer@SORT@iflessthan@a}%
	\ifpgfmathfloatcomparison
		#3\relax
	\else
		#4\relax
	\fi
}%

% returns the view depth of the provided serialized coordinate into
% \pgfmathresult
%
% FIXME : relies on the internal repr in
% \pgfplots@coord@stream@foreach@NORMALIZED :
\def\pgfplots@apply@zbuffer@SORT@iflessthan@#1,#2,#3,#4;{%
	\pgfplotsmathfloatviewdepthxyz{#1}{#2}{#3}%
}%

% Defines \pgfmathresult to be the view depth of a three component
% vector. The third component will be used if and only if the boolean
% \ifpgfplots@curplot@threedim is true.
% The return value will be assigned in floating point.
%
% @see \pgfplotsmathviewdepthxyz
\def\pgfplotsmathfloatviewdepthxyz#1#2#3{%
	\pgfplots@error{Sorry, you can't use \string\pgfplotsmathfloatviewdepthxyz\space in this context.}%
}%

\def\pgfplotsmathfloatviewdepthxyz@infigure#1#2#3{%
	% FIXME : that operates only in float. Provide special cases for
	% fixed!
	\pgfmathfloatmultiplyfixed@{#1}{\pgfplots@view@dir@threedim@x}%
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfmathfloatmultiplyfixed@{#2}{\pgfplots@view@dir@threedim@y}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmathfloatadd@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfmathfloatmultiplyfixed@{#3}{\pgfplots@view@dir@threedim@z}%
		\let\pgfplots@loc@TMPc=\pgfmathresult
		\pgfmathfloatadd@{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
		\let\pgfplots@loc@TMPb=\pgfmathresult
	\fi
	\let\pgfplotslocretval=\pgfplots@loc@TMPb
}%

% Similar to \pgfplotsmathfloatviewdepthxyz, but this always relies on
% fixed point arithmetics.
\def\pgfplotsmathviewdepthxyz#1#2#3{%
	\pgfplots@error{Sorry, you can't use \string\pgfplotsmathviewdepthxyz\space in this context.}%
}
\def\pgfplotsmathviewdepthxyz@infigure#1#2#3{%
	\pgfmath@basic@multiply@{#1}{\pgfplots@view@dir@threedim@x}%
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfmath@basic@multiply@{#2}{\pgfplots@view@dir@threedim@y}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmath@basic@add@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfmath@basic@multiply@{#3}{\pgfplots@view@dir@threedim@z}%
		\let\pgfplots@loc@TMPc=\pgfmathresult
		\pgfmath@basic@add@{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
		\let\pgfplots@loc@TMPb=\pgfmathresult
	\fi
	\let\pgfplotslocretval=\pgfplots@loc@TMPb
}%
